From 18154280b55d40dd554af69c7ffdacca83cc9c64 Mon Sep 17 00:00:00 2001
From: Maxime Gauduin <alucryd@archlinux.org>
Date: Fri, 7 Aug 2015 11:29:52 +0200
Subject: [PATCH 1/3] Modify hardcoded paths via Makefile

---
 Makefile               |   34 +-
 thinkpad-radiosw       |    4 -
 thinkpad-radiosw.in    |    4 +
 thinkpad-radiosw.sh    |   46 -
 thinkpad-radiosw.sh.in |   46 +
 tlp                    |  288 ------
 tlp-functions          | 2413 ------------------------------------------------
 tlp-functions.in       | 2413 ++++++++++++++++++++++++++++++++++++++++++++++++
 tlp-nop                |   26 -
 tlp-nop.in             |   26 +
 tlp-rdw-nm             |  119 ---
 tlp-rdw-nm.in          |  119 +++
 tlp-rdw-udev           |  101 --
 tlp-rdw-udev.in        |  101 ++
 tlp-rdw.rules          |   27 -
 tlp-rdw.rules.in       |   27 +
 tlp-rf                 |   56 --
 tlp-rf.in              |   56 ++
 tlp-run-on             |   57 --
 tlp-run-on.in          |   57 ++
 tlp-sleep.service      |   18 -
 tlp-sleep.service.in   |   18 +
 tlp-stat               | 1194 ------------------------
 tlp-stat.in            | 1194 ++++++++++++++++++++++++
 tlp-usb-udev           |  152 ---
 tlp-usb-udev.in        |  152 +++
 tlp.in                 |  288 ++++++
 tlp.rules              |   10 -
 tlp.rules.in           |   10 +
 tlp.service            |   19 -
 tlp.service.in         |   19 +
 tlp.upstart            |   25 -
 tlp.upstart.in         |   25 +
 33 files changed, 4583 insertions(+), 4561 deletions(-)
 delete mode 100644 thinkpad-radiosw
 create mode 100644 thinkpad-radiosw.in
 delete mode 100755 thinkpad-radiosw.sh
 create mode 100755 thinkpad-radiosw.sh.in
 delete mode 100755 tlp
 delete mode 100755 tlp-functions
 create mode 100755 tlp-functions.in
 delete mode 100755 tlp-nop
 create mode 100755 tlp-nop.in
 delete mode 100755 tlp-rdw-nm
 create mode 100755 tlp-rdw-nm.in
 delete mode 100755 tlp-rdw-udev
 create mode 100755 tlp-rdw-udev.in
 delete mode 100644 tlp-rdw.rules
 create mode 100644 tlp-rdw.rules.in
 delete mode 100755 tlp-rf
 create mode 100755 tlp-rf.in
 delete mode 100755 tlp-run-on
 create mode 100755 tlp-run-on.in
 delete mode 100644 tlp-sleep.service
 create mode 100644 tlp-sleep.service.in
 delete mode 100755 tlp-stat
 create mode 100755 tlp-stat.in
 delete mode 100755 tlp-usb-udev
 create mode 100755 tlp-usb-udev.in
 create mode 100755 tlp.in
 delete mode 100644 tlp.rules
 create mode 100644 tlp.rules.in
 delete mode 100644 tlp.service
 create mode 100644 tlp.service.in
 delete mode 100644 tlp.upstart
 create mode 100644 tlp.upstart.in

diff --git a/Makefile b/Makefile
index 149e668..07bc9d1 100644
--- a/Makefile
+++ b/Makefile
@@ -1,9 +1,5 @@
 # Makefile for TLP
 
-# Important: solely changing destination paths via parameter will
-#   render the installation unusable. You have to change several
-#   definitions and absolute paths in scripts too!
-
 # Evaluate parameters
 TLP_LIBDIR ?= /usr/lib
 TLP_SBIN   ?= /usr/sbin
@@ -29,12 +25,40 @@ _CONF  = $(DESTDIR)$(TLP_CONF)
 _SYSD  = $(DESTDIR)$(TLP_SYSD)
 _SHCPL = $(DESTDIR)$(TLP_SHCPL)
 
+SED = sed \
+	-e "s|@TLP_SBIN@|$(TLP_SBIN)|g" \
+	-e "s|@TLP_TLIB@|$(TLP_TLIB)|g" \
+	-e "s|@TLP_PLIB@|$(TLP_PLIB)|g" \
+	-e "s|@TLP_ULIB@|$(TLP_ULIB)|g" \
+	-e "s|@TLP_ACPI@|$(TLP_ACPI)|g" \
+	-e "s|@TLP_CONF@|$(TLP_CONF)|g"
+
+INFILES = \
+	thinkpad-radiosw \
+	thinkpad-radiosw.sh \
+	tlp \
+	tlp-functions \
+	tlp-nop \
+	tlp-rdw-nm \
+	tlp-rdw-udev \
+	tlp-rf \
+	tlp-run-on \
+	tlp-stat \
+	tlp-usb-udev \
+	tlp.rules \
+	tlp-rdw.rules \
+	tlp.service \
+	tlp-sleep.service \
+	tlp.upstart
+
 # Make targets
 all:
-	@true
+	for f in $(INFILES); do \
+		$(SED) $$f.in > $$f; \
+	done
 
 clean:
-	@true
+	rm $(INFILES)
 
 install-tlp:
 	# Package tlp
diff --git a/thinkpad-radiosw b/thinkpad-radiosw
deleted file mode 100644
index de4e5ef..0000000
--- a/thinkpad-radiosw
+++ /dev/null
@@ -1,4 +0,0 @@
-# handle ThinkPad hardware radio switch
-event=ibm/hotkey HKEY 00000080 00007000
-action=/etc/acpi/thinkpad-radiosw.sh
-
diff --git a/thinkpad-radiosw.in b/thinkpad-radiosw.in
new file mode 100644
index 0000000..4d6e5bd
--- /dev/null
+++ b/thinkpad-radiosw.in
@@ -0,0 +1,4 @@
+# handle ThinkPad hardware radio switch
+event=ibm/hotkey HKEY 00000080 00007000
+action=@TLP_ACPI@/thinkpad-radiosw.sh
+
diff --git a/thinkpad-radiosw.sh b/thinkpad-radiosw.sh
deleted file mode 100755
index 5511c06..0000000
--- a/thinkpad-radiosw.sh
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/bin/sh
-# thinkpad-radiosw.sh - handle ThinkPad hardware radio switch
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-[ -d $libdir ] || exit 0
-
-for lib in $LIBS; do
-    [ -f $libdir/$lib ] || exit 0
-    . $libdir/$lib
-done
-
-read_defaults || exit 0
-
-[ "$TLP_ENABLE" = "1" ] || exit 0
-
-sleep 2 # Allow some time for rfkill state to settle
-
-for dev in bluetooth wifi wwan; do
-    get_devc $dev
-    get_devs $dev
-
-    case $devs in
-        2) # Hardware radio switch was turned off, do nothing
-            echo_debug "rf" "thinkpad-radiosw: off"
-            exit 0
-            ;;
-
-        0|1) # Hardware radio switch was turned on, exit loop
-            break
-            ;;
-
-        *) ;; # No device, continue loop
-    esac
-done
-
-# Disable configured radios
-echo_debug "rf" "thinkpad-radiosw: on"
-set_radio_devices_state radiosw
-
-exit 0
diff --git a/thinkpad-radiosw.sh.in b/thinkpad-radiosw.sh.in
new file mode 100755
index 0000000..3040251
--- /dev/null
+++ b/thinkpad-radiosw.sh.in
@@ -0,0 +1,46 @@
+#!/bin/sh
+# thinkpad-radiosw.sh - handle ThinkPad hardware radio switch
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+[ -d $libdir ] || exit 0
+
+for lib in $LIBS; do
+    [ -f $libdir/$lib ] || exit 0
+    . $libdir/$lib
+done
+
+read_defaults || exit 0
+
+[ "$TLP_ENABLE" = "1" ] || exit 0
+
+sleep 2 # Allow some time for rfkill state to settle
+
+for dev in bluetooth wifi wwan; do
+    get_devc $dev
+    get_devs $dev
+
+    case $devs in
+        2) # Hardware radio switch was turned off, do nothing
+            echo_debug "rf" "thinkpad-radiosw: off"
+            exit 0
+            ;;
+
+        0|1) # Hardware radio switch was turned on, exit loop
+            break
+            ;;
+
+        *) ;; # No device, continue loop
+    esac
+done
+
+# Disable configured radios
+echo_debug "rf" "thinkpad-radiosw: on"
+set_radio_devices_state radiosw
+
+exit 0
diff --git a/tlp b/tlp
deleted file mode 100755
index fb63a02..0000000
--- a/tlp
+++ /dev/null
@@ -1,288 +0,0 @@
-#!/bin/sh
-# tlp - adjust power settings
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-# --- Locate and source libraries
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-if [ ! -d $libdir ]; then
-    echo "Error: missing library directory ($LIBDIRS)." 1>&2
-    exit 1
-fi
-
-for lib in $LIBS; do
-    if [ ! -f $libdir/$lib ]; then
-        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
-        exit 1
-    fi
-    . $libdir/$lib
-done
-
-# --- Subroutines
-apply_common_settings () { # apply settings common to all modes
-                           # $1: 0=ac mode, 1=battery mode
-    load_modules
-
-    set_laptopmode $1
-    set_dirty_parms $1
-    set_scaling_governor $1
-    set_scaling_min_max_freq $1
-    set_cpu_perf_pct $1
-    set_cpu_boost_all $1
-    set_sched_powersave $1
-    set_nmi_watchdog
-    set_phc_controls $1
-    set_energy_perf_policy $1
-    set_disk_apm_level $1
-    set_disk_spindown_timeout $1
-    set_disk_io_sched
-    set_sata_link_power $1
-    set_pcie_aspm $1
-    set_radeon_profile $1
-    set_wifi_power_mode $1
-    disable_wake_on_lan
-    set_sound_power_mode $1
-    set_runtime_pm $1
-
-    return 0
-}
-
-# --- MAIN
-read_defaults
-check_tlp_enabled || exit 1
-add_sbin2path
-
-check_laptop_mode_tools
-
-# get cmd line args
-mode=$(echo $1 | tr "[:upper:]" "[:lower:]")
-mode2=$(echo $2 | tr "[:upper:]" "[:lower:]")
-
-# inhibit trace output for tlp stat
-[ "$mode" = "stat" ] && nodebug=1
-
-# get current power state
-get_power_state
-pwrmode=$?
-
-modedebug=$mode
-[ -n "$mode2" ] && modedebug="$modedebug $mode2"
-echo_debug "run" "+++ mode=$modedebug ($TLPVER) ++++++++++++++++++++++++++++++++++++++++"
-
-if [ -n "$addpath" ]; then
-    echo_debug "path" "PATH=$oldpath[$addpath]"
-else
-    echo_debug "path" "PATH=$oldpath"
-fi
-
-if [ $pwrmode -eq 1 ]; then
-    echo_debug "run" "power_source=bat"
-else
-    echo_debug "run" "power_source=ac"
-fi
-
-exitcode=0
-
-case "$mode" in
-    init) # system initialization/shutdown: sysv, upstart, systemd, ...
-        check_root
-
-        case $mode2 in
-            start|restart|force-reload)
-                echo -n "Loading kernel modules..."
-                load_modules
-                echo "done. "
-
-                # apply settings
-                set_radio_device_states start
-
-                echo -n "Applying power save settings..."
-                apply_common_settings $pwrmode
-                [ "$pwrmode" = "1" ] && poweroff_drivebay 0
-                [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
-                echo "done."
-
-                echo -n "Setting battery charge thresholds..."
-                set_charge_thresholds
-                echo "done."
-                ;;
-
-            stop)
-                set_radio_device_states stop
-
-                if [ "$USB_AUTOSUSPEND_DISABLE_ON_SHUTDOWN" = "1" ]; then
-                    echo -n "Disabling usb autosuspend..."
-                    set_usb_suspend 0 on
-                    echo "done."
-                fi
-
-                # remove usb startup flag
-                [ -f $USB_DONE ] && rm $USB_DONE
-
-                # apply ac settings for faster shutdown
-                echo -n "Applying power save settings..."
-                apply_common_settings 0
-                echo "done."
-                ;;
-
-            *)
-                echo "Usage: tlp init {start|stop|restart|force-reload}" >&2
-                exit 3
-                ;;
-        esac
-        ;;
-
-    auto) # set mode depending on state (called by udev rule)
-        check_root
-        apply_common_settings $pwrmode
-        [ "$pwrmode" = "1" ] && poweroff_drivebay 0
-        set_radio_device_states $pwrmode
-        ;;
-
-    start) # set mode depending on state (interactive mode)
-        check_root
-        apply_common_settings $pwrmode
-        [ "$pwrmode" = "1" ] && poweroff_drivebay 0
-        set_usb_suspend 0 auto
-        set_charge_thresholds
-        set_radio_device_states $pwrmode
-
-        echo_started_mode $pwrmode
-        ;;
-
-    true|bat*) # set battery power mode
-        check_root
-        apply_common_settings 1
-        poweroff_drivebay 0
-        [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
-        set_radio_device_states 1
-
-        echo_started_mode 1
-        ;;
-
-    false|ac) # set ac power mode
-        check_root
-        apply_common_settings 0
-        [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
-        set_radio_device_states 0
-
-        echo_started_mode 0
-        ;;
-
-    suspend) # handle suspend/hibernate
-        check_root
-        save_device_states "bluetooth wwan"
-
-        get_power_state
-        pwrmode=$?
-        apply_common_settings 0
-        suspend_drivebay $pwrmode
-        ;;
-
-    resume) # handle resume
-        check_root
-        restore_device_states
-
-        get_power_state
-        pwrmode=$?
-        apply_common_settings $pwrmode
-        resume_drivebay
-        ;;
-
-    usb) # Enable usb autosuspend
-        check_root
-        set_usb_suspend 1 auto
-        ;;
-
-    bayoff) # power off drive bay
-        check_root
-        poweroff_drivebay 1
-        ;;
-
-    setcharge) # set charge thresholds (temporarily)
-        check_root
-        load_modules
-        setcharge_battery $2 $3 $4
-        exitcode=$?
-        ;;
-
-    fullcharge) # charge battery up to 100% (temporarily)
-        if check_ac_power fullcharge; then
-            check_root
-            load_modules
-            setcharge_battery 96 100 $2
-            exitcode=$?
-        else
-            exitcode=2
-        fi
-        ;;
-
-    chargeonce) # charge battery to upper threshold once
-        if check_ac_power chargeonce; then
-            check_root
-            load_modules
-            chargeonce_battery $2
-            exitcode=$?
-        else
-            exitcode=2
-        fi
-        ;;
-
-    discharge) # discharge battery completely (to recalibrate)
-        if check_ac_power discharge; then
-            check_root
-            load_modules
-            discharge_battery $2
-            exitcode=$?
-        else
-            exitcode=2
-        fi
-        ;;
-
-    recalibrate) # recalibrate battery, i.e. discharge and charge to 100%
-        if check_ac_power recalibrate; then
-            check_root
-            load_modules
-            setcharge_battery 96 100 $2
-            sleep 1
-            discharge_battery $2
-            exitcode=$?
-            if [ $exitcode -eq 0 ]; then
-                echo "      The battery starts charging now. For a complete recalibration"
-                echo "      keep AC connected until the battery is fully charged."
-            fi
-        else
-            exitcode=2
-        fi
-        ;;
-
-    stat) # show status
-        shift
-        tlp-stat $*
-        exitcode=$?
-        ;;
-
-    diskid) # show disk-by-id
-        { for dev in $(ls /dev/disk/by-id/ | egrep '^ata' | egrep -v '\-part[1-9]+'); do
-            if [ -n "$dev" ]; then
-                get_disk_dev $dev
-                echo "$disk_dev: $disk_id"
-            fi
-        done } | sort
-        ;;
-
-    *)
-        echo "Error: unknown command \"$mode\"."  1>&2
-        echo "Usage: tlp start|true|bat|false|ac|usb|bayoff|discharge|setcharge|fullcharge|recalibrate|stat|diskid" 1>&2
-        exitcode=3
-        ;;
-esac
-
-exit $exitcode
-
-
diff --git a/tlp-functions b/tlp-functions
deleted file mode 100755
index 11c248e..0000000
--- a/tlp-functions
+++ /dev/null
@@ -1,2413 +0,0 @@
-#!/bin/sh
-# tlp - power management functions
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-#
-# Some concepts and descriptions were adapted from:
-# - laptop-mode-tools
-# - thinkwiki.org
-
-# ----------------------------------------------------------------------------
-# Constants
-
-readonly TLPVER="0.8"
-
-readonly CONFFILE=/etc/default/tlp
-readonly RUNDIR=/var/run/tlp
-
-readonly ETHTOOL=ethtool
-readonly HDPARM=hdparm
-readonly IWC=iwconfig
-readonly IW=iw
-readonly MODPRO=modprobe
-readonly LOGGER=logger
-readonly UDEVADM=udevadm
-readonly LAPMODE=laptop_mode
-readonly NMCLI=nmcli
-readonly NMD=NetworkManager
-readonly NMTOOL=nm-tool
-readonly ENERGYPERF=x86_energy_perf_policy
-readonly DBUSSEND=dbus-send
-readonly SYSTEMD=systemd
-readonly SYSTEMCTL=systemctl
-readonly INITCTL=initctl
-
-readonly TPACPIBAT=$libdir/tpacpi-bat # libdir is initialized by main program
-
-readonly TPACPIDIR=/sys/devices/platform/thinkpad_acpi
-readonly SMAPIDIR=/sys/devices/platform/smapi
-readonly ACPIBATDIR=/sys/class/power_supply
-readonly NETD=/sys/class/net
-readonly BLUETOOTHD=/sys/class/bluetooth
-readonly PCID=/sys/bus/pci/devices
-readonly PCIDRV=/sys/bus/pci/drivers
-readonly I915D=/sys/module/i915/parameters
-readonly RADD=/sys/module/radeon
-readonly DMID=/sys/class/dmi/id/
-readonly CPU_BOOST_ALL_CTRL=/sys/devices/system/cpu/cpufreq/boost
-readonly INTEL_PSTATED=/sys/devices/system/cpu/intel_pstate
-readonly CPU_MIN_PERF_PCT=$INTEL_PSTATED/min_perf_pct
-readonly CPU_MAX_PERF_PCT=$INTEL_PSTATED/max_perf_pct
-readonly CPU_TURBO_PSTATE=$INTEL_PSTATED/no_turbo
-
-readonly USBD=/sys/bus/usb/devices
-readonly USB_TIMEOUT=2
-readonly USB_TIMEOUT_MS=2000
-readonly USB_WWAN_VENDORS="0bdb 05c6 1199"
-readonly USB_DONE=usb_done
-
-readonly DOCKGLOB="/sys/devices/platform/dock.?"
-
-readonly MODULES="acpi_call coretemp msr thinkpad_acpi tp_smapi"
-
-readonly STATEDIR="/var/lib/tlp"
-readonly RFSTATEFILE=$STATEDIR/rfkill-saved
-readonly BAYSTATEFILE=$STATEDIR/bay-saved
-
-readonly DISK_NOP_WORDS="_ keep"
-readonly DEFAULT_DISK_DEVICES="sda"
-readonly DEFAULT_DISK_IO_SCHEDULER="cfq"
-readonly DEFAULT_PM_DRIVER_BLACKLIST="radeon nouveau"
-readonly DEFAULT_USB_DRIVER_BLACKLIST="usbhid"
-
-# ----------------------------------------------------------------------------
-# Control
-nodebug=0
-
-# ----------------------------------------------------------------------------
-# Functions
-
-# --- Tests
-
-wordinlist () { # test if word in list
-                # $1: word, $2: whitespace-separated list of words
-    local word
-
-    if [ -n "${1-}" ]; then
-        for word in ${2-}; do
-            [ "${word}" != "${1}" ] || return 0 # exact match
-        done
-    fi
-
-    return 1 # no match
-}
-
-echo_debug () { # write debug msg if tag matches -- $1: tag; $2: msg;
-    [ "$nodebug" = "1" ] && return 0
-
-    if wordinlist "$1" "$TLP_DEBUG"; then
-        $LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
-    fi
-}
-
-cmd_exists () { # test if command exists -- $1: command
-    command -v $1 > /dev/null 2>&1
-}
-
-check_sysfs ()  { # check if sysfile exists -- $1: routine; $2: sysfs path
-    if wordinlist "sysfs" "$TLP_DEBUG"; then
-        if [ ! -e $2 ]; then
-            $LOGGER -p debug -t "tlp[$$,$PPID]" "$1: $2 nonexistent"
-        fi
-    fi
-}
-
-test_root () { # test root privilege -- rc: 0=root, 1=not root
-    [ "$(id -u)" = "0" ]
-}
-
-check_root () { # show error message and exit when root privilege missing
-    if ! test_root; then
-        echo "Error: missing root privilege." 1>&2
-        exit 1
-    fi
-}
-
-check_tlp_enabled () { # check if TLP is enabled in config file
-    # rc: 0=disabled/1=enabled
-
-    if [ ! "$TLP_ENABLE" = "1" ]; then
-        echo "Error: TLP power save is disabled. Set TLP_ENABLE=1 in $CONFFILE." 1>&2
-        return 1
-    else
-        return 0
-    fi
-}
-
-check_laptop_mode_tools () { # check if lmt installed -- rc: 0=not installed, 1=installed
-    if cmd_exists $LAPMODE; then
-        echo 1>&2
-        echo "***Warning: laptop-mode-tools detected, this may cause conflicts with TLP." 1>&2
-        echo "            Please uninstall laptop-mode-tools." 1>&2
-        echo 1>&2
-        echo_debug "pm" "check_laptop_mode_tools: yes"
-        return 1
-    else
-        return 0
-    fi
-}
-
-check_systemd () { # check if systemd is the active init system (PID 1) and systemctl is installed
-                   # rc: 0=yes, 1=no
-    [ -d /run/systemd/system ] && cmd_exists $SYSTEMCTL
-}
-
-check_upstart () { # check if upstart is active init system (PID 1)
-                   # rc: 0=yes, 1=no
-    cmd_exists $INITCTL && $INITCTL --version | grep -q upstart
-}
-
-check_openrc () { # check if openrc is the active init system (PID 1)
-                   # rc: 0=yes, 1=no
-    [ -e /run/openrc/softlevel ]
-}
-
-
-# --- PATH
-add_sbin2path () { # check if /sbin /usr/sbin in $PATH, otherwise add them
-                   # retval: $PATH, $oldpath, $addpath
-    local sp
-
-    oldpath="$PATH"
-    addpath=""
-
-    for sp in /usr/sbin /sbin; do
-        if [ -d $sp ] && [ ! -h $sp ]; then
-            # dir exists and is not a symlink
-            case ":$PATH:" in
-                *":$sp:"*) # $sp already in $PATH
-                    ;;
-
-                *) # $sp not in $PATH, add it
-                    addpath="$addpath:$sp"
-                    ;;
-            esac
-        fi
-    done
-
-    if [ -n "$addpath" ]; then
-      export PATH="${PATH}${addpath}"
-    fi
-
-    return 0
-}
-
-# --- Configuration
-
-read_defaults () { # read config file
-    if [ -f $CONFFILE ]; then
-        . $CONFFILE
-        return 0
-    else
-        return 1
-    fi
-}
-
-# --- Kernel Modules
-
-load_modules () { # load needed kernel modules
-    local mod
-
-    # verify module loading is allowed (else explicitly disabled)
-    # and possible (else implicitly disabled)
-    [ "${TLP_LOAD_MODULES:-y}" = "y" ] && [ -e /proc/modules ] || return 0
-
-    # load modules, ignore any errors
-    for mod in $MODULES; do
-        $MODPRO $mod > /dev/null 2>&1
-    done
-    return 0
-}
-
-# --- DMI
-
-read_dmi () { # read dmi data -- $*: keywords; stdout: dmi strings
-    local ds key outr
-
-    outr=""
-    for key in $*; do
-        ds="$( cat ${DMID}/$key 2> /dev/null | \
-                egrep -iv 'not available|to be filled|DMI table is broken' )"
-        if [ -n "$outr" ]; then
-            [ -n "$ds" ] && outr="$outr $ds"
-        else
-            outr="$ds"
-        fi
-    done
-
-    echo $outr
-    return 0
-}
-
-# --- ThinkPad
-
-is_thinkpad () { # check for ThinkPad hardware
-                 # rc: 0=ThinkPad, 1=other hardware
-
-    if [ -d $TPACPIDIR ]; then
-        # Kernel module thinkpad_acpi is loaded
-
-        # Check dmi product string for occurence of "ThinkPad"
-        if read_dmi product_version | grep -q "ThinkPad"; then
-            # It's a real ThinkPad
-            return 0
-        fi
-    fi
-
-    # No ThinkPad detected
-    return 1
-}
-
-# --- Power Source
-
-get_sys_power_supply () { # get current power source
-                          # rc: 0=ac, 1=battery, 2=unknown
-
-    local psrc
-    local rc=
-
-    for psrc in /sys/class/power_supply/*; do
-        # -f $psrc/type not necessary - cat 2>.. handles this
-        case "$(cat $psrc/type 2> /dev/null)" in
-            Mains)
-                # AC detected, check if online
-                if [ "$(cat $psrc/online 2> /dev/null)" = "1" ]; then
-                    rc=0
-                    break
-                fi
-                # else AC not online => keep $rc as-is
-                ;;
-
-            Battery)
-                # set rc to battery, but don't stop looking for AC
-                rc=1
-                ;;
-
-            *)
-                echo_debug "pm" "unknown power supply: ${psrc##*/}"
-                ;;
-        esac
-    done
-
-    # set rc to unknown if we haven't seen any AC/battery power source so far
-    : ${rc:=2}
-
-    return $rc
-}
-
-get_power_state () { # get current power source -- rc: 0=ac, 1=battery
-    # similar to get_sys_power_supply(),
-    # but maps unknown power source to TLP_DEFAULT_MODE
-    local psrc
-
-    get_sys_power_supply
-    psrc=$?
-
-    if [ $psrc -eq 2 ]; then
-        # unknown power supply, apply default mode
-        case "$TLP_DEFAULT_MODE" in
-            ac|AC)   psrc=0 ;;
-            bat|BAT) psrc=1 ;;
-            *)       psrc=0 ;; # use AC if no default mode configured
-        esac
-    fi
-
-    return $psrc
-}
-
-echo_started_mode () { # print operation mode -- $1: 0=ac mode, 1=battery mode
-    if [ "$1" = "0" ]; then
-        echo "TLP started in AC mode."
-    else
-        echo "TLP started in battery mode."
-    fi
-
-    return 0
-}
-
-# --- Locking and Semaphores
-
-set_run_flag () { # set flag -- $1: flag name
-                  # rc: 0=success/1,2=failed
-    local rc
-
-    if mkdir -p $RUNDIR 2> /dev/null 1>&2 ; then
-        touch $RUNDIR/$1; rc=$?
-        echo_debug "lock" "set_run_flag.touch: $1; rc=$rc"
-
-        return $rc
-    else
-        # mkdir failed
-        echo_debug "lock" "set_run_flag.mkdir_failed"
-        return 2
-    fi
-}
-
-reset_run_flag () { # reset flag -- $1: flag name
-    if rm $RUNDIR/$1 2> /dev/null 1>&2 ; then
-        echo_debug "lock" "reset_run_flag($1).remove"
-    else
-        echo_debug "lock" "reset_run_flag($1).not_found"
-    fi
-
-    return 0
-}
-
-check_run_flag () { # check flag -- $1: flag name
-                    # rc: 0=flag set/1=flag not set
-    local rc
-
-    [ -f $RUNDIR/$1 ]; rc=$?
-    echo_debug "lock" "check_run_flag($1): rc=$rc"
-
-    return $rc
-}
-
-check_and_set_semaphore () { # check and set semaphore -- $1: semaphore name
-                             # rc: 0=success/1=failed
-    local rc
-
-    { mkdir -p $RUNDIR && mkdir $RUNDIR/$1 ; } 2> /dev/null 1>&2
-    rc=$?
-    echo_debug "lock" "check_and_set_semaphore($1): rc=$rc"
-
-    return $rc
-}
-
-unset_semaphore () { # unset semaphore -- $1: semaphore name
-    local rc
-
-    rmdir $RUNDIR/$1 2> /dev/null 1>&2
-    rc=$?
-    echo_debug "lock" "unset_semaphore($1): rc=$rc"
-
-    return $rc
-}
-
-set_timed_lock () { # create timestamp n seconds in the future
-    # $1: lock id, $2: lock duration [s]
-
-    local rc
-    local lock=${1}_timed_lock_$(date +%s -d "+${2} seconds")
-
-    set_run_flag $lock; rc=$?
-    echo_debug "lock" "set_timed_lock($1, $2): $lock; rc=$rc"
-
-    return $rc
-}
-
-check_timed_lock () { # check if active timestamp exists
-    # $1: lock id; rc: 0=locked/1=not locked
-
-    local lockid=$1
-    local lockfile locktime
-    local time=$(date +%s)
-
-    for lockfile in $RUNDIR/${lockid}_timed_lock_*; do
-        if [ -f $lockfile ]; then
-            locktime=${lockfile#${RUNDIR}/${lockid}_timed_lock_}
-            if [ $time -lt $(( $locktime - 120 )) ]; then
-                # timestamp is more than 120 secs in the future,
-                # something weird has happened -> remove it
-                rm $lockfile
-                echo_debug "lock" "check_timed_lock($1).remove_invalid: ${lockfile#${RUNDIR}/}"
-            elif [ $time -lt $locktime ]; then
-                # timestamp in the future -> we're locked
-                echo_debug "lock" "check_timed_lock($1).locked: $time, $locktime"
-                return 0
-            else
-                # obsolete timestamp -> remove it
-                rm $lockfile
-                echo_debug "lock" "check_timed_lock($1).remove_obsolete: ${lockfile#${RUNDIR}/}"
-            fi
-        fi
-    done
-
-    echo_debug "lock" "check_timed_lock($1).not_locked: $time"
-    return 1
-}
-
-# --- Filesystem
-
-set_laptopmode () { # set kernel laptop mode -- $1: 0=ac mode, 1=battery mode
-    check_sysfs "set_laptopmode" "/proc/sys/vm/laptop_mode"
-
-    local isec
-
-    if [ "$1" = "1" ]; then
-        isec=${DISK_IDLE_SECS_ON_BAT:-}
-    else
-        isec=${DISK_IDLE_SECS_ON_AC:-}
-    fi
-    # replace with empty string if non-numeric chars are contained
-    isec=$(echo "$isec" | egrep '^[0-9]+$')
-
-    if [ -z "$isec" ]; then
-        # do nothing if unconfigured or non numeric value
-        echo_debug "pm" "set_laptopmode($1).not_configured"
-        return 0
-    fi
-
-    echo_debug "pm" "set_laptopmode($1): $isec"
-    echo $isec > /proc/sys/vm/laptop_mode
-
-    return 0
-}
-
-set_dirty_parms () { # set filesystem buffer params
-    # $1: 0=ac mode, 1=battery mode
-    # concept from laptop-mode-tools
-
-    local age cage df
-
-    check_sysfs "set_dirty_parms" "/proc/sys/vm"
-
-    if [ "$1" = "1" ]; then
-        age=${MAX_LOST_WORK_SECS_ON_BAT:-0}
-    else
-        age=${MAX_LOST_WORK_SECS_ON_AC:-0}
-    fi
-
-    # calc age in centisecs, non numeric values result in "0"
-    cage=$(($age * 100))
-
-    if [ "$cage" = "0" ]; then
-        # do nothing if unconfigured or invalid age
-        echo_debug "pm" "set_dirty_parms($1).not_configured"
-        return 0
-    fi
-
-    echo_debug "pm" "set_dirty_parms($1): $cage"
-
-    for df in /proc/sys/vm/dirty_writeback_centisecs \
-             /proc/sys/vm/dirty_expire_centisecs \
-             /proc/sys/fs/xfs/age_buffer_centisecs \
-             /proc/sys/fs/xfs/xfssyncd_centisecs; do
-        [ -w $df ] && echo $cage > $df
-    done
-
-    [ -w /proc/sys/fs/xfs/xfsbufd_centisecs ] \
-        && echo 3000 > /proc/sys/fs/xfs/xfsbufd_centisecs
-
-    return 0
-}
-
-# --- CPU
-
-check_intel_pstate () { # detect intel_pstate driver -- retval: $intel_pstate
-    #  Note: intel_pstate requires Linux 3.9 or higher
-    intel_pstate=0
-
-    [ -d $INTEL_PSTATED ] && intel_pstate=1
-    return 0
-}
-
-set_scaling_governor () { # set scaling governor -- $1: 0=ac mode, 1=battery mode
-    local gov cpu
-
-    if [ "$1" = "1" ]; then
-        gov=$CPU_SCALING_GOVERNOR_ON_BAT
-    else
-        gov=$CPU_SCALING_GOVERNOR_ON_AC
-    fi
-
-    if [ -n "$gov" ]; then
-        echo_debug "pm" "set_scaling_governor($1): $gov"
-        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
-            [ -f $cpu ] && echo $gov > $cpu 2> /dev/null
-        done
-    fi
-
-    return 0
-}
-
-set_scaling_min_max_freq () { # set scaling limits -- $1: 0=ac mode, 1=battery mode
-    local minfreq maxfreq cpu
-
-    if [ "$1" = "1" ]; then
-        minfreq=$CPU_SCALING_MIN_FREQ_ON_BAT
-        maxfreq=$CPU_SCALING_MAX_FREQ_ON_BAT
-    else
-        minfreq=$CPU_SCALING_MIN_FREQ_ON_AC
-        maxfreq=$CPU_SCALING_MAX_FREQ_ON_AC
-    fi
-
-    if [ -n "$minfreq" ]; then
-        echo_debug "pm" "set_scaling_min_max_freq($1).min: $minfreq"
-        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq; do
-            [ -f $cpu ] && echo $minfreq > $cpu 2> /dev/null
-        done
-    fi
-
-    if [ -n "$maxfreq" ]; then
-        echo_debug "pm" "set_scaling_min_max_freq($1).max: $maxfreq"
-        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq; do
-            [ -f $cpu ] && echo $maxfreq > $cpu 2> /dev/null
-        done
-    fi
-
-    return 0
-}
-
-set_cpu_perf_pct () { # set Intel P-state performance
-                      # $1: 0=ac mode, 1=battery mode
-    local min max
-
-    check_intel_pstate
-    if [ "$intel_pstate" != "1" ]; then
-        echo_debug "pm" "set_cpu_perf_pct($1).no_intel_pstate"
-        return 0
-    fi
-
-    if [ "$1" = "1" ]; then
-        min="${CPU_MIN_PERF_ON_BAT:-}"
-        max="${CPU_MAX_PERF_ON_BAT:-}"
-    else
-        min="${CPU_MIN_PERF_ON_AC:-}"
-        max="${CPU_MAX_PERF_ON_AC:-}"
-    fi
-
-    if [ ! -f $CPU_MIN_PERF_PCT ]; then
-        echo_debug "pm" "set_cpu_perf_pct($1).min.not_supported"
-    elif [ -n "$min" ]; then
-        { echo "$min" > $CPU_MIN_PERF_PCT; } 2> /dev/null
-        echo_debug "pm" "set_cpu_perf_pct($1).min: $min"
-    else
-        echo_debug "pm" "set_cpu_perf_pct($1).min.not_configured"
-    fi
-
-    if [ ! -f $CPU_MAX_PERF_PCT ]; then
-        echo_debug "pm" "set_cpu_perf_pct($1).max.not_supported"
-    elif [ -n "$max" ]; then
-        { echo "$max" > $CPU_MAX_PERF_PCT; } 2> /dev/null
-        echo_debug "pm" "set_cpu_perf_pct($1).max: $max"
-    else
-        echo_debug "pm" "set_cpu_perf_pct($1).max.not_configured"
-    fi
-
-    return 0
-}
-
-set_cpu_boost_all () { # $1: 0=ac mode, 1=battery mode
-    # global cpu boost behavior control based on the current power mode
-    #
-    # Relevant config option(s): CPU_BOOST_ON_{AC,BAT} with values {'',0,1}
-    #
-    # Note:
-    #  * needs commit #615b7300717b9ad5c23d1f391843484fe30f6c12
-    #     (linux-2.6 tree), "Add support for disabling dynamic overclocking",
-    #    => requires Linux 3.7 or later
-
-    local val ival
-
-    if [ "$1" = "1" ]; then
-        val="${CPU_BOOST_ON_BAT:-}"
-    else
-        val="${CPU_BOOST_ON_AC:-}"
-    fi
-
-    if [ -z "$val" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_cpu_boost_all($1).not_configured"
-        return 0
-    fi
-
-    check_intel_pstate
-
-    if [ $intel_pstate -eq 1 ]; then
-        # use intel_pstate sysfiles
-        if [ -f $CPU_TURBO_PSTATE ]; then
-            ival=$(($val ^ 1))
-            echo "$ival" > $CPU_TURBO_PSTATE 2> /dev/null
-            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate: $val"
-        else
-            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate.cpu_not_supported"
-        fi
-    elif [ -f $CPU_BOOST_ALL_CTRL ]; then
-        # use acpi_cpufreq sysfiles
-        # simple test for attribute "w" doesn't work, so actually write
-        if ( echo "$val" > $CPU_BOOST_ALL_CTRL ) 2> /dev/null; then
-            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq: $val"
-        else
-            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq.cpu_not_supported"
-        fi
-    else
-        echo_debug "pm" "set_cpu_boost_all($1).not_available"
-    fi
-
-    return 0
-}
-
-set_sched_powersave () { # set multi-core/-thread powersave policy
-    # $1: 0=ac mode, 1=battery mode
-
-    local pwr pool sdev
-    local avail=0
-
-    if [ "$1" = "1" ]; then
-        pwr=${SCHED_POWERSAVE_ON_BAT:-}
-    else
-        pwr=${SCHED_POWERSAVE_ON_AC:-}
-    fi
-
-    if [ -z "$pwr" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_sched_powersave($1).not_configured"
-        return 0
-    fi
-
-
-    for pool in mc smp smt; do
-        sdev="/sys/devices/system/cpu/sched_${pool}_power_savings"
-        if [ -f $sdev ]; then
-            echo_debug "pm" "set_sched_powersave($1): ${sdev##/*/} $pwr"
-            echo $pwr > "$sdev"
-            avail=1
-        fi
-    done
-
-    [ "$avail" = "1" ] || echo_debug "pm" "set_sched_powersave($1).not_available"
-
-    return 0
-}
-
-set_nmi_watchdog () { # enable/disable nmi watchdog
-    local nmiwd=${NMI_WATCHDOG:-}
-
-    if [ -z "$nmiwd" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_nmi_watchdog.not_configured"
-        return 0
-    fi
-
-    if [ -f /proc/sys/kernel/nmi_watchdog ]; then
-        echo "$nmiwd" > /proc/sys/kernel/nmi_watchdog 2> /dev/null
-        if [ $? = 0 ]; then
-            echo_debug "pm" "set_nmi_watchdog: $nmiwd"
-        else
-            echo_debug "pm" "set_nmi_watchdog.disabled_by_kernel: $nmiwd"
-        fi
-    else
-        echo_debug "pm" "set_nmi_watchdog.not_available"
-    fi
-
-    return 0
-}
-
-set_phc_controls () { # set core voltages
-    local control
-    local ctrl_avail="0"
-
-    phc_controls=${PHC_CONTROLS:-}
-
-    if [ -z "$phc_controls" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_phc_controls.not_configured"
-        return 0
-    fi
-
-    for control in /sys/devices/system/cpu/cpu*/cpufreq/phc_controls; do
-        if [ -f $control ]; then
-            echo_debug "pm" "set_phc_controls: $control $phc_controls"
-            echo $phc_controls > $control
-            ctrl_avail="1"
-        fi
-    done
-
-    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_phc_controls.not_available"
-
-    return 0
-}
-
-set_energy_perf_policy () { # set performance versus energy savings policy
-    # $1: 0=ac mode, 1=battery mode
-
-    local perf rc
-
-    if [ "$1" = "1" ]; then
-        perf=${ENERGY_PERF_POLICY_ON_BAT:-}
-    else
-        perf=${ENERGY_PERF_POLICY_ON_AC:-}
-    fi
-
-    if [ -z "$perf" ]; then
-        echo_debug "pm" "set_energy_perf_policy($1).not_configured"
-    elif ! cmd_exists $ENERGYPERF; then
-        echo_debug "pm" "set_energy_perf_policy($1).not_available"
-    else
-        $ENERGYPERF $perf > /dev/null 2>&1
-        rc=$?
-        case $rc in
-            0) echo_debug "pm" "set_energy_perf_policy($1): $perf" ;;
-            1) echo_debug "pm" "set_energy_perf_policy($1): $perf -- unsupported cpu" ;;
-            2) echo_debug "pm" "set_energy_perf_policy($1): $perf -- kernel specific x86_energy_perf_policy missing" ;;
-            *) echo_debug "pm" "set_energy_perf_policy($1): $perf -- unknown rc=$rc " ;;
-        esac
-        return $rc
-    fi
-
-    return 0
-}
-
-# --- Storage Devices
-
-check_disk_hdparm_cap () { # check if relevant disk device
-    # $1: dev; rc: 0=yes/1=no
-
-    if [ -z "$($HDPARM -I /dev/$1 2>&1 | \
-               egrep 'Invalid argument|Invalid exchange|missing sense data|No such device')" ]; then
-        return 0
-    else
-        return 1
-    fi
-}
-
-echo_disk_model () { # print disk model -- $1: dev
-    local model
-
-    model=$($HDPARM -I /dev/$1 2>&1 | grep 'Model Number' | \
-      cut -f2 -d: | sed -r 's/^ *//' )
-    echo "$model"
-
-    return 0
-}
-
-echo_disk_firmware () { # print firmware version --- $1: dev
-    local firmware
-
-    firmware=$($HDPARM -I /dev/$1 2>&1 | grep 'Firmware Revision' | \
-      cut -f2 -d: | sed -r 's/^ *//' )
-    echo "$firmware"
-
-    return 0
-}
-
-get_disk_state () { # get disk power state -- $1: dev; retval: $disk_state
-    disk_state=$($HDPARM -C /dev/$1 2>&1 | awk -F ':' '/drive state is/ { gsub(/ /,"",$2); print $2; }')
-    [ -z "$disk_state" ] && disk_state="(not available)"
-
-    return 0
-}
-
-spindown_disk () { # stop spindle motor -- $1: dev
-    $HDPARM -y /dev/$1 > /dev/null 2>&1
-
-    return 0
-}
-
-get_disk_apm_level () { # get disk apm level -- $1: dev; rc: apm
-    local apm
-
-    apm=$($HDPARM -I /dev/$1 2>&1 | grep 'Advanced power management level' | \
-          cut -f2 -d: | egrep "^ *[0-9]+ *$")
-    if [ -n "$apm" ]; then
-        return $apm
-    else
-        return 0
-    fi
-
-}
-
-get_disk_trim_capability () { # check for trim capability
-    # $1: dev; rc: 0=no, 1=yes, 254=no ssd device
-
-    local trim
-
-    if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'Solid State Device')" ]; then
-        if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'TRIM supported')" ]; then
-            trim=1
-        else
-            trim=0
-        fi
-    else
-        trim=255
-    fi
-
-    return $trim
-}
-
-get_disk_dev () { # translate disk id to device (sdX)
-    # $1: id or dev; retval: $disk_dev, $disk_id
-
-    if [ -h /dev/disk/by-id/$1 ]; then
-        # $1 is disk id
-        disk_id=$1
-        disk_dev=$(echo $disk_id | sed -r 's/-part[1-9][0-9]*$//')
-        disk_dev=$(readlink /dev/disk/by-id/$disk_dev)
-        disk_dev=${disk_dev##*/}
-    else
-        # $1 is disk dev
-        disk_dev=$1
-        disk_id=""
-    fi
-    # strip partition number
-    disk_dev=$(echo $disk_dev | sed -r 's/[1-9][0-9]*$//')
-}
-
-set_disk_apm_level () { # set disk apm level
-    # $1: 0=ac mode, 1=battery mode
-
-    local pwrmode="$1"
-    local dev log_message
-
-    # when undefined use default
-    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
-
-    # set @argv := apmlist (blanks removed - relying on a sane $IFS)
-    if [ "$pwrmode" = "1" ]; then
-        set -- $DISK_APM_LEVEL_ON_BAT
-    else
-        set -- $DISK_APM_LEVEL_ON_AC
-    fi
-
-    # exit if empty apmlist
-    [ $# -gt 0 ] || return 0
-
-    # pairwise iteration DISK_DEVICES[1,n], apmlist[1,m]; m > 0
-    #  for j in [1,n]: disk_dev[j], apmlist[min(j,m)]
-    #
-    for dev in $DISK_DEVICES; do
-        : ${1:?BUG: broken DISK_APM_LEVEL list handling}
-
-        get_disk_dev $dev
-        log_message="set_disk_apm_level($pwrmode): $disk_dev [$disk_id] $1"
-
-        if [ ! -b /dev/$disk_dev ]; then
-            echo_debug "disk" "${log_message} -- missing"
-        elif ! check_disk_hdparm_cap $disk_dev; then
-            echo_debug "disk" "${log_message} -- not supported"
-        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
-            echo_debug "disk" "${log_message} -- keep as is"
-        else
-            echo_debug "disk" "${log_message}"
-            $HDPARM -B $1 /dev/$disk_dev > /dev/null 2>&1
-        fi
-
-        # last entry in apmlist applies to all remaining disks
-        [ $# -lt 2 ] || shift
-    done
-
-    return 0
-}
-
-set_disk_spindown_timeout () { # set disk spindown timeout
-    # $1: 0=ac mode, 1=battery mode
-
-    local pwrmode="$1"
-    local dev log_message
-
-    # when undefined use default
-    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
-
-    # set @argv := timeoutlist
-    if [ "$pwrmode" = "1" ]; then
-        set -- $DISK_SPINDOWN_TIMEOUT_ON_BAT
-    else
-        set -- $DISK_SPINDOWN_TIMEOUT_ON_AC
-    fi
-
-    # exit if empty timeoutlist
-    [ $# -gt 0 ] || return 0
-
-    # pairwise iteration DISK_DEVICES[1,n], timeoutlist[1,m]; m > 0
-    #  for j in [1,n]: disk_dev[j], timeoutlist[min(j,m)]
-    #
-    for dev in $DISK_DEVICES; do
-        : ${1:?BUG: broken DISK_SPINDOWN_TIMEOUT list handling}
-
-        get_disk_dev $dev
-        log_message="set_disk_spindown_timeout($pwrmode): $disk_dev [$disk_id] $1"
-
-        if [ ! -b /dev/$disk_dev ]; then
-            echo_debug "disk" "${log_message} -- missing"
-        elif ! check_disk_hdparm_cap $disk_dev; then
-            echo_debug "disk" "${log_message} -- not supported"
-        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
-            echo_debug "disk" "${log_message} -- keep as is"
-        else
-            echo_debug "disk" "${log_message}"
-            $HDPARM -S $1 /dev/$disk_dev > /dev/null 2>&1
-        fi
-
-        # last entry in timeoutlist applies to all remaining disks
-        [ $# -lt 2 ] || shift
-    done
-
-    return 0
-}
-
-set_disk_io_sched () { # set disk io scheduler
-    local dev sched schedctrl log_message
-
-    # when undefined use default
-    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
-
-    # set @argv := schedlist
-    set -- $DISK_IOSCHED
-
-    # exit if empty timeoutlist
-    [ $# -gt 0 ] || return 0
-
-    # pairwise iteration DISK_DEVICES[1,n], schedlist[1,m]; m > 0
-    #  for j in [1,min(n,m)]   : disk_dev[j], schedlistj]
-    #  for j in [min(n,m)+1,n] : disk_dev[j], %DEFAULT_DISK_IO_SCHEDULER
-    #
-    for dev in $DISK_DEVICES; do
-        get_disk_dev $dev
-
-        # get sched from argv, use default scheduler when list is too short
-        sched=${1:-${DEFAULT_DISK_IO_SCHEDULER}}
-        schedctrl="/sys/block/$disk_dev/queue/scheduler"
-        log_message="set_disk_io_sched: $disk_dev [$disk_id] $sched"
-
-        if [ ! -b /dev/$disk_dev ]; then
-            echo_debug "disk" "${log_message} -- missing"
-        elif [ ! -f $schedctrl ]; then
-            echo_debug "disk" "${log_message} -- not supported"
-        elif wordinlist "$sched" "$DISK_NOP_WORDS"; then
-            echo_debug "disk" "${log_message} -- keep as is"
-        else
-            echo_debug "disk" "${log_message}"
-            echo -n $sched > $schedctrl
-        fi
-
-        # using %DEFAULT_DISK_IO_SCHEDULER when argv is empty
-        [ $# -eq 0 ] || shift
-    done
-
-    return 0
-}
-
-# --- Device Power Management
-
-set_sata_link_power () { # set sata link power management
-    # $1: 0=ac mode, 1=battery mode
-
-    local i
-    local pwr=""
-    local ctrl_avail="0"
-
-    if [ "$1" = "1" ]; then
-        pwr=${SATA_LINKPWR_ON_BAT:-}
-    else
-        pwr=${SATA_LINKPWR_ON_AC:-}
-    fi
-
-    if [ -z "$pwr" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_sata_link_power($1).not_configured"
-        return 0
-    fi
-
-    echo_debug "pm" "set_sata_link_power($1): $pwr"
-
-    for i in /sys/class/scsi_host/host*/link_power_management_policy ; do
-        if [ -f $i ]; then
-            echo "$pwr" > $i
-            ctrl_avail="1"
-        fi
-    done
-
-    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_sata_link_power($1).not_available"
-    return 0
-}
-
-set_pcie_aspm () { # set pcie active state power management
-    # $1: 0=ac mode, 1=battery mode
-
-    local pwr
-
-    if [ "$1" = "1" ]; then
-        pwr=${PCIE_ASPM_ON_BAT:-}
-    else
-        pwr=${PCIE_ASPM_ON_AC:-}
-    fi
-
-    if [ -z "$pwr" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_pcie_aspm($1).not_configured"
-        return 0
-    fi
-
-    if [ -f /sys/module/pcie_aspm/parameters/policy ]; then
-        echo "$pwr" > /sys/module/pcie_aspm/parameters/policy 2> /dev/null
-        if [ $? = 0 ]; then
-            echo_debug "pm" "set_pcie_aspm($1): $pwr"
-        else
-            echo_debug "pm" "set_pcie_aspm($1).disabled_by_kernel"
-        fi
-    else
-        echo_debug "pm" "set_pcie_aspm($1).not_available"
-    fi
-
-    return 0
-}
-
-set_radeon_profile () { # set radeon power profile
-    # $1: 0=ac mode, 1=battery mode
-
-    local card level pwr rc1 rc2
-    local sdone=0 # 1=radeon present
-
-    if [ ! -d $RADD ]; then
-        # No card present --> exit
-        echo_debug "pm" "set_radeon_profile($1).no_card"
-        return 0
-    fi
-
-    for card in /sys/class/drm/card[0-9]/device ; do
-        if [ -f $card/power_dpm_state ] && [ -f $card/power_dpm_force_performance_level ]; then
-            # Use new radeon dynamic power management method (dpm)
-            if [ "$1" = "1" ]; then
-                pwr=${RADEON_DPM_STATE_ON_BAT:-}
-                level=${RADEON_DPM_PERF_LEVEL_ON_BAT:-auto}
-            else
-                pwr=${RADEON_DPM_STATE_ON_AC:-}
-                level=${RADEON_DPM_PERF_LEVEL_ON_AC:-auto}
-            fi
-
-            if [ -z "$pwr" ]; then
-                # do nothing if unconfigured
-                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
-                return 0
-            fi
-
-            if [ -n "$pwr" ]; then
-                echo "$pwr" > $card/power_dpm_state 2> /dev/null; rc1=$?
-                echo "$level" > $card/power_dpm_force_performance_level 2> /dev/null; rc2=$?
-                echo_debug "pm" "set_radeon_profile($1): $card state=$pwr [rc=$rc1] perf=$level [rc=$rc2]"
-            fi
-
-            sdone=1
-
-        elif [ -f $card/power_method ] && [ -f $card/power_profile ]; then
-            # Use old radeon power profile method
-            if [ "$1" = "1" ]; then
-                pwr=${RADEON_POWER_PROFILE_ON_BAT:-}
-            else
-                pwr=${RADEON_POWER_PROFILE_ON_AC:-}
-            fi
-
-            if [ -z "$pwr" ]; then
-                # do nothing if unconfigured
-                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
-                return 0
-            fi
-
-            if [ -n "$pwr" ]; then
-                echo_debug "pm" "set_radeon_profile($1): $card profile=$pwr"
-                echo "profile" > $card/power_method 2> /dev/null
-                echo "$pwr" > $card/power_profile 2> /dev/null
-            fi
-
-            sdone=1
-        fi
-    done
-
-    if [ $sdone -eq 0 ]; then
-        echo_debug "pm" "set_radeon_profile($1).not_available"
-    fi
-
-    return 0
-}
-
-set_sound_power_mode () { # set sound chip power modes
-    # $1: 0=ac mode, 1=battery mode
-
-    local pwr cpwr
-
-    # new config param
-    if [ "$1" = "1" ]; then
-        pwr=${SOUND_POWER_SAVE_ON_BAT:-}
-    else
-        pwr=${SOUND_POWER_SAVE_ON_AC:-}
-    fi
-
-    # when unconfigured consider legacy config param
-    [ -z "$pwr" ] && pwr=${SOUND_POWER_SAVE:-}
-
-    if [ -z "$pwr" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_sound_power_mode($1).not_configured"
-        return 0
-    fi
-
-    cpwr=${SOUND_POWER_SAVE_CONTROLLER:-Y}
-
-    check_sysfs "set_sound_power_mode" "/sys/module"
-
-    if [ -d /sys/module/snd_hda_intel ]; then
-        echo_debug "pm" "set_sound_power_mode($1).hda: $pwr controller=$cpwr"
-        echo "$pwr" > /sys/module/snd_hda_intel/parameters/power_save
-
-        if [ "$pwr" = "0" ]; then
-            echo "N" >  /sys/module/snd_hda_intel/parameters/power_save_controller
-        else
-            echo "$cpwr" > /sys/module/snd_hda_intel/parameters/power_save_controller
-        fi
-    fi
-
-    if [ -d /sys/module/snd_ac97_codec ]; then
-        echo_debug "pm" "set_sound_power_mode($1).ac97: $pwr"
-        echo "$pwr"  > /sys/module/snd_ac97_codec/parameters/power_save
-    fi
-
-    return 0
-}
-
-get_pci_class_descr () { # get long descr of pci device class
-    # $1: class; retval: lclass
-
-    case $1 in
-        0x020000) lclass="Ethernet controller" ;;
-        0x028000) lclass="Wireless" ;;
-        0x040300) lclass="Audio device" ;;
-        0x060000) lclass="Host Bridge" ;;
-        0x080500) lclass="SD Card Reader" ;;
-        0x088000|0x088001) lclass="Card Reader" ;;
-        0x0c0000|0x0c0010) lclass="Firewire" ;;
-        *) lclass="" ;;
-    esac
-
-    return 0
-}
-
-set_runtime_pm () { # set runtime power management
-    # $1: 0=ac mode, 1=battery mode
-
-    local address class ccontrol control device doall driver drv_bl pci_bl type
-
-    if [ "$1" = "1" ]; then
-        ccontrol=${RUNTIME_PM_ON_BAT:-}
-    else
-        ccontrol=${RUNTIME_PM_ON_AC:-}
-    fi
-
-    if [ -z "$ccontrol" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_runtime_pm($1).not_configured"
-        return 0
-    fi
-
-    # enable for all devices
-    doall=${RUNTIME_PM_ALL:-1}
-
-    # driver specific blacklist
-    drv_bl=${RUNTIME_PM_DRIVER_BLACKLIST:-$DEFAULT_PM_DRIVER_BLACKLIST}
-
-    # pci id blacklist
-    pci_bl=${RUNTIME_PM_BLACKLIST:-}
-
-    # add devices assigned to blacklisted drivers to the pci id blacklist
-    for driver in $drv_bl; do # iterate list
-        if [ -n "$driver" ] && [ -d $PCIDRV/$driver ]; then
-            # driver is active --> iterate over assigned devices
-            for device in $PCIDRV/$driver/0000:*; do
-                # get short device address
-                address=${device##/*/0000:}
-
-                # add to list when not already contained
-                if ! wordinlist "$address" "$pci_bl"; then
-                    pci_bl="$pci_bl $address"
-                fi
-            done
-        fi
-    done
-
-    # iterate pci(e) devices
-    for type in $PCID; do
-        for device in $type/*; do
-            class="none"
-            lclass=""
-
-            # get short device address
-            address=${device##/*/0000:}
-
-            if wordinlist "$address" "$pci_bl"; then
-                # device is in blacklist
-                control="black"
-
-            elif [ -f $device/class ] && [ -f $device/power/control ]; then
-                class=$(cat $device/class)
-                get_pci_class_descr $class
-                control=$ccontrol                
-
-                if [ -z "$lclass" ] && [ $doall -ne 1 ]; then
-                    # device has no long descr and all flag is not set
-                    control="class"
-                fi
-
-                case $control in
-                    auto|on) echo $control > $device/power/control ;;
-
-                    class|none) ;; # do nothing
-                esac
-            fi
-
-            [ -n "$lclass" ] && lclass=" $lclass"
-            echo_debug "pm" "set_runtime_pm($1).$control: $device [$class$lclass]"
-        done
-    done
-
-    return 0
-}
-
-# --- Wifi Power Management
-
-get_wifi_ifaces () { # get all wifi devices -- retval: $wifaces
-    local wi wiu
-    wifaces=""
-
-    for wiu in $NETD/*/uevent; do
-        if grep -q -s "DEVTYPE=wlan" $wiu ; then
-            wi=${wiu%/uevent}; wi=${wi##*/}
-            wifaces="$wifaces $wi"
-        fi
-    done
-
-    wifaces="${wifaces# }"
-    return 0
-}
-
-get_wifi_driver () { # get driver associated with interface
-                     # $1: iface; retval: $wifidrv
-    local drvl
-
-    wifidrv=""
-    if [ -d $NETD/$1 ]; then
-        drvl=$(readlink $NETD/$1/device/driver)
-        [ -n "$drvl" ] && wifidrv=${drvl##*/}
-    fi
-
-    return 0
-}
-
-set_wifi_power_mode () { # set wifi power save mode -- $1: 0=ac mode, 1=battery mode
-    local pwr iface
-    local rc=0
-    local cmdx=0
-
-    if [ "$1" = "1" ]; then
-        pwr=${WIFI_PWR_ON_BAT:-}
-    else
-        pwr=${WIFI_PWR_ON_AC:-}
-    fi
-
-    if [ -z "$pwr" ]; then
-        # do nothing if unconfigured
-        echo_debug "pm" "set_wifi_power_mode($1).not_configured"
-        return 0
-    fi
-
-    case $pwr in
-        0|1|N)          pwr="off" ;;
-        2|3|4|5|6|Y)    pwr="on"  ;;
-    esac
-
-    get_wifi_ifaces
-
-    for iface in $wifaces; do
-        if [ -n "$iface" ]; then
-            if  [ "$X_DONT_USE_IW" != "1" ] && cmd_exists $IW; then
-                # try with iw first
-                $IW dev $iface set power_save $pwr > /dev/null 2>&1
-                rc=$?
-                echo_debug "pm" "set_wifi_power_mode($1, $iface).iw: $pwr; rc=$rc"
-                cmdx=1
-            fi
-            if cmd_exists $IWC; then
-                if [ $rc -ne 0 ] || [ $cmdx -eq 0 ]; then
-                    # iw did not succeed or iw not installed -> try with iwconfig
-                    $IWC $iface power $pwr > /dev/null 2>&1
-                    rc=$?
-                    echo_debug "pm" "set_wifi_power_mode($1, $iface).iwconfig: $pwr; rc=$rc"
-                    cmdx=1
-                fi
-            fi
-            if [ $cmdx -eq 0 ]; then
-                # neither iw nor iwconfig installed -> no way
-                echo_debug "pm" "set_wifi_power_mode($1, $iface).no_tool"
-            fi
-        fi
-    done
-
-    return 0
-}
-
-wireless_in_use () { # check if wifi or wwan device is in use -- $1: iface
-    if [ -f $NETD/$1/carrier ]; then
-        if [ "$(cat $NETD/$1/carrier 2>/dev/null)" = "1" ]; then
-            return 0
-        fi
-    fi
-    return 1
-}
-
-any_wifi_in_use () { # check if any wifi device is in use
-    local iface
-
-    get_wifi_ifaces
-    for iface in $wifaces; do
-        wireless_in_use $iface && return 0
-    done
-
-    return 1
-}
-
-# --- WWAN Power Management
-
-get_wwan_ifaces () { # get all wwan devices -- retval: $wanifaces
-    local wi wiu
-    wanifaces=""
-
-    for wiu in $NETD/*/uevent; do
-        if grep -q -s "DEVTYPE=wwan" $wiu ; then
-            wi=${wiu%/uevent}; wi=${wi##*/}
-            wanifaces="$wanifaces $wi"
-        fi
-    done
-
-    wanifaces="${wanifaces# }"
-    return 0
-}
-
-any_wwan_in_use () { # check if any wwan device is in use
-    local iface
-
-    get_wwan_ifaces
-    for iface in $wanifaces; do
-        wireless_in_use $iface && return 0
-    done
-
-    return 1
-}
-
-get_wwan_driver () { # get driver associated with interface
-                     # $1: iface; retval: $wwandrv
-    local drvl
-
-    wwandrv=""
-    if [ -d $NETD/$1 ]; then
-        drvl=$(readlink $NETD/$1/device/driver)
-        [ -n "$drvl" ] && wwandrv=${drvl##*/}
-    fi
-
-    return 0
-}
-
-# --- Bluetooth Power Management
-
-get_bluetooth_ifaces () { # get all bluetooth devices -- retval: $bifaces
-    # enumerate symlinks only
-    bifaces="$(for i in $BLUETOOTHD/*; do [ -h $i ] && echo ${i##/*/}; done | grep -v ':')"
-    return 0
-}
-
-get_bluetooth_driver () { # get driver associated with interface -- $1: iface; retval: $bluetoothdrv
-    local drvl
-
-    bluetoothdrv=""
-    if [ -d $BLUETOOTHD/$1 ]; then
-        drvl=$(readlink $BLUETOOTHD/$1/device/driver)
-        [ -n "$drvl" ] && bluetoothdrv=${drvl##*/}
-    fi
-
-    return 0
-}
-
-dbus_call () { # call method via system dbus -- $1: dest; $2: $path; $3: interface, $4: $method
-    $DBUSSEND --system --type=method_call --print-reply --dest="$1" "$2" "$3.$4" 2> /dev/null
-}
-
-bluez_call () { # call bluez method via dbus -- $1: path; $2: interface; $3: $method
-    dbus_call "org.bluez" "$1" "org.bluez.$2" "$3"
-}
-
-bluez_bluetooth_in_use () { # check if bluetooth device (specified as dbus path) is in use $1: dbus path
-    local devices device connected
-
-    devices=$(bluez_call $1 Adapter ListDevices | sed -n 's/\s*object path "\(.*\)"\s*/\1/p')
-    for device in $devices; do
-        connected="$(bluez_call $device Device GetProperties | grep -A 1 Connected | sed -n 's/.*boolean //p')"
-        test "$connected" = "true" && return 0
-    done
-
-    return 1
-}
-
-bluetooth_in_use () { # check if bluetooth device is in use -- $1: iface
-    local paths path
-
-    paths="$(bluez_call / Manager ListAdapters | sed -n 's/\s*object path "\(.*\)"\s*/\1/p' | grep /$1\$)"
-    for path in $paths; do
-        bluez_bluetooth_in_use "$path" && return 0
-    done
-
-    return 1
-}
-
-any_bluetooth_in_use () { # check if some bluetooth device is in use
-    local paths path
-
-    paths="$(bluez_call / Manager ListAdapters | sed -n 's/\s*object path "\(.*\)"\s*/\1/p')"
-    for path in $paths; do
-        bluez_bluetooth_in_use "$path" && return 0
-    done
-
-    return 1
-}
-
-# --- LAN
-
-get_eth_ifaces () { # get all eth devices -- retval: $ethifaces
-    local ei eic
-    ethifaces=""
-
-    for eic in $NETD/*/device/class; do
-        if [ -f $eic ] \
-            && [ "$(cat $eic)" = "0x020000" ] \
-            && [ ! -d "${eic%/class}/ieee80211" ]; then
-
-            ei=${eic%/device/class}; ei=${ei##*/}
-            ethifaces="$ethifaces $ei"
-        fi
-    done
-
-    ethifaces="${ethifaces# }"
-    return 0
-}
-
-disable_wake_on_lan () {  # disable WOL
-    local ei
-
-    WOL_DISABLE=${WOL_DISABLE:-N}
-
-    if [ "$WOL_DISABLE" = "Y" ]; then
-        get_eth_ifaces
-
-        for ei in $ethifaces; do
-            echo_debug "pm" "disable_wake_on_lan: $ei"
-            $ETHTOOL -s $ei wol d > /dev/null 2>&1
-        done
-    fi
-
-    return 0
-}
-
-# --- USB Autosuspend
-
-set_usb_suspend () { # activate usb autosuspend for all devices except input and blacklisted
-    # $1: 0=silent/1=report result; $2: on/auto
-
-    local busdev control devices exc usbdev usbid subdev
-    local ctrlf="control"
-    local autof="autosuspend_delay_ms"
-
-    check_sysfs "set_usb_suspend" "$USBD"
-
-    if [ "$USB_AUTOSUSPEND" = "1" ]; then
-        # autosuspend is configured
-
-        # iterate devices
-        devices=$(ls $USBD 2> /dev/null | grep -v ':')
-
-        for usbdev in $devices; do
-            if [ -f $USBD/$usbdev/power/autosuspend ] || [ -f $USBD/$usbdev/power/autosuspend_delay_ms ]; then
-                usbid="$(cat $USBD/$usbdev/idVendor):$(cat $USBD/$usbdev/idProduct)"
-                busdev="Bus $(cat $USBD/$usbdev/busnum) Dev $(cat $USBD/$usbdev/devnum)"
-
-                control="${2:-auto}"
-                exc=""
-                chg=0
-
-                if [ "$control" != "on" ]; then
-                    if wordinlist "$usbid" "$USB_WHITELIST"; then
-                        # device is in whitelist -- whitelist always wins
-                        control="auto"
-                        exc="_dev_white"
-                    elif wordinlist "$usbid" "$USB_BLACKLIST"; then
-                        # device is in blacklist
-                        control="on"
-                        exc="_dev_black"
-                    else
-                        # check for hid subdevices
-                        for subdev in $USBD/$usbdev/*:*; do
-                            if [ -d $subdev ] && [ "$(cat $subdev/bInterfaceClass)" = "03" ]; then
-                                control="on"
-                                exc="_hid_black"
-                                break
-                            fi
-                        done
-
-                        if [ -z "$exc" ]; then
-                            # check for wwan vendor ids
-                            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
-
-                            if [ $USB_BLACKLIST_WWAN = "1" ]; then
-                                vendor="$(cat $USBD/$usbdev/idVendor)"
-                                if wordinlist "$vendor" "$USB_WWAN_VENDORS"; then
-                                    control="on"
-                                    exc="_wwan_black"
-                                fi
-                            fi
-                        fi
-                    fi
-                fi
-
-                if [ -f $USBD/$usbdev/power/control ]; then
-                    if [ "$(cat $USBD/$usbdev/power/control)" != "$control" ]; then
-                        # Write actual changes only
-                        echo "$control" > $USBD/$usbdev/power/control
-                        chg=1
-                    fi
-                else
-                    # level is deprecated
-                    if [ "$(cat $USBD/$usbdev/power/level)" != "$control" ]; then
-                        # Write actual changes only
-                        echo "$control" > $USBD/$usbdev/power/level
-                        chg=1
-                    fi
-                    ctrlf="level"
-                fi
-
-                if [ "$X_TLP_USB_SET_AUTOSUSPEND_DELAY" = "1" ]; then
-                    # set autosuspend_delay
-                    if [ -f $USBD/$usbdev/power/autosuspend_delay_ms ]; then
-                        echo $USB_TIMEOUT_MS > $USBD/$usbdev/power/autosuspend_delay_ms
-                    else
-                        # autosuspend is deprecated
-                        echo $USB_TIMEOUT > $USBD/$usbdev/power/autosuspend
-                        autof="autosuspend"
-                    fi
-                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev [$ctrlf $autof]"
-                elif [ $chg -eq 1 ]; then
-                    # default: change control but not autosuspend_delay, i.e. keep kernel default setting
-                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev [$ctrlf]"
-                else
-                    # we didn't change anything actually
-                    echo_debug "usb" "udev_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev"
-                fi
-
-            fi
-        done
-        [ "$1" = "1" ] && echo "USB autosuspend settings applied."
-    else
-        [ "$1" = "1" ] && echo "Error: USB autosuspend is disabled. Set USB_AUTOSUSPEND=1 in $DEFAULT_FILE." 1>&2
-    fi
-
-    # set "startup completion" flag for tlp-usb-udev
-    set_run_flag $USB_DONE
-
-    return 0
-}
-
-# --- ThinkPad Battery Functions
-
-check_tpsmapi () {  # check if tp_smapi is supported and loaded
-    # rc: 0=supported/2=module tp_smapi not loaded/127=not installed
-    # retval: $tpsmapi
-
-    if [ -d $SMAPIDIR ]; then
-        # module loaded
-        tpsmapi=0
-    else
-        if [ -n "$(modinfo tp_smapi 2> /dev/null)" ]; then
-            # module installed but not loaded
-            tpsmapi=2
-        else
-            # module not installed
-            tpsmapi=127
-        fi
-    fi
-
-    echo_debug "bat" "check_tp_smapi: rc=$tpsmapi"
-    return $tpsmapi
-}
-
-check_tpacpi () { # check if tpacpi-bat is supported
-    # rc: 0=supported/2=acpi_call not loaded/4=disabled/
-    #     127=acpi_call not installed/255=not supported
-    # retval: $tpacpi
-
-    if [ -z "$(modinfo acpi_call 2> /dev/null)" ]; then
-        # module not installed
-        tpacpi=127
-    else
-        $TPACPIBAT -g FD 1 > /dev/null 2>&1
-        tpacpi=$?
-
-        if [ $tpacpi -eq 0 ] && [ "$DISABLE_TPACPIBAT" = "1" ]; then
-            tpacpi=4
-        fi
-    fi
-
-    echo_debug "bat" "check_tpacpi: rc=$tpacpi"
-    return $tpacpi
-}
-
-check_tp_battery () { # check ThinkPad battery presence and return index
-    # $1: BAT0/BAT1/DEF
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0=bat exists/1=bat nonexistent/255=no thresh api available
-    # retval: $bat_str: BAT0/BAT1; $bat_idx: 1/2
-
-    # defaults
-    local rc=255 # no threshold API available
-    bat_idx=0    # no tpacpi-bat index
-    bat_str=""   # no default bat found
-    local blist bs
-
-    # check prerequisites: tpacpi-bat or tp-smapi
-    check_tpacpi
-    check_tpsmapi
-
-    # validate param
-    case $1 in
-        BAT0|BAT1) blist="$1" ;;
-        DEF) blist="BAT0 BAT1" ;;
-
-        *)         return 1 ;;
-    esac
-
-    if [ $tpsmapi -eq 0 ]; then # tp-smapi available
-        for bs in $blist; do
-            # check tp-smapi name space
-            [ -d $SMAPIDIR/$bs ] && [ "$(cat $SMAPIDIR/$bs/installed)" = "1" ]
-            rc=$?
-            if [ $rc -eq 0 ]; then
-                case $bs in
-                    BAT0) bat_idx=1; bat_str="$bs" ;;
-                    BAT1) bat_idx=2; bat_str="$bs" ;;
-                esac
-            fi
-            [ $rc -ne 0 ] || break # exit loop on first battery detected
-        done
-    elif [ $tpacpi -eq 0 ]; then # tpacpi-bat available
-        for bs in $blist; do
-            # check acpi name space
-            [ -d $ACPIBATDIR/$bs ] && [ "$(cat $ACPIBATDIR/$bs/present)" = "1" ]
-            rc=$?
-            if [ $rc -eq 0 ]; then
-                # determine tpacpi-bat index
-                case $bs in
-                    BAT0)
-                        bat_idx=1 # BAT0 is always assumed main battery
-                        bat_str="$bs"
-                        ;;
-
-                    BAT1)
-                        # check with tpacpi-bat(2) if BAT1 is main or aux battery
-                        if $TPACPIBAT -g ST 2 2> /dev/null 1>&2 ; then
-                            bat_idx=2 # BAT1 is aux
-                        else
-                            bat_idx=1 # BAT1 is main
-                        fi
-                        bat_str="$bs"
-                        ;;
-                esac
-            fi
-            [ $rc -ne 0 ] || break # exit loop on first battery detected
-        done
-    fi
-
-    echo_debug "bat" "check_tp_battery($1): idx=$bat_idx; str=$bat_str; tpacpi=$tpacpi; tpsmapi=$tpsmapi; rc=$rc"
-    return $rc
-}
-
-read_tpacpi_threshold () { # $1: ST/SP (start/stop); $2: 0/1 (battery)
-                           # rc: threshold (1..99, 0=default, 255=error)
-    local thresh rc
-
-    thresh=$($TPACPIBAT -g $1 $2 2> /dev/null | cut -f1 -d' ')
-    rc=$?
-
-    if [ $rc -eq 0 ] && [ -n "$thresh" ]; then
-        [ $thresh -ge 128 ] && thresh=$(($thresh - 128)) # Remove offset of 128 for Edge S430
-        return $thresh
-    else
-        return 255
-    fi
-}
-
-do_threshold () { # $1: start/stop, $2: BAT0/BAT1, $3: new value
-    # global param: $bat_idx, $tpsmapi, $tpacpi
-    # rc: 0=ok/1=read error/2=thresh not present/255=no thresh api
-
-    local bsys ts
-    local old_thresh=-1
-    local new_thresh=$3
-    local rc=0
-
-    [ $3 -eq -1 ] && return 0 # -1 = do not set threshold
-
-    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
-        if [ $bat_idx -ne 0 ]; then
-            # replace factory default values with 0 for tpacpi
-            case $1 in
-                start)
-                    [ $new_thresh -eq  96 ] && new_thresh=0
-                    ts="ST"
-                    ;;
-                stop)
-                    [ $new_thresh -eq 100 ] && new_thresh=0
-                    ts="SP"
-                    ;;
-            esac
-
-            read_tpacpi_threshold $ts $bat_idx
-            old_thresh=$?
-
-            if [ $new_thresh -ne $old_thresh ]; then
-                $TPACPIBAT -s $ts $bat_idx $new_thresh > /dev/null 2>&1
-                rc=$?
-            fi
-        fi
-    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
-        bsys=$SMAPIDIR/$2/${1}_charge_thresh
-
-        if [ -f $bsys ]; then
-            old_thresh=$(cat $bsys 2> /dev/null)
-            if [ -z "$old_thresh" ]; then
-                rc=1
-            elif [ "$old_thresh" -ne "$new_thresh" ]; then
-                echo $new_thresh > $bsys 2> /dev/null
-                rc=$?
-            fi
-        else
-            rc=2 # invalid bat argument
-        fi
-    else
-        # no threshold API available
-        rc=255
-    fi
-
-    echo_debug "bat" "do_threshold($1, $2): bat_idx=$bat_idx; tpacpi=$tpacpi; tpsmapi=$tpsmapi; old=$old_thresh; new=$new_thresh; rc=$rc"
-    return $rc
-}
-
-normalize_thresholds () { # check values and enforce start < stop - 3
-    # $1: start threshold; $2: stop_threshold
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0
-    # retval: $start_thresh, $stop_thresh
-
-    local type thresh
-
-    for type in start stop; do
-        case $type in
-            start) thresh=$1 ;;
-            stop)  thresh=$2 ;;
-        esac
-
-        # check for 1..3 digits, replace with empty string if non-numeric chars are contained
-        thresh=$(echo "$thresh" | egrep '^[0-9]{1,3}$')
-        # replace empty string with -1
-        [ -z "$thresh" ] && thresh=-1
-
-        # ensure min/max values; replace 0 with defaults 96/100
-        case $type in
-            start)
-                [ $thresh -eq 0 ] || [ $thresh -gt 96 ] && thresh=96
-                start_thresh=$thresh
-                ;;
-
-            stop)
-                [ $thresh -eq 0 ] || [ $thresh -gt 100 ] && thresh=100
-                [ $thresh -ne -1 ] && [ $thresh -lt 5 ] && thresh=5
-                stop_thresh=$thresh
-                ;;
-        esac
-    done
-
-    # enforce start < stop - 3
-    if [ $start_thresh -ne -1 ] && [ $stop_thresh -ne -1 ]; then
-        [ $start_thresh -ge $(($stop_thresh - 3)) ] && start_thresh=$(($stop_thresh - 4))
-    fi
-
-    echo_debug "bat" "normalize_thresholds($1, $2): start=$start_thresh; stop=$stop_thresh"
-
-    return 0
-}
-
-set_charge_thresholds () { # write all charge thresholds from configuration
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0
-
-    local rc
-
-    if check_tp_battery BAT0; then
-        normalize_thresholds "$START_CHARGE_THRESH_BAT0" "$STOP_CHARGE_THRESH_BAT0"
-
-        if [ $stop_thresh -ne -1 ]; then
-            do_threshold stop BAT0 $stop_thresh; rc=$?
-            echo_debug "bat" "set_charge_thresholds.stop(BAT0): $stop_thresh; rc=$rc"
-        else
-            echo_debug "bat" "set_charge_thresholds.stop(BAT0).not_set"
-        fi
-
-        if [ $start_thresh -ne -1 ]; then
-            do_threshold start BAT0 $start_thresh; rc=$?
-            echo_debug "bat" "set_charge_thresholds.start(BAT0): $start_thresh; rc=$rc"
-        else
-            echo_debug "bat" "set_charge_thresholds.start(BAT0).not_set"
-        fi
-    fi
-
-    if check_tp_battery BAT1; then
-        normalize_thresholds "$START_CHARGE_THRESH_BAT1" "$STOP_CHARGE_THRESH_BAT1"
-
-        if [ $stop_thresh -ne -1 ]; then
-            do_threshold stop BAT1 $stop_thresh; rc=$?
-            echo_debug "bat" "set_charge_thresholds.stop(BAT1): $stop_thresh; rc=$rc"
-        else
-            echo_debug "bat" "set_charge_thresholds.stop(BAT1).not_set"
-        fi
-
-        if [ $start_thresh -ne -1 ]; then
-            do_threshold start BAT1 $start_thresh; rc=$?
-            echo_debug "bat" "set_charge_thresholds.start(BAT1): $start_thresh; rc=$rc"
-        else
-            echo_debug "bat" "set_charge_thresholds.start(BAT1).not_set"
-        fi
-    fi
-
-    return 0
-}
-
-do_force_discharge () { # write force discharge state
-    # $1: BAT0/BAT1, $2: 0=off/1=on
-    # global param: $bat_idx, $tpacpi, $tpsmapi
-    # rc: 0=done/1=write error/2=discharge not present/255=no thresh api
-
-    local bsys rc=0
-
-    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
-        $TPACPIBAT -s FD $bat_idx $2 > /dev/null 2>&1; rc=$?
-        echo_debug "bat" "do_force_discharge.tpacpi-bat($1, $2): rc=$rc"
-    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
-        bsys=$SMAPIDIR/$1/force_discharge
-
-        if [ -f $bsys ]; then
-            echo $2 > $bsys 2> /dev/null; rc=$?
-        else
-            rc=2
-        fi
-        echo_debug "bat" "do_force_discharge.tp-smapi($1, $2): rc=$rc"
-    else # no threshold API available
-        rc=255
-        echo_debug "bat" "do_force_discharge.noapi($1, $2)"
-    fi
-
-    return $rc
-}
-
-get_force_discharge () { # $1: BAT0/BAT1,
-    # global param: $bat_idx, $tpacpi, $tpsmapi
-    # rc: 0=done/1=read error/2=discharge not present/255=no thresh api
-
-    local bsys rc=0
-
-    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
-        case $($TPACPIBAT -g FD $bat_idx 2> /dev/null) in
-            yes) rc=1 ;;
-            no)  rc=0 ;;
-            *)   rc=2 ;;
-        esac
-    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
-        bsys=$SMAPIDIR/$1/force_discharge
-
-        if [ -f $bsys ]; then
-            rc=$(cat $bsys 2> /dev/null)
-        else
-            rc=2
-        fi
-    else # no threshold API available
-        rc=255
-    fi
-
-    echo_debug "bat" "get_force_discharge($1): rc=$rc"
-    return $rc
-}
-
-cancel_force_discharge () { # called from trap -- global param: $bat_str
-    do_force_discharge $bat_str 0
-    echo_debug "bat" "force_discharge.cancelled($bat_str)"
-    echo " Cancelled."
-
-    exit 0
-}
-
-check_ac_power () { # check if ac power connected -- $1: function
-
-    if ! get_sys_power_supply ; then
-        echo_debug "bat" "check_ac_power($1).no_ac_power"
-        echo "Error: $1 is possible on AC power only." 1>&2
-        return 1
-    fi
-
-    return 0
-}
-
-setcharge_battery () { # write charge thresholds (called from cmd line)
-    # $1: start charge threshold, $2: stop charge threshold, $3: battery
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0=ok/1=error
-
-    local bat rc st sp
-    local use_cfg=0
-    # $bat_str is global for cancel_force_discharge() trap
-
-    # check params
-    case $# in
-        0) # no args
-            bat=DEF   # use default(1st) battery
-            use_cfg=1 # use configured values
-            ;;
-
-        1) # assume $1 is battery
-            bat=$1
-            use_cfg=1 # use configured values
-            ;;
-
-        2) # assume $1,$2 are thresholds
-            st=$1
-            sp=$2
-            bat=DEF # use default(1st) battery
-            ;;
-
-        3) # assume $1,$2 are thresholds, $3 is battery
-            st=$1
-            sp=$2
-            bat=$3
-            ;;
-    esac
-
-    # convert bat to uppercase
-    bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
-
-    # check bat presence and/or get default(1st) battery
-    check_tp_battery $bat
-    case $? in
-        0) # battery present
-            # get configured values if requested
-            if [ $use_cfg -eq 1 ]; then
-                eval st="\$START_CHARGE_THRESH_$bat_str"
-                eval sp="\$STOP_CHARGE_THRESH_$bat_str"
-            fi
-            ;;
-
-        255) # no api
-            echo "Error: ThinkPad extended battery functions not available." 1>&2
-            echo_debug "bat" "setcharge_battery.noapi"
-            return 1
-            ;;
-
-        *) # not present
-            echo "Error: battery $bat not present." 1>&2
-            echo_debug "bat" "setcharge_battery.not_present($bat)"
-            return 1
-            ;;
-    esac
-
-    # validate thresholds
-    normalize_thresholds $st $sp
-
-    # write threshold values
-    echo "Setting temporary charge thresholds for $bat_str:"
-
-    if [ $stop_thresh -ne -1 ]; then
-        do_threshold stop $bat_str $stop_thresh; rc=$?
-
-        echo_debug "bat" "setcharge_battery.stop($bat_str): $stop_thresh; rc=$rc"
-        if [ $rc -eq 0 ]; then
-            echo "  stop  = $stop_thresh"
-        else
-            echo "  stop  => Error: cannot set threshold. Aborting." 1>&2
-            return 1
-        fi
-    else
-        echo_debug "bat" "setcharge_battery.stop($bat_str).not_configured"
-        echo "  stop = not configured"
-    fi
-
-    if [ $start_thresh -ne -1 ]; then
-        do_threshold start $bat_str $start_thresh; rc=$?
-
-        echo_debug "bat" "setcharge_battery.start($bat_str): $start_thresh; rc=$rc"
-        if [ $rc -eq 0 ]; then
-            echo "  start = $start_thresh"
-        else
-            echo "  start => Warning: cannot set threshold." 1>&2
-            return 1
-        fi
-    else
-        echo_debug "bat" "setcharge_battery.start($bat_str).not_configured"
-        echo "  start = not configured"
-    fi
-
-    return 0
-}
-
-get_sysval () { # $1: file; rc: sysfile value
-    local sysf="$1"
-    local val=""
-
-    # read sysval when it exists
-    [ -f $sysf ] && val=$(cat $sysf 2> /dev/null)
-
-    # replace with 0 if empty string or non-numeric chars are contained
-    [ -z "$(echo "$val" | egrep '^[0-9]+$')" ] && val=0
-
-    return $val
-}
-
-chargeonce_battery () { # charge battery to upper threshold once
-    # $1: battery
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0=ok/1=error
-
-    local bat bdir temp_start_thresh
-    local start_thresh=""
-    local stop_thresh=""
-    local efull=0
-    local enow=0
-    local ccharge=0
-
-    # check params
-    if [ $# -gt 0 ]; then
-        # some parameters given, check them
-
-        # get battery arg
-        bat=${1:-DEF}
-        bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
-    else
-        # no parameters given, use default(1st) battery
-        bat=DEF
-    fi
-
-    # check if selected battery is present
-    check_tp_battery $bat
-    case $? in
-        0) ;; # battery present
-
-        255) # no api
-            echo "Error: ThinkPad extended battery functions not available." 1>&2
-            echo_debug "bat" "chargeonce_battery.noapi"
-            return 1
-            ;;
-
-        *) # not present
-            echo "Error: battery $bat_str not present." 1>&2
-            echo_debug "bat" "chargeonce_battery.not_present($bat_str)"
-            return 1
-            ;;
-    esac
-
-    # get and check thresholds from configuration)
-    eval stop_thresh=\$STOP_CHARGE_THRESH_$bat_str
-    eval start_thresh=\$START_CHARGE_THRESH_$bat_str
-
-    [ -z "$stop_thresh" ] && stop_thresh=100
-    if [ -z "$start_thresh" ] ; then
-        echo_debug "bat" "chargeonce_battery($bat_str).start_threshold_not_configured"
-        echo "Error: no start charge threshold configured for $bat_str." 1>&2
-        return 1
-    fi
-
-    # get current charge level (in %)
-    if [ $tpsmapi -eq 0 ]; then
-        # use tp-smapi
-        bdir="$SMAPIDIR/$bat_str"
-        get_sysval $bdir/remaining_percent; ccharge=$?
-    else
-        # use ACPI data
-        bdir="$ACPIBATDIR/$bat_str"
-        if [ -f $bdir/energy_full ]; then
-            get_sysval $bdir/energy_full; efull=$?
-            get_sysval $dir/energy_now; enow=$?
-        fi
-
-        if [ $efull -ne 0 ]; then
-            ccharge=$(( 100 * $enow / $efull ))
-        else
-            ccharge=-1
-        fi
-    fi
-
-    if [ $ccharge -eq -1 ] ; then
-        echo_debug "bat" "chargeonce_battery($bat_str).charge_level_unknown: enow=$enow; efull=$efull; ccharge=$ccharge"
-        echo "Error: cannot determine charge level for $bat_str." 1>&2
-        return 1
-    else
-        echo_debug "bat" "chargeonce_battery($bat_str).charge_level: enow=$enow; efull=$efull; ccharge=$ccharge"
-    fi
-
-    temp_start_thresh=$(( $stop_thresh - 4 ))
-    if [ $temp_start_thresh -le $ccharge ] ; then
-        echo_debug "bat" "chargeonce_battery($bat_str).charge_level_too_high: $temp_start_thresh $stop_thresh"
-        echo "Error: current charge level ($ccharge) of $bat_str is higher than stop charge threshold - 4 ($temp_start_thresh)." 1>&2
-        return 1
-    else
-        echo_debug "bat" "chargeonce_battery($bat_str).setcharge: $temp_start_thresh $stop_thresh"
-    fi
-
-    setcharge_battery $temp_start_thresh $stop_thresh $bat_str
-    return $?
-}
-
-discharge_battery () { # discharge battery
-    # $1: battery
-    # global param: $tpacpi, $tpsmapi
-    # rc: 0=ok/1=error
-
-    local bat bdir ef pn rc
-    # $bat_str is global for cancel_force_discharge() trap
-
-    # check params
-    bat=$1
-    bat=${bat:=DEF}
-    bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
-
-    # check if selected battery is present
-    check_tp_battery $bat
-    case $? in
-        0) ;; # battery present
-
-        255) # no api
-            echo "Error: ThinkPad extended battery functions not available." 1>&2
-            echo_debug "bat" "discharge_battery.noapi"
-            return 1
-            ;;
-
-        *) # not present
-            echo "Error: battery $bat not present." 1>&2
-            echo_debug "bat" "discharge_battery.not_present($bat)"
-            return 1
-            ;;
-    esac
-
-    # start discharge
-    do_force_discharge $bat_str 1; rc=$?
-    if [ $rc -ne 0 ]; then
-        echo_debug "bat" "discharge_battery.force_discharge_not_available($bat_str)"
-        echo "Error: discharge function not available for this ThinkPad model." 1>&2
-        return 1
-    fi
-
-    trap cancel_force_discharge INT # enable ^C hook
-
-    # wait for start
-    while get_force_discharge $bat_str; do :; done
-    echo_debug "bat" "discharge_battery.running($bat_str)"
-
-    # wait for completion
-    while ! get_force_discharge $bat_str; do
-        clear
-        echo "Currently discharging battery $bat_str:"
-
-        # show current battery state
-        if [ $tpsmapi -eq 0 ]; then # use tp_smapi
-            bdir=$SMAPIDIR/$bat_str
-
-            printf "voltage            = %6s [mV]\n"  $(cat $bdir/voltage)
-            printf "remaining capacity = %6s [mWh]\n" $(cat $bdir/remaining_capacity)
-            printf "remaining percent  = %6s [%%]\n"  $(cat $bdir/remaining_percent)
-            printf "remaining time     = %6s [min]\n" $(cat $bdir/remaining_running_time_now)
-            printf "power              = %6s [mW]\n"  $(cat $bdir/power_avg)
-        else # use acpi
-            bdir=$ACPIBATDIR/$bat_str
-
-            if [ -d $bdir ]; then
-                printf "voltage            = %6s [mV]\n"  $(cat $bdir/voltage_now | sed 's/\(.*\).../\1/')
-                printf "remaining capacity = %6s [mWh]\n" $(cat $bdir/energy_now | sed 's/\(.*\).../\1/')
-
-                ef=$(cat $bdir/energy_full)
-                if [ "$ef" != "0" ]; then
-                    printf "remaining percent  = %6s [%%]\n" \
-                        $(( 100 * $(cat $bdir/energy_now) / $(cat $bdir/energy_full) ))
-                else
-                    printf "remaining percent  = not available [%]\n"
-                fi
-
-                pn=$(cat $bdir/power_now)
-                if [ "$pn" != "0" ]; then
-                    printf "remaining time     = %6s [min]\n" \
-                        $(( 60 * $(cat $bdir/energy_now) / $(cat $bdir/power_now) ))
-                    printf "power              = %6s [mW]\n" $(( $pn / 1000 ))
-                else
-                    printf "remaining time     = not discharging [min]\n"
-                fi
-
-            fi
-        fi
-        echo "Press Ctrl+C to cancel."
-        sleep 2
-    done
-
-    trap - INT # remove ^C hook
-
-    echo
-    echo "Done: battery $bat_str was completely discharged."
-    echo_debug "bat" "discharge_battery.complete($bat_str)"
-    return 0
-}
-
-# --- Drive Bay
-
-get_drivebay_device () { # Find generic dock interface for drive bay
-                         # rc: 0; retval: $dock
-	dock=$(grep -l ata_bay $DOCKGLOB/type 2> /dev/null)
-	dock=${dock%%/type}
-	if [ ! -d "$dock" ]; then
-		dock=""
-	fi
-
-    return 0
-}
-
-check_is_docked() { # check if $dock is docked;
-                    # rc: 0 if docked, else 1
-
-   local dock_status dock_info_file
-
-   # return 0 if any sysfs file indicates "docked"
-   for dock_info_file in docked firmware_node/status; do
-        if [ -f $dock/$dock_info_file ] && \
-            read -r dock_status < $dock/$dock_info_file 2>/dev/null; then
-            # catch empty $dock_status (safety check, unlikely case)
-            [ "${dock_status:-0}" != "0" ] && return 0
-        fi
-   done
-
-   # otherwise assume "not docked"
-   return 1
-}
-
-suspend_drivebay () { # Save power state of drive bay before suspend
-                      # $1: 0=ac mode, 1=battery mode
-
-    if [ "$1" = "1" ] && [ "$BAY_POWEROFF_ON_BAT" = "1" ]; then
-        # bat power and setting is active -> save state
-        get_drivebay_device
-
-        if [ -n "$dock" ]; then
-            mkdir -p $STATEDIR 2> /dev/null 1>&2
-
-            if ! check_is_docked; then
-                echo "off" > $BAYSTATEFILE
-                echo_debug "pm" "suspend_drivebay: bay=off"
-            else
-                echo "on" > $BAYSTATEFILE
-                echo_debug "pm" "suspend_drivebay: bay=on"
-            fi
-        fi
-    else
-        # not on bat or setting not active -> remove state file
-        rm -f $BAYSTATEFILE 2> /dev/null
-    fi
-
-    return 0
-}
-
-resume_drivebay () { # Restore power state of drive bay after resume
-
-	local cnt rc
-
-	[ -f $BAYSTATEFILE ] || return 0 # no state file -> do nothing
-
-    if [ "$(cat $BAYSTATEFILE)" = "off" ]; then
-        get_drivebay_device
-
-        if [ -n "$dock" ]; then
-            if check_is_docked; then
-                # device active -> deactivate
-                if [ -e $dock/undock ]; then
-                    cnt=5
-                    rc=1
-                    until [ $rc = 0 -o $cnt = 0 ]; do
-                        cnt=$((cnt - 1))
-                        echo 1 > $dock/undock
-                        rc=$?
-                        [ $rc = 0 ] || sleep 0.5
-                    done
-                    echo_debug "pm" "resume_drivebay.bay_off: rc=$rc"
-                fi
-            else
-                echo_debug "pm" "resume_drivebay.already_off"
-            fi
-        fi
-    fi
-
-    rm -f $BAYSTATEFILE 2> /dev/null
-
-    return 0
-}
-
-poweroff_drivebay () { # power off optical drive in drive bay
-    # $1: 0=conditional+quiet mode, 1=force+verbose mode
-    # Some code adapted from http://www.thinkwiki.org/wiki/How_to_hotswap_UltraBay_devices
-
-    local optdrv syspath
-
-    # Run only if either explicitly enabled or forced
-    [ "$BAY_POWEROFF_ON_BAT" = "1" ] || [ "$1" = "1" ] || return 0
-
-    get_drivebay_device
-    if [ -z "$dock" ] || [ ! -d "$dock" ]; then
-        echo_debug "pm" "poweroff_drivebay.no_bay_device"
-        [ "$1" = "1" ] && echo "Error: cannot locate bay device." 1>&2
-        return 1
-    fi
-    echo_debug "pm" "poweroff_drivebay: dock=$dock"
-
-    # Check if bay is occupied
-    if ! check_is_docked; then
-        echo_debug "pm" "poweroff_drivebay.drive_already_off"
-        [ "$1" = "1" ] && echo "No drive in bay (or power already off)."
-    else
-        # Check for optical drive
-        optdrv=/dev/${BAY_DEVICE:=sr0}
-        if [ ! -b "$optdrv" ]; then
-            echo_debug "pm" "poweroff_drivebay.no_opt_drive: $optdrv"
-            [ "$1" = "1" ] && echo "No optical drive in bay ($optdrv)."
-            return 0
-        else
-            echo_debug "pm" "poweroff_drivebay: optdrv=$optdrv"
-
-            echo -n "Powering off drive bay..."
-
-            # Unmount media
-            umount -l $optdrv > /dev/null 2>&1
-
-            # Sync drive
-            sync
-            sleep 1
-
-            # Power off drive
-            $HDPARM -Y $optdrv > /dev/null 2>&1
-            sleep 5
-
-            # Unregister scsi device
-            if syspath="$($UDEVADM info --query=path --name=$optdrv)"; then
-                syspath="/sys${syspath%/block/*}"
-
-                if [ "$syspath" != "/sys" ]; then
-                    echo_debug "pm" "poweroff_drivebay: syspath=$syspath"
-                    echo 1 > $syspath/delete
-                else
-                    echo_debug "pm" "poweroff_drivebay: got empty/invalid syspath for $optdrv"
-                fi
-            else
-                echo_debug "pm" "poweroff_drivebay: failed to get syspath (udevadm returned $?)"
-            fi
-
-            # Turn power off
-            echo 1 > $dock/undock
-            [ "$1" = "1" ] && echo "done."
-            echo_debug "pm" "poweroff_drivebay.bay_powered_off"
-        fi
-    fi
-
-    return 0
-}
diff --git a/tlp-functions.in b/tlp-functions.in
new file mode 100755
index 0000000..02a4fad
--- /dev/null
+++ b/tlp-functions.in
@@ -0,0 +1,2413 @@
+#!/bin/sh
+# tlp - power management functions
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+#
+# Some concepts and descriptions were adapted from:
+# - laptop-mode-tools
+# - thinkwiki.org
+
+# ----------------------------------------------------------------------------
+# Constants
+
+readonly TLPVER="0.8"
+
+readonly CONFFILE=@TLP_CONF@
+readonly RUNDIR=/var/run/tlp
+
+readonly ETHTOOL=ethtool
+readonly HDPARM=hdparm
+readonly IWC=iwconfig
+readonly IW=iw
+readonly MODPRO=modprobe
+readonly LOGGER=logger
+readonly UDEVADM=udevadm
+readonly LAPMODE=laptop_mode
+readonly NMCLI=nmcli
+readonly NMD=NetworkManager
+readonly NMTOOL=nm-tool
+readonly ENERGYPERF=x86_energy_perf_policy
+readonly DBUSSEND=dbus-send
+readonly SYSTEMD=systemd
+readonly SYSTEMCTL=systemctl
+readonly INITCTL=initctl
+
+readonly TPACPIBAT=$libdir/tpacpi-bat # libdir is initialized by main program
+
+readonly TPACPIDIR=/sys/devices/platform/thinkpad_acpi
+readonly SMAPIDIR=/sys/devices/platform/smapi
+readonly ACPIBATDIR=/sys/class/power_supply
+readonly NETD=/sys/class/net
+readonly BLUETOOTHD=/sys/class/bluetooth
+readonly PCID=/sys/bus/pci/devices
+readonly PCIDRV=/sys/bus/pci/drivers
+readonly I915D=/sys/module/i915/parameters
+readonly RADD=/sys/module/radeon
+readonly DMID=/sys/class/dmi/id/
+readonly CPU_BOOST_ALL_CTRL=/sys/devices/system/cpu/cpufreq/boost
+readonly INTEL_PSTATED=/sys/devices/system/cpu/intel_pstate
+readonly CPU_MIN_PERF_PCT=$INTEL_PSTATED/min_perf_pct
+readonly CPU_MAX_PERF_PCT=$INTEL_PSTATED/max_perf_pct
+readonly CPU_TURBO_PSTATE=$INTEL_PSTATED/no_turbo
+
+readonly USBD=/sys/bus/usb/devices
+readonly USB_TIMEOUT=2
+readonly USB_TIMEOUT_MS=2000
+readonly USB_WWAN_VENDORS="0bdb 05c6 1199"
+readonly USB_DONE=usb_done
+
+readonly DOCKGLOB="/sys/devices/platform/dock.?"
+
+readonly MODULES="acpi_call coretemp msr thinkpad_acpi tp_smapi"
+
+readonly STATEDIR="/var/lib/tlp"
+readonly RFSTATEFILE=$STATEDIR/rfkill-saved
+readonly BAYSTATEFILE=$STATEDIR/bay-saved
+
+readonly DISK_NOP_WORDS="_ keep"
+readonly DEFAULT_DISK_DEVICES="sda"
+readonly DEFAULT_DISK_IO_SCHEDULER="cfq"
+readonly DEFAULT_PM_DRIVER_BLACKLIST="radeon nouveau"
+readonly DEFAULT_USB_DRIVER_BLACKLIST="usbhid"
+
+# ----------------------------------------------------------------------------
+# Control
+nodebug=0
+
+# ----------------------------------------------------------------------------
+# Functions
+
+# --- Tests
+
+wordinlist () { # test if word in list
+                # $1: word, $2: whitespace-separated list of words
+    local word
+
+    if [ -n "${1-}" ]; then
+        for word in ${2-}; do
+            [ "${word}" != "${1}" ] || return 0 # exact match
+        done
+    fi
+
+    return 1 # no match
+}
+
+echo_debug () { # write debug msg if tag matches -- $1: tag; $2: msg;
+    [ "$nodebug" = "1" ] && return 0
+
+    if wordinlist "$1" "$TLP_DEBUG"; then
+        $LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
+    fi
+}
+
+cmd_exists () { # test if command exists -- $1: command
+    command -v $1 > /dev/null 2>&1
+}
+
+check_sysfs ()  { # check if sysfile exists -- $1: routine; $2: sysfs path
+    if wordinlist "sysfs" "$TLP_DEBUG"; then
+        if [ ! -e $2 ]; then
+            $LOGGER -p debug -t "tlp[$$,$PPID]" "$1: $2 nonexistent"
+        fi
+    fi
+}
+
+test_root () { # test root privilege -- rc: 0=root, 1=not root
+    [ "$(id -u)" = "0" ]
+}
+
+check_root () { # show error message and exit when root privilege missing
+    if ! test_root; then
+        echo "Error: missing root privilege." 1>&2
+        exit 1
+    fi
+}
+
+check_tlp_enabled () { # check if TLP is enabled in config file
+    # rc: 0=disabled/1=enabled
+
+    if [ ! "$TLP_ENABLE" = "1" ]; then
+        echo "Error: TLP power save is disabled. Set TLP_ENABLE=1 in $CONFFILE." 1>&2
+        return 1
+    else
+        return 0
+    fi
+}
+
+check_laptop_mode_tools () { # check if lmt installed -- rc: 0=not installed, 1=installed
+    if cmd_exists $LAPMODE; then
+        echo 1>&2
+        echo "***Warning: laptop-mode-tools detected, this may cause conflicts with TLP." 1>&2
+        echo "            Please uninstall laptop-mode-tools." 1>&2
+        echo 1>&2
+        echo_debug "pm" "check_laptop_mode_tools: yes"
+        return 1
+    else
+        return 0
+    fi
+}
+
+check_systemd () { # check if systemd is the active init system (PID 1) and systemctl is installed
+                   # rc: 0=yes, 1=no
+    [ -d /run/systemd/system ] && cmd_exists $SYSTEMCTL
+}
+
+check_upstart () { # check if upstart is active init system (PID 1)
+                   # rc: 0=yes, 1=no
+    cmd_exists $INITCTL && $INITCTL --version | grep -q upstart
+}
+
+check_openrc () { # check if openrc is the active init system (PID 1)
+                   # rc: 0=yes, 1=no
+    [ -e /run/openrc/softlevel ]
+}
+
+
+# --- PATH
+add_sbin2path () { # check if /sbin /usr/sbin in $PATH, otherwise add them
+                   # retval: $PATH, $oldpath, $addpath
+    local sp
+
+    oldpath="$PATH"
+    addpath=""
+
+    for sp in /usr/sbin /sbin; do
+        if [ -d $sp ] && [ ! -h $sp ]; then
+            # dir exists and is not a symlink
+            case ":$PATH:" in
+                *":$sp:"*) # $sp already in $PATH
+                    ;;
+
+                *) # $sp not in $PATH, add it
+                    addpath="$addpath:$sp"
+                    ;;
+            esac
+        fi
+    done
+
+    if [ -n "$addpath" ]; then
+      export PATH="${PATH}${addpath}"
+    fi
+
+    return 0
+}
+
+# --- Configuration
+
+read_defaults () { # read config file
+    if [ -f $CONFFILE ]; then
+        . $CONFFILE
+        return 0
+    else
+        return 1
+    fi
+}
+
+# --- Kernel Modules
+
+load_modules () { # load needed kernel modules
+    local mod
+
+    # verify module loading is allowed (else explicitly disabled)
+    # and possible (else implicitly disabled)
+    [ "${TLP_LOAD_MODULES:-y}" = "y" ] && [ -e /proc/modules ] || return 0
+
+    # load modules, ignore any errors
+    for mod in $MODULES; do
+        $MODPRO $mod > /dev/null 2>&1
+    done
+    return 0
+}
+
+# --- DMI
+
+read_dmi () { # read dmi data -- $*: keywords; stdout: dmi strings
+    local ds key outr
+
+    outr=""
+    for key in $*; do
+        ds="$( cat ${DMID}/$key 2> /dev/null | \
+                egrep -iv 'not available|to be filled|DMI table is broken' )"
+        if [ -n "$outr" ]; then
+            [ -n "$ds" ] && outr="$outr $ds"
+        else
+            outr="$ds"
+        fi
+    done
+
+    echo $outr
+    return 0
+}
+
+# --- ThinkPad
+
+is_thinkpad () { # check for ThinkPad hardware
+                 # rc: 0=ThinkPad, 1=other hardware
+
+    if [ -d $TPACPIDIR ]; then
+        # Kernel module thinkpad_acpi is loaded
+
+        # Check dmi product string for occurence of "ThinkPad"
+        if read_dmi product_version | grep -q "ThinkPad"; then
+            # It's a real ThinkPad
+            return 0
+        fi
+    fi
+
+    # No ThinkPad detected
+    return 1
+}
+
+# --- Power Source
+
+get_sys_power_supply () { # get current power source
+                          # rc: 0=ac, 1=battery, 2=unknown
+
+    local psrc
+    local rc=
+
+    for psrc in /sys/class/power_supply/*; do
+        # -f $psrc/type not necessary - cat 2>.. handles this
+        case "$(cat $psrc/type 2> /dev/null)" in
+            Mains)
+                # AC detected, check if online
+                if [ "$(cat $psrc/online 2> /dev/null)" = "1" ]; then
+                    rc=0
+                    break
+                fi
+                # else AC not online => keep $rc as-is
+                ;;
+
+            Battery)
+                # set rc to battery, but don't stop looking for AC
+                rc=1
+                ;;
+
+            *)
+                echo_debug "pm" "unknown power supply: ${psrc##*/}"
+                ;;
+        esac
+    done
+
+    # set rc to unknown if we haven't seen any AC/battery power source so far
+    : ${rc:=2}
+
+    return $rc
+}
+
+get_power_state () { # get current power source -- rc: 0=ac, 1=battery
+    # similar to get_sys_power_supply(),
+    # but maps unknown power source to TLP_DEFAULT_MODE
+    local psrc
+
+    get_sys_power_supply
+    psrc=$?
+
+    if [ $psrc -eq 2 ]; then
+        # unknown power supply, apply default mode
+        case "$TLP_DEFAULT_MODE" in
+            ac|AC)   psrc=0 ;;
+            bat|BAT) psrc=1 ;;
+            *)       psrc=0 ;; # use AC if no default mode configured
+        esac
+    fi
+
+    return $psrc
+}
+
+echo_started_mode () { # print operation mode -- $1: 0=ac mode, 1=battery mode
+    if [ "$1" = "0" ]; then
+        echo "TLP started in AC mode."
+    else
+        echo "TLP started in battery mode."
+    fi
+
+    return 0
+}
+
+# --- Locking and Semaphores
+
+set_run_flag () { # set flag -- $1: flag name
+                  # rc: 0=success/1,2=failed
+    local rc
+
+    if mkdir -p $RUNDIR 2> /dev/null 1>&2 ; then
+        touch $RUNDIR/$1; rc=$?
+        echo_debug "lock" "set_run_flag.touch: $1; rc=$rc"
+
+        return $rc
+    else
+        # mkdir failed
+        echo_debug "lock" "set_run_flag.mkdir_failed"
+        return 2
+    fi
+}
+
+reset_run_flag () { # reset flag -- $1: flag name
+    if rm $RUNDIR/$1 2> /dev/null 1>&2 ; then
+        echo_debug "lock" "reset_run_flag($1).remove"
+    else
+        echo_debug "lock" "reset_run_flag($1).not_found"
+    fi
+
+    return 0
+}
+
+check_run_flag () { # check flag -- $1: flag name
+                    # rc: 0=flag set/1=flag not set
+    local rc
+
+    [ -f $RUNDIR/$1 ]; rc=$?
+    echo_debug "lock" "check_run_flag($1): rc=$rc"
+
+    return $rc
+}
+
+check_and_set_semaphore () { # check and set semaphore -- $1: semaphore name
+                             # rc: 0=success/1=failed
+    local rc
+
+    { mkdir -p $RUNDIR && mkdir $RUNDIR/$1 ; } 2> /dev/null 1>&2
+    rc=$?
+    echo_debug "lock" "check_and_set_semaphore($1): rc=$rc"
+
+    return $rc
+}
+
+unset_semaphore () { # unset semaphore -- $1: semaphore name
+    local rc
+
+    rmdir $RUNDIR/$1 2> /dev/null 1>&2
+    rc=$?
+    echo_debug "lock" "unset_semaphore($1): rc=$rc"
+
+    return $rc
+}
+
+set_timed_lock () { # create timestamp n seconds in the future
+    # $1: lock id, $2: lock duration [s]
+
+    local rc
+    local lock=${1}_timed_lock_$(date +%s -d "+${2} seconds")
+
+    set_run_flag $lock; rc=$?
+    echo_debug "lock" "set_timed_lock($1, $2): $lock; rc=$rc"
+
+    return $rc
+}
+
+check_timed_lock () { # check if active timestamp exists
+    # $1: lock id; rc: 0=locked/1=not locked
+
+    local lockid=$1
+    local lockfile locktime
+    local time=$(date +%s)
+
+    for lockfile in $RUNDIR/${lockid}_timed_lock_*; do
+        if [ -f $lockfile ]; then
+            locktime=${lockfile#${RUNDIR}/${lockid}_timed_lock_}
+            if [ $time -lt $(( $locktime - 120 )) ]; then
+                # timestamp is more than 120 secs in the future,
+                # something weird has happened -> remove it
+                rm $lockfile
+                echo_debug "lock" "check_timed_lock($1).remove_invalid: ${lockfile#${RUNDIR}/}"
+            elif [ $time -lt $locktime ]; then
+                # timestamp in the future -> we're locked
+                echo_debug "lock" "check_timed_lock($1).locked: $time, $locktime"
+                return 0
+            else
+                # obsolete timestamp -> remove it
+                rm $lockfile
+                echo_debug "lock" "check_timed_lock($1).remove_obsolete: ${lockfile#${RUNDIR}/}"
+            fi
+        fi
+    done
+
+    echo_debug "lock" "check_timed_lock($1).not_locked: $time"
+    return 1
+}
+
+# --- Filesystem
+
+set_laptopmode () { # set kernel laptop mode -- $1: 0=ac mode, 1=battery mode
+    check_sysfs "set_laptopmode" "/proc/sys/vm/laptop_mode"
+
+    local isec
+
+    if [ "$1" = "1" ]; then
+        isec=${DISK_IDLE_SECS_ON_BAT:-}
+    else
+        isec=${DISK_IDLE_SECS_ON_AC:-}
+    fi
+    # replace with empty string if non-numeric chars are contained
+    isec=$(echo "$isec" | egrep '^[0-9]+$')
+
+    if [ -z "$isec" ]; then
+        # do nothing if unconfigured or non numeric value
+        echo_debug "pm" "set_laptopmode($1).not_configured"
+        return 0
+    fi
+
+    echo_debug "pm" "set_laptopmode($1): $isec"
+    echo $isec > /proc/sys/vm/laptop_mode
+
+    return 0
+}
+
+set_dirty_parms () { # set filesystem buffer params
+    # $1: 0=ac mode, 1=battery mode
+    # concept from laptop-mode-tools
+
+    local age cage df
+
+    check_sysfs "set_dirty_parms" "/proc/sys/vm"
+
+    if [ "$1" = "1" ]; then
+        age=${MAX_LOST_WORK_SECS_ON_BAT:-0}
+    else
+        age=${MAX_LOST_WORK_SECS_ON_AC:-0}
+    fi
+
+    # calc age in centisecs, non numeric values result in "0"
+    cage=$(($age * 100))
+
+    if [ "$cage" = "0" ]; then
+        # do nothing if unconfigured or invalid age
+        echo_debug "pm" "set_dirty_parms($1).not_configured"
+        return 0
+    fi
+
+    echo_debug "pm" "set_dirty_parms($1): $cage"
+
+    for df in /proc/sys/vm/dirty_writeback_centisecs \
+             /proc/sys/vm/dirty_expire_centisecs \
+             /proc/sys/fs/xfs/age_buffer_centisecs \
+             /proc/sys/fs/xfs/xfssyncd_centisecs; do
+        [ -w $df ] && echo $cage > $df
+    done
+
+    [ -w /proc/sys/fs/xfs/xfsbufd_centisecs ] \
+        && echo 3000 > /proc/sys/fs/xfs/xfsbufd_centisecs
+
+    return 0
+}
+
+# --- CPU
+
+check_intel_pstate () { # detect intel_pstate driver -- retval: $intel_pstate
+    #  Note: intel_pstate requires Linux 3.9 or higher
+    intel_pstate=0
+
+    [ -d $INTEL_PSTATED ] && intel_pstate=1
+    return 0
+}
+
+set_scaling_governor () { # set scaling governor -- $1: 0=ac mode, 1=battery mode
+    local gov cpu
+
+    if [ "$1" = "1" ]; then
+        gov=$CPU_SCALING_GOVERNOR_ON_BAT
+    else
+        gov=$CPU_SCALING_GOVERNOR_ON_AC
+    fi
+
+    if [ -n "$gov" ]; then
+        echo_debug "pm" "set_scaling_governor($1): $gov"
+        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
+            [ -f $cpu ] && echo $gov > $cpu 2> /dev/null
+        done
+    fi
+
+    return 0
+}
+
+set_scaling_min_max_freq () { # set scaling limits -- $1: 0=ac mode, 1=battery mode
+    local minfreq maxfreq cpu
+
+    if [ "$1" = "1" ]; then
+        minfreq=$CPU_SCALING_MIN_FREQ_ON_BAT
+        maxfreq=$CPU_SCALING_MAX_FREQ_ON_BAT
+    else
+        minfreq=$CPU_SCALING_MIN_FREQ_ON_AC
+        maxfreq=$CPU_SCALING_MAX_FREQ_ON_AC
+    fi
+
+    if [ -n "$minfreq" ]; then
+        echo_debug "pm" "set_scaling_min_max_freq($1).min: $minfreq"
+        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq; do
+            [ -f $cpu ] && echo $minfreq > $cpu 2> /dev/null
+        done
+    fi
+
+    if [ -n "$maxfreq" ]; then
+        echo_debug "pm" "set_scaling_min_max_freq($1).max: $maxfreq"
+        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq; do
+            [ -f $cpu ] && echo $maxfreq > $cpu 2> /dev/null
+        done
+    fi
+
+    return 0
+}
+
+set_cpu_perf_pct () { # set Intel P-state performance
+                      # $1: 0=ac mode, 1=battery mode
+    local min max
+
+    check_intel_pstate
+    if [ "$intel_pstate" != "1" ]; then
+        echo_debug "pm" "set_cpu_perf_pct($1).no_intel_pstate"
+        return 0
+    fi
+
+    if [ "$1" = "1" ]; then
+        min="${CPU_MIN_PERF_ON_BAT:-}"
+        max="${CPU_MAX_PERF_ON_BAT:-}"
+    else
+        min="${CPU_MIN_PERF_ON_AC:-}"
+        max="${CPU_MAX_PERF_ON_AC:-}"
+    fi
+
+    if [ ! -f $CPU_MIN_PERF_PCT ]; then
+        echo_debug "pm" "set_cpu_perf_pct($1).min.not_supported"
+    elif [ -n "$min" ]; then
+        { echo "$min" > $CPU_MIN_PERF_PCT; } 2> /dev/null
+        echo_debug "pm" "set_cpu_perf_pct($1).min: $min"
+    else
+        echo_debug "pm" "set_cpu_perf_pct($1).min.not_configured"
+    fi
+
+    if [ ! -f $CPU_MAX_PERF_PCT ]; then
+        echo_debug "pm" "set_cpu_perf_pct($1).max.not_supported"
+    elif [ -n "$max" ]; then
+        { echo "$max" > $CPU_MAX_PERF_PCT; } 2> /dev/null
+        echo_debug "pm" "set_cpu_perf_pct($1).max: $max"
+    else
+        echo_debug "pm" "set_cpu_perf_pct($1).max.not_configured"
+    fi
+
+    return 0
+}
+
+set_cpu_boost_all () { # $1: 0=ac mode, 1=battery mode
+    # global cpu boost behavior control based on the current power mode
+    #
+    # Relevant config option(s): CPU_BOOST_ON_{AC,BAT} with values {'',0,1}
+    #
+    # Note:
+    #  * needs commit #615b7300717b9ad5c23d1f391843484fe30f6c12
+    #     (linux-2.6 tree), "Add support for disabling dynamic overclocking",
+    #    => requires Linux 3.7 or later
+
+    local val ival
+
+    if [ "$1" = "1" ]; then
+        val="${CPU_BOOST_ON_BAT:-}"
+    else
+        val="${CPU_BOOST_ON_AC:-}"
+    fi
+
+    if [ -z "$val" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_cpu_boost_all($1).not_configured"
+        return 0
+    fi
+
+    check_intel_pstate
+
+    if [ $intel_pstate -eq 1 ]; then
+        # use intel_pstate sysfiles
+        if [ -f $CPU_TURBO_PSTATE ]; then
+            ival=$(($val ^ 1))
+            echo "$ival" > $CPU_TURBO_PSTATE 2> /dev/null
+            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate: $val"
+        else
+            echo_debug "pm" "set_cpu_boost_all($1).intel_pstate.cpu_not_supported"
+        fi
+    elif [ -f $CPU_BOOST_ALL_CTRL ]; then
+        # use acpi_cpufreq sysfiles
+        # simple test for attribute "w" doesn't work, so actually write
+        if ( echo "$val" > $CPU_BOOST_ALL_CTRL ) 2> /dev/null; then
+            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq: $val"
+        else
+            echo_debug "pm" "set_cpu_boost_all($1).acpi_cpufreq.cpu_not_supported"
+        fi
+    else
+        echo_debug "pm" "set_cpu_boost_all($1).not_available"
+    fi
+
+    return 0
+}
+
+set_sched_powersave () { # set multi-core/-thread powersave policy
+    # $1: 0=ac mode, 1=battery mode
+
+    local pwr pool sdev
+    local avail=0
+
+    if [ "$1" = "1" ]; then
+        pwr=${SCHED_POWERSAVE_ON_BAT:-}
+    else
+        pwr=${SCHED_POWERSAVE_ON_AC:-}
+    fi
+
+    if [ -z "$pwr" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_sched_powersave($1).not_configured"
+        return 0
+    fi
+
+
+    for pool in mc smp smt; do
+        sdev="/sys/devices/system/cpu/sched_${pool}_power_savings"
+        if [ -f $sdev ]; then
+            echo_debug "pm" "set_sched_powersave($1): ${sdev##/*/} $pwr"
+            echo $pwr > "$sdev"
+            avail=1
+        fi
+    done
+
+    [ "$avail" = "1" ] || echo_debug "pm" "set_sched_powersave($1).not_available"
+
+    return 0
+}
+
+set_nmi_watchdog () { # enable/disable nmi watchdog
+    local nmiwd=${NMI_WATCHDOG:-}
+
+    if [ -z "$nmiwd" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_nmi_watchdog.not_configured"
+        return 0
+    fi
+
+    if [ -f /proc/sys/kernel/nmi_watchdog ]; then
+        echo "$nmiwd" > /proc/sys/kernel/nmi_watchdog 2> /dev/null
+        if [ $? = 0 ]; then
+            echo_debug "pm" "set_nmi_watchdog: $nmiwd"
+        else
+            echo_debug "pm" "set_nmi_watchdog.disabled_by_kernel: $nmiwd"
+        fi
+    else
+        echo_debug "pm" "set_nmi_watchdog.not_available"
+    fi
+
+    return 0
+}
+
+set_phc_controls () { # set core voltages
+    local control
+    local ctrl_avail="0"
+
+    phc_controls=${PHC_CONTROLS:-}
+
+    if [ -z "$phc_controls" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_phc_controls.not_configured"
+        return 0
+    fi
+
+    for control in /sys/devices/system/cpu/cpu*/cpufreq/phc_controls; do
+        if [ -f $control ]; then
+            echo_debug "pm" "set_phc_controls: $control $phc_controls"
+            echo $phc_controls > $control
+            ctrl_avail="1"
+        fi
+    done
+
+    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_phc_controls.not_available"
+
+    return 0
+}
+
+set_energy_perf_policy () { # set performance versus energy savings policy
+    # $1: 0=ac mode, 1=battery mode
+
+    local perf rc
+
+    if [ "$1" = "1" ]; then
+        perf=${ENERGY_PERF_POLICY_ON_BAT:-}
+    else
+        perf=${ENERGY_PERF_POLICY_ON_AC:-}
+    fi
+
+    if [ -z "$perf" ]; then
+        echo_debug "pm" "set_energy_perf_policy($1).not_configured"
+    elif ! cmd_exists $ENERGYPERF; then
+        echo_debug "pm" "set_energy_perf_policy($1).not_available"
+    else
+        $ENERGYPERF $perf > /dev/null 2>&1
+        rc=$?
+        case $rc in
+            0) echo_debug "pm" "set_energy_perf_policy($1): $perf" ;;
+            1) echo_debug "pm" "set_energy_perf_policy($1): $perf -- unsupported cpu" ;;
+            2) echo_debug "pm" "set_energy_perf_policy($1): $perf -- kernel specific x86_energy_perf_policy missing" ;;
+            *) echo_debug "pm" "set_energy_perf_policy($1): $perf -- unknown rc=$rc " ;;
+        esac
+        return $rc
+    fi
+
+    return 0
+}
+
+# --- Storage Devices
+
+check_disk_hdparm_cap () { # check if relevant disk device
+    # $1: dev; rc: 0=yes/1=no
+
+    if [ -z "$($HDPARM -I /dev/$1 2>&1 | \
+               egrep 'Invalid argument|Invalid exchange|missing sense data|No such device')" ]; then
+        return 0
+    else
+        return 1
+    fi
+}
+
+echo_disk_model () { # print disk model -- $1: dev
+    local model
+
+    model=$($HDPARM -I /dev/$1 2>&1 | grep 'Model Number' | \
+      cut -f2 -d: | sed -r 's/^ *//' )
+    echo "$model"
+
+    return 0
+}
+
+echo_disk_firmware () { # print firmware version --- $1: dev
+    local firmware
+
+    firmware=$($HDPARM -I /dev/$1 2>&1 | grep 'Firmware Revision' | \
+      cut -f2 -d: | sed -r 's/^ *//' )
+    echo "$firmware"
+
+    return 0
+}
+
+get_disk_state () { # get disk power state -- $1: dev; retval: $disk_state
+    disk_state=$($HDPARM -C /dev/$1 2>&1 | awk -F ':' '/drive state is/ { gsub(/ /,"",$2); print $2; }')
+    [ -z "$disk_state" ] && disk_state="(not available)"
+
+    return 0
+}
+
+spindown_disk () { # stop spindle motor -- $1: dev
+    $HDPARM -y /dev/$1 > /dev/null 2>&1
+
+    return 0
+}
+
+get_disk_apm_level () { # get disk apm level -- $1: dev; rc: apm
+    local apm
+
+    apm=$($HDPARM -I /dev/$1 2>&1 | grep 'Advanced power management level' | \
+          cut -f2 -d: | egrep "^ *[0-9]+ *$")
+    if [ -n "$apm" ]; then
+        return $apm
+    else
+        return 0
+    fi
+
+}
+
+get_disk_trim_capability () { # check for trim capability
+    # $1: dev; rc: 0=no, 1=yes, 254=no ssd device
+
+    local trim
+
+    if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'Solid State Device')" ]; then
+        if [ -n "$($HDPARM -I /dev/$1 2>&1 | grep 'TRIM supported')" ]; then
+            trim=1
+        else
+            trim=0
+        fi
+    else
+        trim=255
+    fi
+
+    return $trim
+}
+
+get_disk_dev () { # translate disk id to device (sdX)
+    # $1: id or dev; retval: $disk_dev, $disk_id
+
+    if [ -h /dev/disk/by-id/$1 ]; then
+        # $1 is disk id
+        disk_id=$1
+        disk_dev=$(echo $disk_id | sed -r 's/-part[1-9][0-9]*$//')
+        disk_dev=$(readlink /dev/disk/by-id/$disk_dev)
+        disk_dev=${disk_dev##*/}
+    else
+        # $1 is disk dev
+        disk_dev=$1
+        disk_id=""
+    fi
+    # strip partition number
+    disk_dev=$(echo $disk_dev | sed -r 's/[1-9][0-9]*$//')
+}
+
+set_disk_apm_level () { # set disk apm level
+    # $1: 0=ac mode, 1=battery mode
+
+    local pwrmode="$1"
+    local dev log_message
+
+    # when undefined use default
+    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
+
+    # set @argv := apmlist (blanks removed - relying on a sane $IFS)
+    if [ "$pwrmode" = "1" ]; then
+        set -- $DISK_APM_LEVEL_ON_BAT
+    else
+        set -- $DISK_APM_LEVEL_ON_AC
+    fi
+
+    # exit if empty apmlist
+    [ $# -gt 0 ] || return 0
+
+    # pairwise iteration DISK_DEVICES[1,n], apmlist[1,m]; m > 0
+    #  for j in [1,n]: disk_dev[j], apmlist[min(j,m)]
+    #
+    for dev in $DISK_DEVICES; do
+        : ${1:?BUG: broken DISK_APM_LEVEL list handling}
+
+        get_disk_dev $dev
+        log_message="set_disk_apm_level($pwrmode): $disk_dev [$disk_id] $1"
+
+        if [ ! -b /dev/$disk_dev ]; then
+            echo_debug "disk" "${log_message} -- missing"
+        elif ! check_disk_hdparm_cap $disk_dev; then
+            echo_debug "disk" "${log_message} -- not supported"
+        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
+            echo_debug "disk" "${log_message} -- keep as is"
+        else
+            echo_debug "disk" "${log_message}"
+            $HDPARM -B $1 /dev/$disk_dev > /dev/null 2>&1
+        fi
+
+        # last entry in apmlist applies to all remaining disks
+        [ $# -lt 2 ] || shift
+    done
+
+    return 0
+}
+
+set_disk_spindown_timeout () { # set disk spindown timeout
+    # $1: 0=ac mode, 1=battery mode
+
+    local pwrmode="$1"
+    local dev log_message
+
+    # when undefined use default
+    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
+
+    # set @argv := timeoutlist
+    if [ "$pwrmode" = "1" ]; then
+        set -- $DISK_SPINDOWN_TIMEOUT_ON_BAT
+    else
+        set -- $DISK_SPINDOWN_TIMEOUT_ON_AC
+    fi
+
+    # exit if empty timeoutlist
+    [ $# -gt 0 ] || return 0
+
+    # pairwise iteration DISK_DEVICES[1,n], timeoutlist[1,m]; m > 0
+    #  for j in [1,n]: disk_dev[j], timeoutlist[min(j,m)]
+    #
+    for dev in $DISK_DEVICES; do
+        : ${1:?BUG: broken DISK_SPINDOWN_TIMEOUT list handling}
+
+        get_disk_dev $dev
+        log_message="set_disk_spindown_timeout($pwrmode): $disk_dev [$disk_id] $1"
+
+        if [ ! -b /dev/$disk_dev ]; then
+            echo_debug "disk" "${log_message} -- missing"
+        elif ! check_disk_hdparm_cap $disk_dev; then
+            echo_debug "disk" "${log_message} -- not supported"
+        elif wordinlist "$1" "$DISK_NOP_WORDS"; then
+            echo_debug "disk" "${log_message} -- keep as is"
+        else
+            echo_debug "disk" "${log_message}"
+            $HDPARM -S $1 /dev/$disk_dev > /dev/null 2>&1
+        fi
+
+        # last entry in timeoutlist applies to all remaining disks
+        [ $# -lt 2 ] || shift
+    done
+
+    return 0
+}
+
+set_disk_io_sched () { # set disk io scheduler
+    local dev sched schedctrl log_message
+
+    # when undefined use default
+    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
+
+    # set @argv := schedlist
+    set -- $DISK_IOSCHED
+
+    # exit if empty timeoutlist
+    [ $# -gt 0 ] || return 0
+
+    # pairwise iteration DISK_DEVICES[1,n], schedlist[1,m]; m > 0
+    #  for j in [1,min(n,m)]   : disk_dev[j], schedlistj]
+    #  for j in [min(n,m)+1,n] : disk_dev[j], %DEFAULT_DISK_IO_SCHEDULER
+    #
+    for dev in $DISK_DEVICES; do
+        get_disk_dev $dev
+
+        # get sched from argv, use default scheduler when list is too short
+        sched=${1:-${DEFAULT_DISK_IO_SCHEDULER}}
+        schedctrl="/sys/block/$disk_dev/queue/scheduler"
+        log_message="set_disk_io_sched: $disk_dev [$disk_id] $sched"
+
+        if [ ! -b /dev/$disk_dev ]; then
+            echo_debug "disk" "${log_message} -- missing"
+        elif [ ! -f $schedctrl ]; then
+            echo_debug "disk" "${log_message} -- not supported"
+        elif wordinlist "$sched" "$DISK_NOP_WORDS"; then
+            echo_debug "disk" "${log_message} -- keep as is"
+        else
+            echo_debug "disk" "${log_message}"
+            echo -n $sched > $schedctrl
+        fi
+
+        # using %DEFAULT_DISK_IO_SCHEDULER when argv is empty
+        [ $# -eq 0 ] || shift
+    done
+
+    return 0
+}
+
+# --- Device Power Management
+
+set_sata_link_power () { # set sata link power management
+    # $1: 0=ac mode, 1=battery mode
+
+    local i
+    local pwr=""
+    local ctrl_avail="0"
+
+    if [ "$1" = "1" ]; then
+        pwr=${SATA_LINKPWR_ON_BAT:-}
+    else
+        pwr=${SATA_LINKPWR_ON_AC:-}
+    fi
+
+    if [ -z "$pwr" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_sata_link_power($1).not_configured"
+        return 0
+    fi
+
+    echo_debug "pm" "set_sata_link_power($1): $pwr"
+
+    for i in /sys/class/scsi_host/host*/link_power_management_policy ; do
+        if [ -f $i ]; then
+            echo "$pwr" > $i
+            ctrl_avail="1"
+        fi
+    done
+
+    [ "$ctrl_avail" = "0" ] && echo_debug "pm" "set_sata_link_power($1).not_available"
+    return 0
+}
+
+set_pcie_aspm () { # set pcie active state power management
+    # $1: 0=ac mode, 1=battery mode
+
+    local pwr
+
+    if [ "$1" = "1" ]; then
+        pwr=${PCIE_ASPM_ON_BAT:-}
+    else
+        pwr=${PCIE_ASPM_ON_AC:-}
+    fi
+
+    if [ -z "$pwr" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_pcie_aspm($1).not_configured"
+        return 0
+    fi
+
+    if [ -f /sys/module/pcie_aspm/parameters/policy ]; then
+        echo "$pwr" > /sys/module/pcie_aspm/parameters/policy 2> /dev/null
+        if [ $? = 0 ]; then
+            echo_debug "pm" "set_pcie_aspm($1): $pwr"
+        else
+            echo_debug "pm" "set_pcie_aspm($1).disabled_by_kernel"
+        fi
+    else
+        echo_debug "pm" "set_pcie_aspm($1).not_available"
+    fi
+
+    return 0
+}
+
+set_radeon_profile () { # set radeon power profile
+    # $1: 0=ac mode, 1=battery mode
+
+    local card level pwr rc1 rc2
+    local sdone=0 # 1=radeon present
+
+    if [ ! -d $RADD ]; then
+        # No card present --> exit
+        echo_debug "pm" "set_radeon_profile($1).no_card"
+        return 0
+    fi
+
+    for card in /sys/class/drm/card[0-9]/device ; do
+        if [ -f $card/power_dpm_state ] && [ -f $card/power_dpm_force_performance_level ]; then
+            # Use new radeon dynamic power management method (dpm)
+            if [ "$1" = "1" ]; then
+                pwr=${RADEON_DPM_STATE_ON_BAT:-}
+                level=${RADEON_DPM_PERF_LEVEL_ON_BAT:-auto}
+            else
+                pwr=${RADEON_DPM_STATE_ON_AC:-}
+                level=${RADEON_DPM_PERF_LEVEL_ON_AC:-auto}
+            fi
+
+            if [ -z "$pwr" ]; then
+                # do nothing if unconfigured
+                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
+                return 0
+            fi
+
+            if [ -n "$pwr" ]; then
+                echo "$pwr" > $card/power_dpm_state 2> /dev/null; rc1=$?
+                echo "$level" > $card/power_dpm_force_performance_level 2> /dev/null; rc2=$?
+                echo_debug "pm" "set_radeon_profile($1): $card state=$pwr [rc=$rc1] perf=$level [rc=$rc2]"
+            fi
+
+            sdone=1
+
+        elif [ -f $card/power_method ] && [ -f $card/power_profile ]; then
+            # Use old radeon power profile method
+            if [ "$1" = "1" ]; then
+                pwr=${RADEON_POWER_PROFILE_ON_BAT:-}
+            else
+                pwr=${RADEON_POWER_PROFILE_ON_AC:-}
+            fi
+
+            if [ -z "$pwr" ]; then
+                # do nothing if unconfigured
+                echo_debug "pm" "set_radeon_profile($1).not_configured: $card"
+                return 0
+            fi
+
+            if [ -n "$pwr" ]; then
+                echo_debug "pm" "set_radeon_profile($1): $card profile=$pwr"
+                echo "profile" > $card/power_method 2> /dev/null
+                echo "$pwr" > $card/power_profile 2> /dev/null
+            fi
+
+            sdone=1
+        fi
+    done
+
+    if [ $sdone -eq 0 ]; then
+        echo_debug "pm" "set_radeon_profile($1).not_available"
+    fi
+
+    return 0
+}
+
+set_sound_power_mode () { # set sound chip power modes
+    # $1: 0=ac mode, 1=battery mode
+
+    local pwr cpwr
+
+    # new config param
+    if [ "$1" = "1" ]; then
+        pwr=${SOUND_POWER_SAVE_ON_BAT:-}
+    else
+        pwr=${SOUND_POWER_SAVE_ON_AC:-}
+    fi
+
+    # when unconfigured consider legacy config param
+    [ -z "$pwr" ] && pwr=${SOUND_POWER_SAVE:-}
+
+    if [ -z "$pwr" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_sound_power_mode($1).not_configured"
+        return 0
+    fi
+
+    cpwr=${SOUND_POWER_SAVE_CONTROLLER:-Y}
+
+    check_sysfs "set_sound_power_mode" "/sys/module"
+
+    if [ -d /sys/module/snd_hda_intel ]; then
+        echo_debug "pm" "set_sound_power_mode($1).hda: $pwr controller=$cpwr"
+        echo "$pwr" > /sys/module/snd_hda_intel/parameters/power_save
+
+        if [ "$pwr" = "0" ]; then
+            echo "N" >  /sys/module/snd_hda_intel/parameters/power_save_controller
+        else
+            echo "$cpwr" > /sys/module/snd_hda_intel/parameters/power_save_controller
+        fi
+    fi
+
+    if [ -d /sys/module/snd_ac97_codec ]; then
+        echo_debug "pm" "set_sound_power_mode($1).ac97: $pwr"
+        echo "$pwr"  > /sys/module/snd_ac97_codec/parameters/power_save
+    fi
+
+    return 0
+}
+
+get_pci_class_descr () { # get long descr of pci device class
+    # $1: class; retval: lclass
+
+    case $1 in
+        0x020000) lclass="Ethernet controller" ;;
+        0x028000) lclass="Wireless" ;;
+        0x040300) lclass="Audio device" ;;
+        0x060000) lclass="Host Bridge" ;;
+        0x080500) lclass="SD Card Reader" ;;
+        0x088000|0x088001) lclass="Card Reader" ;;
+        0x0c0000|0x0c0010) lclass="Firewire" ;;
+        *) lclass="" ;;
+    esac
+
+    return 0
+}
+
+set_runtime_pm () { # set runtime power management
+    # $1: 0=ac mode, 1=battery mode
+
+    local address class ccontrol control device doall driver drv_bl pci_bl type
+
+    if [ "$1" = "1" ]; then
+        ccontrol=${RUNTIME_PM_ON_BAT:-}
+    else
+        ccontrol=${RUNTIME_PM_ON_AC:-}
+    fi
+
+    if [ -z "$ccontrol" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_runtime_pm($1).not_configured"
+        return 0
+    fi
+
+    # enable for all devices
+    doall=${RUNTIME_PM_ALL:-1}
+
+    # driver specific blacklist
+    drv_bl=${RUNTIME_PM_DRIVER_BLACKLIST:-$DEFAULT_PM_DRIVER_BLACKLIST}
+
+    # pci id blacklist
+    pci_bl=${RUNTIME_PM_BLACKLIST:-}
+
+    # add devices assigned to blacklisted drivers to the pci id blacklist
+    for driver in $drv_bl; do # iterate list
+        if [ -n "$driver" ] && [ -d $PCIDRV/$driver ]; then
+            # driver is active --> iterate over assigned devices
+            for device in $PCIDRV/$driver/0000:*; do
+                # get short device address
+                address=${device##/*/0000:}
+
+                # add to list when not already contained
+                if ! wordinlist "$address" "$pci_bl"; then
+                    pci_bl="$pci_bl $address"
+                fi
+            done
+        fi
+    done
+
+    # iterate pci(e) devices
+    for type in $PCID; do
+        for device in $type/*; do
+            class="none"
+            lclass=""
+
+            # get short device address
+            address=${device##/*/0000:}
+
+            if wordinlist "$address" "$pci_bl"; then
+                # device is in blacklist
+                control="black"
+
+            elif [ -f $device/class ] && [ -f $device/power/control ]; then
+                class=$(cat $device/class)
+                get_pci_class_descr $class
+                control=$ccontrol                
+
+                if [ -z "$lclass" ] && [ $doall -ne 1 ]; then
+                    # device has no long descr and all flag is not set
+                    control="class"
+                fi
+
+                case $control in
+                    auto|on) echo $control > $device/power/control ;;
+
+                    class|none) ;; # do nothing
+                esac
+            fi
+
+            [ -n "$lclass" ] && lclass=" $lclass"
+            echo_debug "pm" "set_runtime_pm($1).$control: $device [$class$lclass]"
+        done
+    done
+
+    return 0
+}
+
+# --- Wifi Power Management
+
+get_wifi_ifaces () { # get all wifi devices -- retval: $wifaces
+    local wi wiu
+    wifaces=""
+
+    for wiu in $NETD/*/uevent; do
+        if grep -q -s "DEVTYPE=wlan" $wiu ; then
+            wi=${wiu%/uevent}; wi=${wi##*/}
+            wifaces="$wifaces $wi"
+        fi
+    done
+
+    wifaces="${wifaces# }"
+    return 0
+}
+
+get_wifi_driver () { # get driver associated with interface
+                     # $1: iface; retval: $wifidrv
+    local drvl
+
+    wifidrv=""
+    if [ -d $NETD/$1 ]; then
+        drvl=$(readlink $NETD/$1/device/driver)
+        [ -n "$drvl" ] && wifidrv=${drvl##*/}
+    fi
+
+    return 0
+}
+
+set_wifi_power_mode () { # set wifi power save mode -- $1: 0=ac mode, 1=battery mode
+    local pwr iface
+    local rc=0
+    local cmdx=0
+
+    if [ "$1" = "1" ]; then
+        pwr=${WIFI_PWR_ON_BAT:-}
+    else
+        pwr=${WIFI_PWR_ON_AC:-}
+    fi
+
+    if [ -z "$pwr" ]; then
+        # do nothing if unconfigured
+        echo_debug "pm" "set_wifi_power_mode($1).not_configured"
+        return 0
+    fi
+
+    case $pwr in
+        0|1|N)          pwr="off" ;;
+        2|3|4|5|6|Y)    pwr="on"  ;;
+    esac
+
+    get_wifi_ifaces
+
+    for iface in $wifaces; do
+        if [ -n "$iface" ]; then
+            if  [ "$X_DONT_USE_IW" != "1" ] && cmd_exists $IW; then
+                # try with iw first
+                $IW dev $iface set power_save $pwr > /dev/null 2>&1
+                rc=$?
+                echo_debug "pm" "set_wifi_power_mode($1, $iface).iw: $pwr; rc=$rc"
+                cmdx=1
+            fi
+            if cmd_exists $IWC; then
+                if [ $rc -ne 0 ] || [ $cmdx -eq 0 ]; then
+                    # iw did not succeed or iw not installed -> try with iwconfig
+                    $IWC $iface power $pwr > /dev/null 2>&1
+                    rc=$?
+                    echo_debug "pm" "set_wifi_power_mode($1, $iface).iwconfig: $pwr; rc=$rc"
+                    cmdx=1
+                fi
+            fi
+            if [ $cmdx -eq 0 ]; then
+                # neither iw nor iwconfig installed -> no way
+                echo_debug "pm" "set_wifi_power_mode($1, $iface).no_tool"
+            fi
+        fi
+    done
+
+    return 0
+}
+
+wireless_in_use () { # check if wifi or wwan device is in use -- $1: iface
+    if [ -f $NETD/$1/carrier ]; then
+        if [ "$(cat $NETD/$1/carrier 2>/dev/null)" = "1" ]; then
+            return 0
+        fi
+    fi
+    return 1
+}
+
+any_wifi_in_use () { # check if any wifi device is in use
+    local iface
+
+    get_wifi_ifaces
+    for iface in $wifaces; do
+        wireless_in_use $iface && return 0
+    done
+
+    return 1
+}
+
+# --- WWAN Power Management
+
+get_wwan_ifaces () { # get all wwan devices -- retval: $wanifaces
+    local wi wiu
+    wanifaces=""
+
+    for wiu in $NETD/*/uevent; do
+        if grep -q -s "DEVTYPE=wwan" $wiu ; then
+            wi=${wiu%/uevent}; wi=${wi##*/}
+            wanifaces="$wanifaces $wi"
+        fi
+    done
+
+    wanifaces="${wanifaces# }"
+    return 0
+}
+
+any_wwan_in_use () { # check if any wwan device is in use
+    local iface
+
+    get_wwan_ifaces
+    for iface in $wanifaces; do
+        wireless_in_use $iface && return 0
+    done
+
+    return 1
+}
+
+get_wwan_driver () { # get driver associated with interface
+                     # $1: iface; retval: $wwandrv
+    local drvl
+
+    wwandrv=""
+    if [ -d $NETD/$1 ]; then
+        drvl=$(readlink $NETD/$1/device/driver)
+        [ -n "$drvl" ] && wwandrv=${drvl##*/}
+    fi
+
+    return 0
+}
+
+# --- Bluetooth Power Management
+
+get_bluetooth_ifaces () { # get all bluetooth devices -- retval: $bifaces
+    # enumerate symlinks only
+    bifaces="$(for i in $BLUETOOTHD/*; do [ -h $i ] && echo ${i##/*/}; done | grep -v ':')"
+    return 0
+}
+
+get_bluetooth_driver () { # get driver associated with interface -- $1: iface; retval: $bluetoothdrv
+    local drvl
+
+    bluetoothdrv=""
+    if [ -d $BLUETOOTHD/$1 ]; then
+        drvl=$(readlink $BLUETOOTHD/$1/device/driver)
+        [ -n "$drvl" ] && bluetoothdrv=${drvl##*/}
+    fi
+
+    return 0
+}
+
+dbus_call () { # call method via system dbus -- $1: dest; $2: $path; $3: interface, $4: $method
+    $DBUSSEND --system --type=method_call --print-reply --dest="$1" "$2" "$3.$4" 2> /dev/null
+}
+
+bluez_call () { # call bluez method via dbus -- $1: path; $2: interface; $3: $method
+    dbus_call "org.bluez" "$1" "org.bluez.$2" "$3"
+}
+
+bluez_bluetooth_in_use () { # check if bluetooth device (specified as dbus path) is in use $1: dbus path
+    local devices device connected
+
+    devices=$(bluez_call $1 Adapter ListDevices | sed -n 's/\s*object path "\(.*\)"\s*/\1/p')
+    for device in $devices; do
+        connected="$(bluez_call $device Device GetProperties | grep -A 1 Connected | sed -n 's/.*boolean //p')"
+        test "$connected" = "true" && return 0
+    done
+
+    return 1
+}
+
+bluetooth_in_use () { # check if bluetooth device is in use -- $1: iface
+    local paths path
+
+    paths="$(bluez_call / Manager ListAdapters | sed -n 's/\s*object path "\(.*\)"\s*/\1/p' | grep /$1\$)"
+    for path in $paths; do
+        bluez_bluetooth_in_use "$path" && return 0
+    done
+
+    return 1
+}
+
+any_bluetooth_in_use () { # check if some bluetooth device is in use
+    local paths path
+
+    paths="$(bluez_call / Manager ListAdapters | sed -n 's/\s*object path "\(.*\)"\s*/\1/p')"
+    for path in $paths; do
+        bluez_bluetooth_in_use "$path" && return 0
+    done
+
+    return 1
+}
+
+# --- LAN
+
+get_eth_ifaces () { # get all eth devices -- retval: $ethifaces
+    local ei eic
+    ethifaces=""
+
+    for eic in $NETD/*/device/class; do
+        if [ -f $eic ] \
+            && [ "$(cat $eic)" = "0x020000" ] \
+            && [ ! -d "${eic%/class}/ieee80211" ]; then
+
+            ei=${eic%/device/class}; ei=${ei##*/}
+            ethifaces="$ethifaces $ei"
+        fi
+    done
+
+    ethifaces="${ethifaces# }"
+    return 0
+}
+
+disable_wake_on_lan () {  # disable WOL
+    local ei
+
+    WOL_DISABLE=${WOL_DISABLE:-N}
+
+    if [ "$WOL_DISABLE" = "Y" ]; then
+        get_eth_ifaces
+
+        for ei in $ethifaces; do
+            echo_debug "pm" "disable_wake_on_lan: $ei"
+            $ETHTOOL -s $ei wol d > /dev/null 2>&1
+        done
+    fi
+
+    return 0
+}
+
+# --- USB Autosuspend
+
+set_usb_suspend () { # activate usb autosuspend for all devices except input and blacklisted
+    # $1: 0=silent/1=report result; $2: on/auto
+
+    local busdev control devices exc usbdev usbid subdev
+    local ctrlf="control"
+    local autof="autosuspend_delay_ms"
+
+    check_sysfs "set_usb_suspend" "$USBD"
+
+    if [ "$USB_AUTOSUSPEND" = "1" ]; then
+        # autosuspend is configured
+
+        # iterate devices
+        devices=$(ls $USBD 2> /dev/null | grep -v ':')
+
+        for usbdev in $devices; do
+            if [ -f $USBD/$usbdev/power/autosuspend ] || [ -f $USBD/$usbdev/power/autosuspend_delay_ms ]; then
+                usbid="$(cat $USBD/$usbdev/idVendor):$(cat $USBD/$usbdev/idProduct)"
+                busdev="Bus $(cat $USBD/$usbdev/busnum) Dev $(cat $USBD/$usbdev/devnum)"
+
+                control="${2:-auto}"
+                exc=""
+                chg=0
+
+                if [ "$control" != "on" ]; then
+                    if wordinlist "$usbid" "$USB_WHITELIST"; then
+                        # device is in whitelist -- whitelist always wins
+                        control="auto"
+                        exc="_dev_white"
+                    elif wordinlist "$usbid" "$USB_BLACKLIST"; then
+                        # device is in blacklist
+                        control="on"
+                        exc="_dev_black"
+                    else
+                        # check for hid subdevices
+                        for subdev in $USBD/$usbdev/*:*; do
+                            if [ -d $subdev ] && [ "$(cat $subdev/bInterfaceClass)" = "03" ]; then
+                                control="on"
+                                exc="_hid_black"
+                                break
+                            fi
+                        done
+
+                        if [ -z "$exc" ]; then
+                            # check for wwan vendor ids
+                            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
+
+                            if [ $USB_BLACKLIST_WWAN = "1" ]; then
+                                vendor="$(cat $USBD/$usbdev/idVendor)"
+                                if wordinlist "$vendor" "$USB_WWAN_VENDORS"; then
+                                    control="on"
+                                    exc="_wwan_black"
+                                fi
+                            fi
+                        fi
+                    fi
+                fi
+
+                if [ -f $USBD/$usbdev/power/control ]; then
+                    if [ "$(cat $USBD/$usbdev/power/control)" != "$control" ]; then
+                        # Write actual changes only
+                        echo "$control" > $USBD/$usbdev/power/control
+                        chg=1
+                    fi
+                else
+                    # level is deprecated
+                    if [ "$(cat $USBD/$usbdev/power/level)" != "$control" ]; then
+                        # Write actual changes only
+                        echo "$control" > $USBD/$usbdev/power/level
+                        chg=1
+                    fi
+                    ctrlf="level"
+                fi
+
+                if [ "$X_TLP_USB_SET_AUTOSUSPEND_DELAY" = "1" ]; then
+                    # set autosuspend_delay
+                    if [ -f $USBD/$usbdev/power/autosuspend_delay_ms ]; then
+                        echo $USB_TIMEOUT_MS > $USBD/$usbdev/power/autosuspend_delay_ms
+                    else
+                        # autosuspend is deprecated
+                        echo $USB_TIMEOUT > $USBD/$usbdev/power/autosuspend
+                        autof="autosuspend"
+                    fi
+                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev [$ctrlf $autof]"
+                elif [ $chg -eq 1 ]; then
+                    # default: change control but not autosuspend_delay, i.e. keep kernel default setting
+                    echo_debug "usb" "set_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev [$ctrlf]"
+                else
+                    # we didn't change anything actually
+                    echo_debug "usb" "udev_usb_suspend.$control$exc: $busdev ID $usbid $USBD/$usbdev"
+                fi
+
+            fi
+        done
+        [ "$1" = "1" ] && echo "USB autosuspend settings applied."
+    else
+        [ "$1" = "1" ] && echo "Error: USB autosuspend is disabled. Set USB_AUTOSUSPEND=1 in $DEFAULT_FILE." 1>&2
+    fi
+
+    # set "startup completion" flag for tlp-usb-udev
+    set_run_flag $USB_DONE
+
+    return 0
+}
+
+# --- ThinkPad Battery Functions
+
+check_tpsmapi () {  # check if tp_smapi is supported and loaded
+    # rc: 0=supported/2=module tp_smapi not loaded/127=not installed
+    # retval: $tpsmapi
+
+    if [ -d $SMAPIDIR ]; then
+        # module loaded
+        tpsmapi=0
+    else
+        if [ -n "$(modinfo tp_smapi 2> /dev/null)" ]; then
+            # module installed but not loaded
+            tpsmapi=2
+        else
+            # module not installed
+            tpsmapi=127
+        fi
+    fi
+
+    echo_debug "bat" "check_tp_smapi: rc=$tpsmapi"
+    return $tpsmapi
+}
+
+check_tpacpi () { # check if tpacpi-bat is supported
+    # rc: 0=supported/2=acpi_call not loaded/4=disabled/
+    #     127=acpi_call not installed/255=not supported
+    # retval: $tpacpi
+
+    if [ -z "$(modinfo acpi_call 2> /dev/null)" ]; then
+        # module not installed
+        tpacpi=127
+    else
+        $TPACPIBAT -g FD 1 > /dev/null 2>&1
+        tpacpi=$?
+
+        if [ $tpacpi -eq 0 ] && [ "$DISABLE_TPACPIBAT" = "1" ]; then
+            tpacpi=4
+        fi
+    fi
+
+    echo_debug "bat" "check_tpacpi: rc=$tpacpi"
+    return $tpacpi
+}
+
+check_tp_battery () { # check ThinkPad battery presence and return index
+    # $1: BAT0/BAT1/DEF
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0=bat exists/1=bat nonexistent/255=no thresh api available
+    # retval: $bat_str: BAT0/BAT1; $bat_idx: 1/2
+
+    # defaults
+    local rc=255 # no threshold API available
+    bat_idx=0    # no tpacpi-bat index
+    bat_str=""   # no default bat found
+    local blist bs
+
+    # check prerequisites: tpacpi-bat or tp-smapi
+    check_tpacpi
+    check_tpsmapi
+
+    # validate param
+    case $1 in
+        BAT0|BAT1) blist="$1" ;;
+        DEF) blist="BAT0 BAT1" ;;
+
+        *)         return 1 ;;
+    esac
+
+    if [ $tpsmapi -eq 0 ]; then # tp-smapi available
+        for bs in $blist; do
+            # check tp-smapi name space
+            [ -d $SMAPIDIR/$bs ] && [ "$(cat $SMAPIDIR/$bs/installed)" = "1" ]
+            rc=$?
+            if [ $rc -eq 0 ]; then
+                case $bs in
+                    BAT0) bat_idx=1; bat_str="$bs" ;;
+                    BAT1) bat_idx=2; bat_str="$bs" ;;
+                esac
+            fi
+            [ $rc -ne 0 ] || break # exit loop on first battery detected
+        done
+    elif [ $tpacpi -eq 0 ]; then # tpacpi-bat available
+        for bs in $blist; do
+            # check acpi name space
+            [ -d $ACPIBATDIR/$bs ] && [ "$(cat $ACPIBATDIR/$bs/present)" = "1" ]
+            rc=$?
+            if [ $rc -eq 0 ]; then
+                # determine tpacpi-bat index
+                case $bs in
+                    BAT0)
+                        bat_idx=1 # BAT0 is always assumed main battery
+                        bat_str="$bs"
+                        ;;
+
+                    BAT1)
+                        # check with tpacpi-bat(2) if BAT1 is main or aux battery
+                        if $TPACPIBAT -g ST 2 2> /dev/null 1>&2 ; then
+                            bat_idx=2 # BAT1 is aux
+                        else
+                            bat_idx=1 # BAT1 is main
+                        fi
+                        bat_str="$bs"
+                        ;;
+                esac
+            fi
+            [ $rc -ne 0 ] || break # exit loop on first battery detected
+        done
+    fi
+
+    echo_debug "bat" "check_tp_battery($1): idx=$bat_idx; str=$bat_str; tpacpi=$tpacpi; tpsmapi=$tpsmapi; rc=$rc"
+    return $rc
+}
+
+read_tpacpi_threshold () { # $1: ST/SP (start/stop); $2: 0/1 (battery)
+                           # rc: threshold (1..99, 0=default, 255=error)
+    local thresh rc
+
+    thresh=$($TPACPIBAT -g $1 $2 2> /dev/null | cut -f1 -d' ')
+    rc=$?
+
+    if [ $rc -eq 0 ] && [ -n "$thresh" ]; then
+        [ $thresh -ge 128 ] && thresh=$(($thresh - 128)) # Remove offset of 128 for Edge S430
+        return $thresh
+    else
+        return 255
+    fi
+}
+
+do_threshold () { # $1: start/stop, $2: BAT0/BAT1, $3: new value
+    # global param: $bat_idx, $tpsmapi, $tpacpi
+    # rc: 0=ok/1=read error/2=thresh not present/255=no thresh api
+
+    local bsys ts
+    local old_thresh=-1
+    local new_thresh=$3
+    local rc=0
+
+    [ $3 -eq -1 ] && return 0 # -1 = do not set threshold
+
+    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
+        if [ $bat_idx -ne 0 ]; then
+            # replace factory default values with 0 for tpacpi
+            case $1 in
+                start)
+                    [ $new_thresh -eq  96 ] && new_thresh=0
+                    ts="ST"
+                    ;;
+                stop)
+                    [ $new_thresh -eq 100 ] && new_thresh=0
+                    ts="SP"
+                    ;;
+            esac
+
+            read_tpacpi_threshold $ts $bat_idx
+            old_thresh=$?
+
+            if [ $new_thresh -ne $old_thresh ]; then
+                $TPACPIBAT -s $ts $bat_idx $new_thresh > /dev/null 2>&1
+                rc=$?
+            fi
+        fi
+    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
+        bsys=$SMAPIDIR/$2/${1}_charge_thresh
+
+        if [ -f $bsys ]; then
+            old_thresh=$(cat $bsys 2> /dev/null)
+            if [ -z "$old_thresh" ]; then
+                rc=1
+            elif [ "$old_thresh" -ne "$new_thresh" ]; then
+                echo $new_thresh > $bsys 2> /dev/null
+                rc=$?
+            fi
+        else
+            rc=2 # invalid bat argument
+        fi
+    else
+        # no threshold API available
+        rc=255
+    fi
+
+    echo_debug "bat" "do_threshold($1, $2): bat_idx=$bat_idx; tpacpi=$tpacpi; tpsmapi=$tpsmapi; old=$old_thresh; new=$new_thresh; rc=$rc"
+    return $rc
+}
+
+normalize_thresholds () { # check values and enforce start < stop - 3
+    # $1: start threshold; $2: stop_threshold
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0
+    # retval: $start_thresh, $stop_thresh
+
+    local type thresh
+
+    for type in start stop; do
+        case $type in
+            start) thresh=$1 ;;
+            stop)  thresh=$2 ;;
+        esac
+
+        # check for 1..3 digits, replace with empty string if non-numeric chars are contained
+        thresh=$(echo "$thresh" | egrep '^[0-9]{1,3}$')
+        # replace empty string with -1
+        [ -z "$thresh" ] && thresh=-1
+
+        # ensure min/max values; replace 0 with defaults 96/100
+        case $type in
+            start)
+                [ $thresh -eq 0 ] || [ $thresh -gt 96 ] && thresh=96
+                start_thresh=$thresh
+                ;;
+
+            stop)
+                [ $thresh -eq 0 ] || [ $thresh -gt 100 ] && thresh=100
+                [ $thresh -ne -1 ] && [ $thresh -lt 5 ] && thresh=5
+                stop_thresh=$thresh
+                ;;
+        esac
+    done
+
+    # enforce start < stop - 3
+    if [ $start_thresh -ne -1 ] && [ $stop_thresh -ne -1 ]; then
+        [ $start_thresh -ge $(($stop_thresh - 3)) ] && start_thresh=$(($stop_thresh - 4))
+    fi
+
+    echo_debug "bat" "normalize_thresholds($1, $2): start=$start_thresh; stop=$stop_thresh"
+
+    return 0
+}
+
+set_charge_thresholds () { # write all charge thresholds from configuration
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0
+
+    local rc
+
+    if check_tp_battery BAT0; then
+        normalize_thresholds "$START_CHARGE_THRESH_BAT0" "$STOP_CHARGE_THRESH_BAT0"
+
+        if [ $stop_thresh -ne -1 ]; then
+            do_threshold stop BAT0 $stop_thresh; rc=$?
+            echo_debug "bat" "set_charge_thresholds.stop(BAT0): $stop_thresh; rc=$rc"
+        else
+            echo_debug "bat" "set_charge_thresholds.stop(BAT0).not_set"
+        fi
+
+        if [ $start_thresh -ne -1 ]; then
+            do_threshold start BAT0 $start_thresh; rc=$?
+            echo_debug "bat" "set_charge_thresholds.start(BAT0): $start_thresh; rc=$rc"
+        else
+            echo_debug "bat" "set_charge_thresholds.start(BAT0).not_set"
+        fi
+    fi
+
+    if check_tp_battery BAT1; then
+        normalize_thresholds "$START_CHARGE_THRESH_BAT1" "$STOP_CHARGE_THRESH_BAT1"
+
+        if [ $stop_thresh -ne -1 ]; then
+            do_threshold stop BAT1 $stop_thresh; rc=$?
+            echo_debug "bat" "set_charge_thresholds.stop(BAT1): $stop_thresh; rc=$rc"
+        else
+            echo_debug "bat" "set_charge_thresholds.stop(BAT1).not_set"
+        fi
+
+        if [ $start_thresh -ne -1 ]; then
+            do_threshold start BAT1 $start_thresh; rc=$?
+            echo_debug "bat" "set_charge_thresholds.start(BAT1): $start_thresh; rc=$rc"
+        else
+            echo_debug "bat" "set_charge_thresholds.start(BAT1).not_set"
+        fi
+    fi
+
+    return 0
+}
+
+do_force_discharge () { # write force discharge state
+    # $1: BAT0/BAT1, $2: 0=off/1=on
+    # global param: $bat_idx, $tpacpi, $tpsmapi
+    # rc: 0=done/1=write error/2=discharge not present/255=no thresh api
+
+    local bsys rc=0
+
+    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
+        $TPACPIBAT -s FD $bat_idx $2 > /dev/null 2>&1; rc=$?
+        echo_debug "bat" "do_force_discharge.tpacpi-bat($1, $2): rc=$rc"
+    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
+        bsys=$SMAPIDIR/$1/force_discharge
+
+        if [ -f $bsys ]; then
+            echo $2 > $bsys 2> /dev/null; rc=$?
+        else
+            rc=2
+        fi
+        echo_debug "bat" "do_force_discharge.tp-smapi($1, $2): rc=$rc"
+    else # no threshold API available
+        rc=255
+        echo_debug "bat" "do_force_discharge.noapi($1, $2)"
+    fi
+
+    return $rc
+}
+
+get_force_discharge () { # $1: BAT0/BAT1,
+    # global param: $bat_idx, $tpacpi, $tpsmapi
+    # rc: 0=done/1=read error/2=discharge not present/255=no thresh api
+
+    local bsys rc=0
+
+    if [ $tpacpi -eq 0 ]; then # use tpacpi-bat
+        case $($TPACPIBAT -g FD $bat_idx 2> /dev/null) in
+            yes) rc=1 ;;
+            no)  rc=0 ;;
+            *)   rc=2 ;;
+        esac
+    elif [ $tpsmapi -eq 0 ]; then # use tp-smapi
+        bsys=$SMAPIDIR/$1/force_discharge
+
+        if [ -f $bsys ]; then
+            rc=$(cat $bsys 2> /dev/null)
+        else
+            rc=2
+        fi
+    else # no threshold API available
+        rc=255
+    fi
+
+    echo_debug "bat" "get_force_discharge($1): rc=$rc"
+    return $rc
+}
+
+cancel_force_discharge () { # called from trap -- global param: $bat_str
+    do_force_discharge $bat_str 0
+    echo_debug "bat" "force_discharge.cancelled($bat_str)"
+    echo " Cancelled."
+
+    exit 0
+}
+
+check_ac_power () { # check if ac power connected -- $1: function
+
+    if ! get_sys_power_supply ; then
+        echo_debug "bat" "check_ac_power($1).no_ac_power"
+        echo "Error: $1 is possible on AC power only." 1>&2
+        return 1
+    fi
+
+    return 0
+}
+
+setcharge_battery () { # write charge thresholds (called from cmd line)
+    # $1: start charge threshold, $2: stop charge threshold, $3: battery
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0=ok/1=error
+
+    local bat rc st sp
+    local use_cfg=0
+    # $bat_str is global for cancel_force_discharge() trap
+
+    # check params
+    case $# in
+        0) # no args
+            bat=DEF   # use default(1st) battery
+            use_cfg=1 # use configured values
+            ;;
+
+        1) # assume $1 is battery
+            bat=$1
+            use_cfg=1 # use configured values
+            ;;
+
+        2) # assume $1,$2 are thresholds
+            st=$1
+            sp=$2
+            bat=DEF # use default(1st) battery
+            ;;
+
+        3) # assume $1,$2 are thresholds, $3 is battery
+            st=$1
+            sp=$2
+            bat=$3
+            ;;
+    esac
+
+    # convert bat to uppercase
+    bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
+
+    # check bat presence and/or get default(1st) battery
+    check_tp_battery $bat
+    case $? in
+        0) # battery present
+            # get configured values if requested
+            if [ $use_cfg -eq 1 ]; then
+                eval st="\$START_CHARGE_THRESH_$bat_str"
+                eval sp="\$STOP_CHARGE_THRESH_$bat_str"
+            fi
+            ;;
+
+        255) # no api
+            echo "Error: ThinkPad extended battery functions not available." 1>&2
+            echo_debug "bat" "setcharge_battery.noapi"
+            return 1
+            ;;
+
+        *) # not present
+            echo "Error: battery $bat not present." 1>&2
+            echo_debug "bat" "setcharge_battery.not_present($bat)"
+            return 1
+            ;;
+    esac
+
+    # validate thresholds
+    normalize_thresholds $st $sp
+
+    # write threshold values
+    echo "Setting temporary charge thresholds for $bat_str:"
+
+    if [ $stop_thresh -ne -1 ]; then
+        do_threshold stop $bat_str $stop_thresh; rc=$?
+
+        echo_debug "bat" "setcharge_battery.stop($bat_str): $stop_thresh; rc=$rc"
+        if [ $rc -eq 0 ]; then
+            echo "  stop  = $stop_thresh"
+        else
+            echo "  stop  => Error: cannot set threshold. Aborting." 1>&2
+            return 1
+        fi
+    else
+        echo_debug "bat" "setcharge_battery.stop($bat_str).not_configured"
+        echo "  stop = not configured"
+    fi
+
+    if [ $start_thresh -ne -1 ]; then
+        do_threshold start $bat_str $start_thresh; rc=$?
+
+        echo_debug "bat" "setcharge_battery.start($bat_str): $start_thresh; rc=$rc"
+        if [ $rc -eq 0 ]; then
+            echo "  start = $start_thresh"
+        else
+            echo "  start => Warning: cannot set threshold." 1>&2
+            return 1
+        fi
+    else
+        echo_debug "bat" "setcharge_battery.start($bat_str).not_configured"
+        echo "  start = not configured"
+    fi
+
+    return 0
+}
+
+get_sysval () { # $1: file; rc: sysfile value
+    local sysf="$1"
+    local val=""
+
+    # read sysval when it exists
+    [ -f $sysf ] && val=$(cat $sysf 2> /dev/null)
+
+    # replace with 0 if empty string or non-numeric chars are contained
+    [ -z "$(echo "$val" | egrep '^[0-9]+$')" ] && val=0
+
+    return $val
+}
+
+chargeonce_battery () { # charge battery to upper threshold once
+    # $1: battery
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0=ok/1=error
+
+    local bat bdir temp_start_thresh
+    local start_thresh=""
+    local stop_thresh=""
+    local efull=0
+    local enow=0
+    local ccharge=0
+
+    # check params
+    if [ $# -gt 0 ]; then
+        # some parameters given, check them
+
+        # get battery arg
+        bat=${1:-DEF}
+        bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
+    else
+        # no parameters given, use default(1st) battery
+        bat=DEF
+    fi
+
+    # check if selected battery is present
+    check_tp_battery $bat
+    case $? in
+        0) ;; # battery present
+
+        255) # no api
+            echo "Error: ThinkPad extended battery functions not available." 1>&2
+            echo_debug "bat" "chargeonce_battery.noapi"
+            return 1
+            ;;
+
+        *) # not present
+            echo "Error: battery $bat_str not present." 1>&2
+            echo_debug "bat" "chargeonce_battery.not_present($bat_str)"
+            return 1
+            ;;
+    esac
+
+    # get and check thresholds from configuration)
+    eval stop_thresh=\$STOP_CHARGE_THRESH_$bat_str
+    eval start_thresh=\$START_CHARGE_THRESH_$bat_str
+
+    [ -z "$stop_thresh" ] && stop_thresh=100
+    if [ -z "$start_thresh" ] ; then
+        echo_debug "bat" "chargeonce_battery($bat_str).start_threshold_not_configured"
+        echo "Error: no start charge threshold configured for $bat_str." 1>&2
+        return 1
+    fi
+
+    # get current charge level (in %)
+    if [ $tpsmapi -eq 0 ]; then
+        # use tp-smapi
+        bdir="$SMAPIDIR/$bat_str"
+        get_sysval $bdir/remaining_percent; ccharge=$?
+    else
+        # use ACPI data
+        bdir="$ACPIBATDIR/$bat_str"
+        if [ -f $bdir/energy_full ]; then
+            get_sysval $bdir/energy_full; efull=$?
+            get_sysval $dir/energy_now; enow=$?
+        fi
+
+        if [ $efull -ne 0 ]; then
+            ccharge=$(( 100 * $enow / $efull ))
+        else
+            ccharge=-1
+        fi
+    fi
+
+    if [ $ccharge -eq -1 ] ; then
+        echo_debug "bat" "chargeonce_battery($bat_str).charge_level_unknown: enow=$enow; efull=$efull; ccharge=$ccharge"
+        echo "Error: cannot determine charge level for $bat_str." 1>&2
+        return 1
+    else
+        echo_debug "bat" "chargeonce_battery($bat_str).charge_level: enow=$enow; efull=$efull; ccharge=$ccharge"
+    fi
+
+    temp_start_thresh=$(( $stop_thresh - 4 ))
+    if [ $temp_start_thresh -le $ccharge ] ; then
+        echo_debug "bat" "chargeonce_battery($bat_str).charge_level_too_high: $temp_start_thresh $stop_thresh"
+        echo "Error: current charge level ($ccharge) of $bat_str is higher than stop charge threshold - 4 ($temp_start_thresh)." 1>&2
+        return 1
+    else
+        echo_debug "bat" "chargeonce_battery($bat_str).setcharge: $temp_start_thresh $stop_thresh"
+    fi
+
+    setcharge_battery $temp_start_thresh $stop_thresh $bat_str
+    return $?
+}
+
+discharge_battery () { # discharge battery
+    # $1: battery
+    # global param: $tpacpi, $tpsmapi
+    # rc: 0=ok/1=error
+
+    local bat bdir ef pn rc
+    # $bat_str is global for cancel_force_discharge() trap
+
+    # check params
+    bat=$1
+    bat=${bat:=DEF}
+    bat=$(echo $bat | tr "[:lower:]" "[:upper:]")
+
+    # check if selected battery is present
+    check_tp_battery $bat
+    case $? in
+        0) ;; # battery present
+
+        255) # no api
+            echo "Error: ThinkPad extended battery functions not available." 1>&2
+            echo_debug "bat" "discharge_battery.noapi"
+            return 1
+            ;;
+
+        *) # not present
+            echo "Error: battery $bat not present." 1>&2
+            echo_debug "bat" "discharge_battery.not_present($bat)"
+            return 1
+            ;;
+    esac
+
+    # start discharge
+    do_force_discharge $bat_str 1; rc=$?
+    if [ $rc -ne 0 ]; then
+        echo_debug "bat" "discharge_battery.force_discharge_not_available($bat_str)"
+        echo "Error: discharge function not available for this ThinkPad model." 1>&2
+        return 1
+    fi
+
+    trap cancel_force_discharge INT # enable ^C hook
+
+    # wait for start
+    while get_force_discharge $bat_str; do :; done
+    echo_debug "bat" "discharge_battery.running($bat_str)"
+
+    # wait for completion
+    while ! get_force_discharge $bat_str; do
+        clear
+        echo "Currently discharging battery $bat_str:"
+
+        # show current battery state
+        if [ $tpsmapi -eq 0 ]; then # use tp_smapi
+            bdir=$SMAPIDIR/$bat_str
+
+            printf "voltage            = %6s [mV]\n"  $(cat $bdir/voltage)
+            printf "remaining capacity = %6s [mWh]\n" $(cat $bdir/remaining_capacity)
+            printf "remaining percent  = %6s [%%]\n"  $(cat $bdir/remaining_percent)
+            printf "remaining time     = %6s [min]\n" $(cat $bdir/remaining_running_time_now)
+            printf "power              = %6s [mW]\n"  $(cat $bdir/power_avg)
+        else # use acpi
+            bdir=$ACPIBATDIR/$bat_str
+
+            if [ -d $bdir ]; then
+                printf "voltage            = %6s [mV]\n"  $(cat $bdir/voltage_now | sed 's/\(.*\).../\1/')
+                printf "remaining capacity = %6s [mWh]\n" $(cat $bdir/energy_now | sed 's/\(.*\).../\1/')
+
+                ef=$(cat $bdir/energy_full)
+                if [ "$ef" != "0" ]; then
+                    printf "remaining percent  = %6s [%%]\n" \
+                        $(( 100 * $(cat $bdir/energy_now) / $(cat $bdir/energy_full) ))
+                else
+                    printf "remaining percent  = not available [%]\n"
+                fi
+
+                pn=$(cat $bdir/power_now)
+                if [ "$pn" != "0" ]; then
+                    printf "remaining time     = %6s [min]\n" \
+                        $(( 60 * $(cat $bdir/energy_now) / $(cat $bdir/power_now) ))
+                    printf "power              = %6s [mW]\n" $(( $pn / 1000 ))
+                else
+                    printf "remaining time     = not discharging [min]\n"
+                fi
+
+            fi
+        fi
+        echo "Press Ctrl+C to cancel."
+        sleep 2
+    done
+
+    trap - INT # remove ^C hook
+
+    echo
+    echo "Done: battery $bat_str was completely discharged."
+    echo_debug "bat" "discharge_battery.complete($bat_str)"
+    return 0
+}
+
+# --- Drive Bay
+
+get_drivebay_device () { # Find generic dock interface for drive bay
+                         # rc: 0; retval: $dock
+	dock=$(grep -l ata_bay $DOCKGLOB/type 2> /dev/null)
+	dock=${dock%%/type}
+	if [ ! -d "$dock" ]; then
+		dock=""
+	fi
+
+    return 0
+}
+
+check_is_docked() { # check if $dock is docked;
+                    # rc: 0 if docked, else 1
+
+   local dock_status dock_info_file
+
+   # return 0 if any sysfs file indicates "docked"
+   for dock_info_file in docked firmware_node/status; do
+        if [ -f $dock/$dock_info_file ] && \
+            read -r dock_status < $dock/$dock_info_file 2>/dev/null; then
+            # catch empty $dock_status (safety check, unlikely case)
+            [ "${dock_status:-0}" != "0" ] && return 0
+        fi
+   done
+
+   # otherwise assume "not docked"
+   return 1
+}
+
+suspend_drivebay () { # Save power state of drive bay before suspend
+                      # $1: 0=ac mode, 1=battery mode
+
+    if [ "$1" = "1" ] && [ "$BAY_POWEROFF_ON_BAT" = "1" ]; then
+        # bat power and setting is active -> save state
+        get_drivebay_device
+
+        if [ -n "$dock" ]; then
+            mkdir -p $STATEDIR 2> /dev/null 1>&2
+
+            if ! check_is_docked; then
+                echo "off" > $BAYSTATEFILE
+                echo_debug "pm" "suspend_drivebay: bay=off"
+            else
+                echo "on" > $BAYSTATEFILE
+                echo_debug "pm" "suspend_drivebay: bay=on"
+            fi
+        fi
+    else
+        # not on bat or setting not active -> remove state file
+        rm -f $BAYSTATEFILE 2> /dev/null
+    fi
+
+    return 0
+}
+
+resume_drivebay () { # Restore power state of drive bay after resume
+
+	local cnt rc
+
+	[ -f $BAYSTATEFILE ] || return 0 # no state file -> do nothing
+
+    if [ "$(cat $BAYSTATEFILE)" = "off" ]; then
+        get_drivebay_device
+
+        if [ -n "$dock" ]; then
+            if check_is_docked; then
+                # device active -> deactivate
+                if [ -e $dock/undock ]; then
+                    cnt=5
+                    rc=1
+                    until [ $rc = 0 -o $cnt = 0 ]; do
+                        cnt=$((cnt - 1))
+                        echo 1 > $dock/undock
+                        rc=$?
+                        [ $rc = 0 ] || sleep 0.5
+                    done
+                    echo_debug "pm" "resume_drivebay.bay_off: rc=$rc"
+                fi
+            else
+                echo_debug "pm" "resume_drivebay.already_off"
+            fi
+        fi
+    fi
+
+    rm -f $BAYSTATEFILE 2> /dev/null
+
+    return 0
+}
+
+poweroff_drivebay () { # power off optical drive in drive bay
+    # $1: 0=conditional+quiet mode, 1=force+verbose mode
+    # Some code adapted from http://www.thinkwiki.org/wiki/How_to_hotswap_UltraBay_devices
+
+    local optdrv syspath
+
+    # Run only if either explicitly enabled or forced
+    [ "$BAY_POWEROFF_ON_BAT" = "1" ] || [ "$1" = "1" ] || return 0
+
+    get_drivebay_device
+    if [ -z "$dock" ] || [ ! -d "$dock" ]; then
+        echo_debug "pm" "poweroff_drivebay.no_bay_device"
+        [ "$1" = "1" ] && echo "Error: cannot locate bay device." 1>&2
+        return 1
+    fi
+    echo_debug "pm" "poweroff_drivebay: dock=$dock"
+
+    # Check if bay is occupied
+    if ! check_is_docked; then
+        echo_debug "pm" "poweroff_drivebay.drive_already_off"
+        [ "$1" = "1" ] && echo "No drive in bay (or power already off)."
+    else
+        # Check for optical drive
+        optdrv=/dev/${BAY_DEVICE:=sr0}
+        if [ ! -b "$optdrv" ]; then
+            echo_debug "pm" "poweroff_drivebay.no_opt_drive: $optdrv"
+            [ "$1" = "1" ] && echo "No optical drive in bay ($optdrv)."
+            return 0
+        else
+            echo_debug "pm" "poweroff_drivebay: optdrv=$optdrv"
+
+            echo -n "Powering off drive bay..."
+
+            # Unmount media
+            umount -l $optdrv > /dev/null 2>&1
+
+            # Sync drive
+            sync
+            sleep 1
+
+            # Power off drive
+            $HDPARM -Y $optdrv > /dev/null 2>&1
+            sleep 5
+
+            # Unregister scsi device
+            if syspath="$($UDEVADM info --query=path --name=$optdrv)"; then
+                syspath="/sys${syspath%/block/*}"
+
+                if [ "$syspath" != "/sys" ]; then
+                    echo_debug "pm" "poweroff_drivebay: syspath=$syspath"
+                    echo 1 > $syspath/delete
+                else
+                    echo_debug "pm" "poweroff_drivebay: got empty/invalid syspath for $optdrv"
+                fi
+            else
+                echo_debug "pm" "poweroff_drivebay: failed to get syspath (udevadm returned $?)"
+            fi
+
+            # Turn power off
+            echo 1 > $dock/undock
+            [ "$1" = "1" ] && echo "done."
+            echo_debug "pm" "poweroff_drivebay.bay_powered_off"
+        fi
+    fi
+
+    return 0
+}
diff --git a/tlp-nop b/tlp-nop
deleted file mode 100755
index cf733b3..0000000
--- a/tlp-nop
+++ /dev/null
@@ -1,26 +0,0 @@
-#!/bin/sh
-# tlp - if tlp is enabled, override corresponding script
-#       in /usr/lib*/pm-utils/power.d/
-
-CONFFILE=/etc/default/tlp
-LIBDIRS='/usr/lib /usr/lib64'
-
-for d in ${LIBDIRS}; do
-    if [ -d "${d}/pm-utils/power.d" ]; then
-        blocked="${d}/pm-utils/power.d/${0##*/}"
-        break
-    fi
-done
-
-if [ -n "$blocked" ] && [ -x "$blocked" ]; then
-    # else nothing to disable -> don't read $CONFFILE
-
-    if [ -e "$CONFFILE" ] && . "$CONFFILE" && [ "$TLP_ENABLE" = '1' ]; then
-        # TLP is enabled -> disable $blocked
-        echo "Notice: '${blocked}' disabled by TLP."
-    else
-        exec "$blocked" $*
-    fi
-fi
-
-exit 0
diff --git a/tlp-nop.in b/tlp-nop.in
new file mode 100755
index 0000000..1c19d0b
--- /dev/null
+++ b/tlp-nop.in
@@ -0,0 +1,26 @@
+#!/bin/sh
+# tlp - if tlp is enabled, override corresponding script
+#       in /usr/lib*/pm-utils/power.d/
+
+CONFFILE=@TLP_CONF@
+LIBDIRS='/usr/lib /usr/lib64'
+
+for d in ${LIBDIRS}; do
+    if [ -d "${d}/pm-utils/power.d" ]; then
+        blocked="${d}/pm-utils/power.d/${0##*/}"
+        break
+    fi
+done
+
+if [ -n "$blocked" ] && [ -x "$blocked" ]; then
+    # else nothing to disable -> don't read $CONFFILE
+
+    if [ -e "$CONFFILE" ] && . "$CONFFILE" && [ "$TLP_ENABLE" = '1' ]; then
+        # TLP is enabled -> disable $blocked
+        echo "Notice: '${blocked}' disabled by TLP."
+    else
+        exec "$blocked" $*
+    fi
+fi
+
+exit 0
diff --git a/tlp-rdw-nm b/tlp-rdw-nm
deleted file mode 100755
index b183ef3..0000000
--- a/tlp-rdw-nm
+++ /dev/null
@@ -1,119 +0,0 @@
-#!/bin/sh
-# tlp-rdw - network manager dispatcher hook:
-#           enable/disable radios on ifup/ifdown
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-readonly RDW_NM_LOCK="rdw_nm"
-readonly RDW_NM_LOCKTIME=2
-
-# --- Locate and source libraries
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-[ -d $libdir ] || exit 0
-
-for lib in $LIBS; do
-    [ -f $libdir/$lib ] || exit 0
-    . $libdir/$lib
-done
-
-# --- MAIN
-read_defaults
-check_tlp_enabled || exit 0
-add_sbin2path
-
-# Get args
-iface="$1"
-action="$2"
-itype="unknown"
-
-# Quit for invalid interfaces
-[ -n "$iface" ] && [ "$iface" != "none" ] || exit 0
-
-echo_debug "nm" "rdw_nm($iface).$action"
-if [ -n "$addpath" ]; then
-    echo_debug "path" "PATH=$oldpath[$addpath]"
-else
-    echo_debug "path" "PATH=$oldpath"
-fi
-
-# Quit if timed lock in progress
-check_timed_lock $RDW_NM_LOCK && exit 0
-
-# Determine interface type
-if cmd_exists $NMCLI ; then
-    # nmcli is available --> check if nmcli dev output matches interface
-    itype="$($NMCLI dev | awk '$1 ~ /'$iface'/ { print $2; }')"
-
-    if [ -z "$itype" ]; then
-        # iface is not found in nmcli dev output: many WWAN devices have
-        # different devices for control and the actual network connection
-        # --> check if interface matches a WWAN device
-        get_wwan_ifaces
-        if wordinlist "$iface" "$wanifaces"; then
-            itype="wwan"
-        else
-            itype="unknown"
-        fi
-    fi
-    echo_debug "nm" "rdw_nm($iface).$action: type=$itype [nmcli]"
-else
-    # nmcli is not available
-    echo_debug "nm" "rdw_nm($iface)$action.nmcli_not_available"
-fi
-
-case $action in
-    up) # interface up, disable configured interfaces
-
-        set_timed_lock $RDW_NM_LOCK $RDW_NM_LOCKTIME # lock rdw events
-
-        case $itype in
-            *ethernet)
-                for dev in $DEVICES_TO_DISABLE_ON_LAN_CONNECT; do
-                    [ -n "$dev" ] && device_switch $dev off
-                done
-                ;;
-
-            *wireless|wifi)
-                for dev in $DEVICES_TO_DISABLE_ON_WIFI_CONNECT; do
-                    [ -n "$dev" ] && [ "$dev" != wifi ] && device_switch $dev off
-                done
-                ;;
-
-            gsm|wwan)
-                for dev in $DEVICES_TO_DISABLE_ON_WWAN_CONNECT; do
-                    [ -n "$dev" ] && [ "$dev" != wwan ] && device_switch $dev off
-                done
-                ;;
-        esac
-        ;; # up
-
-    down) # interface down, enable configured interfaces
-        case $itype in
-            *ethernet)
-                for dev in $DEVICES_TO_ENABLE_ON_LAN_DISCONNECT; do
-                    [ -n "$dev" ] && device_switch $dev on
-                done
-                ;;
-
-            *wireless|wifi)
-                for dev in $DEVICES_TO_ENABLE_ON_WIFI_DISCONNECT; do
-                    [ -n "$dev" ] && [ "$dev" != wifi ] && device_switch $dev on
-                done
-                ;;
-
-            gsm)
-                for dev in $DEVICES_TO_ENABLE_ON_WWAN_DISCONNECT; do
-                    [ -n "$dev" ] && [ "$dev" != wwan ] && device_switch $dev on
-                done
-                ;;
-        esac
-        ;; # down
-
-esac
-
-exit 0
diff --git a/tlp-rdw-nm.in b/tlp-rdw-nm.in
new file mode 100755
index 0000000..e018dc3
--- /dev/null
+++ b/tlp-rdw-nm.in
@@ -0,0 +1,119 @@
+#!/bin/sh
+# tlp-rdw - network manager dispatcher hook:
+#           enable/disable radios on ifup/ifdown
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+readonly RDW_NM_LOCK="rdw_nm"
+readonly RDW_NM_LOCKTIME=2
+
+# --- Locate and source libraries
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+[ -d $libdir ] || exit 0
+
+for lib in $LIBS; do
+    [ -f $libdir/$lib ] || exit 0
+    . $libdir/$lib
+done
+
+# --- MAIN
+read_defaults
+check_tlp_enabled || exit 0
+add_sbin2path
+
+# Get args
+iface="$1"
+action="$2"
+itype="unknown"
+
+# Quit for invalid interfaces
+[ -n "$iface" ] && [ "$iface" != "none" ] || exit 0
+
+echo_debug "nm" "rdw_nm($iface).$action"
+if [ -n "$addpath" ]; then
+    echo_debug "path" "PATH=$oldpath[$addpath]"
+else
+    echo_debug "path" "PATH=$oldpath"
+fi
+
+# Quit if timed lock in progress
+check_timed_lock $RDW_NM_LOCK && exit 0
+
+# Determine interface type
+if cmd_exists $NMCLI ; then
+    # nmcli is available --> check if nmcli dev output matches interface
+    itype="$($NMCLI dev | awk '$1 ~ /'$iface'/ { print $2; }')"
+
+    if [ -z "$itype" ]; then
+        # iface is not found in nmcli dev output: many WWAN devices have
+        # different devices for control and the actual network connection
+        # --> check if interface matches a WWAN device
+        get_wwan_ifaces
+        if wordinlist "$iface" "$wanifaces"; then
+            itype="wwan"
+        else
+            itype="unknown"
+        fi
+    fi
+    echo_debug "nm" "rdw_nm($iface).$action: type=$itype [nmcli]"
+else
+    # nmcli is not available
+    echo_debug "nm" "rdw_nm($iface)$action.nmcli_not_available"
+fi
+
+case $action in
+    up) # interface up, disable configured interfaces
+
+        set_timed_lock $RDW_NM_LOCK $RDW_NM_LOCKTIME # lock rdw events
+
+        case $itype in
+            *ethernet)
+                for dev in $DEVICES_TO_DISABLE_ON_LAN_CONNECT; do
+                    [ -n "$dev" ] && device_switch $dev off
+                done
+                ;;
+
+            *wireless|wifi)
+                for dev in $DEVICES_TO_DISABLE_ON_WIFI_CONNECT; do
+                    [ -n "$dev" ] && [ "$dev" != wifi ] && device_switch $dev off
+                done
+                ;;
+
+            gsm|wwan)
+                for dev in $DEVICES_TO_DISABLE_ON_WWAN_CONNECT; do
+                    [ -n "$dev" ] && [ "$dev" != wwan ] && device_switch $dev off
+                done
+                ;;
+        esac
+        ;; # up
+
+    down) # interface down, enable configured interfaces
+        case $itype in
+            *ethernet)
+                for dev in $DEVICES_TO_ENABLE_ON_LAN_DISCONNECT; do
+                    [ -n "$dev" ] && device_switch $dev on
+                done
+                ;;
+
+            *wireless|wifi)
+                for dev in $DEVICES_TO_ENABLE_ON_WIFI_DISCONNECT; do
+                    [ -n "$dev" ] && [ "$dev" != wifi ] && device_switch $dev on
+                done
+                ;;
+
+            gsm)
+                for dev in $DEVICES_TO_ENABLE_ON_WWAN_DISCONNECT; do
+                    [ -n "$dev" ] && [ "$dev" != wwan ] && device_switch $dev on
+                done
+                ;;
+        esac
+        ;; # down
+
+esac
+
+exit 0
diff --git a/tlp-rdw-udev b/tlp-rdw-udev
deleted file mode 100755
index 7fa7db6..0000000
--- a/tlp-rdw-udev
+++ /dev/null
@@ -1,101 +0,0 @@
-#!/bin/sh
-# tlp-rdw - handle dock/undock events
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-readonly RDW_DOCK_LOCK="rdw_dock_lock"
-readonly RDW_DOCK_LOCKTIME=2
-
-# --- Locate and source libraries
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-[ -d $libdir ] || exit 0
-
-for lib in $LIBS; do
-    [ -f $libdir/$lib ] || exit 0
-    . $libdir/$lib
-done
-
-# --- MAIN
-read_defaults
-check_tlp_enabled || exit 0
-add_sbin2path
-
-# get power state
-get_power_state; onbat=$?
-
-# get device/type
-ddev=/sys$1
-devtype=$2
-
-case $devtype in
-    dock)
-        # check if type is "dock_station", exit if not
-        type=$(cat $ddev/type)
-        [ "$type" = "dock_station" ] || exit 0
-
-        docked=$(cat $ddev/docked)
-        action=$EVENT
-
-        echo_debug "udev" "rdw_udev($devtype).$action dev=$ddev type=$type docked=$docked onbat=$onbat"
-        ;;
-
-    usb_dock)
-        case $ACTION in
-            add)    action="dock"  ;;
-            remove) action="undock"  ;;
-        esac
-
-        echo_debug "udev" "rdw_udev($devtype).$action dev=$ddev onbat=$onbat"
-        ;;
-
-    *) exit 0 ;; # unknown device type
-esac
-
-# quit if timed lock in progress
-if check_timed_lock $RDW_DOCK_LOCK ; then
-    echo_debug "udev" "rdw_udev.locked"
-    exit 0
-fi
-
-case $action in
-    dock) # laptop was docked
-
-        # lock for 2 seconds in case dock has multiple devices
-        set_timed_lock $RDW_DOCK_LOCK $RDW_DOCK_LOCKTIME
-
-        # enable configured radios
-        for dev in $DEVICES_TO_ENABLE_ON_DOCK; do
-            [ -n "$dev" ] && device_switch $dev on
-        done
-
-        # disable configured radios
-        for dev in $DEVICES_TO_DISABLE_ON_DOCK; do
-            [ -n "$dev" ] && device_switch $dev off
-        done
-        ;;
-
-    undock) # laptop was undocked
-
-        # lock for 2 seconds in case dock has multiple devices
-        set_timed_lock $RDW_DOCK_LOCK $RDW_DOCK_LOCKTIME
-
-        # enable configured radios
-        for dev in $DEVICES_TO_ENABLE_ON_UNDOCK; do
-            [ -n "$dev" ] && device_switch $dev on
-        done
-
-        # disable configured radios
-        for dev in $DEVICES_TO_DISABLE_ON_UNDOCK; do
-            [ -n "$dev" ] && device_switch $dev off
-        done
-        ;;
-
-    *) ;; # unknown action -> do nothing
-esac
-
-exit 0
diff --git a/tlp-rdw-udev.in b/tlp-rdw-udev.in
new file mode 100755
index 0000000..fc17a78
--- /dev/null
+++ b/tlp-rdw-udev.in
@@ -0,0 +1,101 @@
+#!/bin/sh
+# tlp-rdw - handle dock/undock events
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+readonly RDW_DOCK_LOCK="rdw_dock_lock"
+readonly RDW_DOCK_LOCKTIME=2
+
+# --- Locate and source libraries
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+[ -d $libdir ] || exit 0
+
+for lib in $LIBS; do
+    [ -f $libdir/$lib ] || exit 0
+    . $libdir/$lib
+done
+
+# --- MAIN
+read_defaults
+check_tlp_enabled || exit 0
+add_sbin2path
+
+# get power state
+get_power_state; onbat=$?
+
+# get device/type
+ddev=/sys$1
+devtype=$2
+
+case $devtype in
+    dock)
+        # check if type is "dock_station", exit if not
+        type=$(cat $ddev/type)
+        [ "$type" = "dock_station" ] || exit 0
+
+        docked=$(cat $ddev/docked)
+        action=$EVENT
+
+        echo_debug "udev" "rdw_udev($devtype).$action dev=$ddev type=$type docked=$docked onbat=$onbat"
+        ;;
+
+    usb_dock)
+        case $ACTION in
+            add)    action="dock"  ;;
+            remove) action="undock"  ;;
+        esac
+
+        echo_debug "udev" "rdw_udev($devtype).$action dev=$ddev onbat=$onbat"
+        ;;
+
+    *) exit 0 ;; # unknown device type
+esac
+
+# quit if timed lock in progress
+if check_timed_lock $RDW_DOCK_LOCK ; then
+    echo_debug "udev" "rdw_udev.locked"
+    exit 0
+fi
+
+case $action in
+    dock) # laptop was docked
+
+        # lock for 2 seconds in case dock has multiple devices
+        set_timed_lock $RDW_DOCK_LOCK $RDW_DOCK_LOCKTIME
+
+        # enable configured radios
+        for dev in $DEVICES_TO_ENABLE_ON_DOCK; do
+            [ -n "$dev" ] && device_switch $dev on
+        done
+
+        # disable configured radios
+        for dev in $DEVICES_TO_DISABLE_ON_DOCK; do
+            [ -n "$dev" ] && device_switch $dev off
+        done
+        ;;
+
+    undock) # laptop was undocked
+
+        # lock for 2 seconds in case dock has multiple devices
+        set_timed_lock $RDW_DOCK_LOCK $RDW_DOCK_LOCKTIME
+
+        # enable configured radios
+        for dev in $DEVICES_TO_ENABLE_ON_UNDOCK; do
+            [ -n "$dev" ] && device_switch $dev on
+        done
+
+        # disable configured radios
+        for dev in $DEVICES_TO_DISABLE_ON_UNDOCK; do
+            [ -n "$dev" ] && device_switch $dev off
+        done
+        ;;
+
+    *) ;; # unknown action -> do nothing
+esac
+
+exit 0
diff --git a/tlp-rdw.rules b/tlp-rdw.rules
deleted file mode 100644
index b7ba50c..0000000
--- a/tlp-rdw.rules
+++ /dev/null
@@ -1,27 +0,0 @@
-# tlp-rdw - udev rules
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Dock/undock events
-
-# ThinkPad Advanced Mini Dock (and all older models), ThinkPad UltraBase
-ACTION=="change", SUBSYSTEM=="platform", KERNEL=="dock.*", RUN+="/lib/udev/tlp-rdw-udev %p dock"
-
-# ThinkPad Mini Dock (Plus) Series 3
-ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/100a/*", RUN+="/lib/udev/tlp-rdw-udev %p usb_dock"
-
-# ThinkPad Ultra Dock
-ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/1010/*", RUN+="/lib/udev/tlp-rdw-udev %p usb_dock"
-
-# ThinkPad Pro Dock
-ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/1012/*", RUN+="/lib/udev/tlp-rdw-udev %p usb_dock"
-
-# ThinkPad Basic Dock
-# *** TODO: yet unknown ***
-
-# ThinkPad OneLink Dock Pro
-ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/304b/*", RUN+="/lib/udev/tlp-rdw-udev %p usb_dock"
-
-# ThinkPad OneLink Dock Basic
-ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/3049/*", RUN+="/lib/udev/tlp-rdw-udev %p usb_dock"
diff --git a/tlp-rdw.rules.in b/tlp-rdw.rules.in
new file mode 100644
index 0000000..4d5f322
--- /dev/null
+++ b/tlp-rdw.rules.in
@@ -0,0 +1,27 @@
+# tlp-rdw - udev rules
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Dock/undock events
+
+# ThinkPad Advanced Mini Dock (and all older models), ThinkPad UltraBase
+ACTION=="change", SUBSYSTEM=="platform", KERNEL=="dock.*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p dock"
+
+# ThinkPad Mini Dock (Plus) Series 3
+ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/100a/*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p usb_dock"
+
+# ThinkPad Ultra Dock
+ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/1010/*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p usb_dock"
+
+# ThinkPad Pro Dock
+ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/1012/*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p usb_dock"
+
+# ThinkPad Basic Dock
+# *** TODO: yet unknown ***
+
+# ThinkPad OneLink Dock Pro
+ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/304b/*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p usb_dock"
+
+# ThinkPad OneLink Dock Basic
+ACTION=="add|remove", SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{PRODUCT}=="17ef/3049/*", RUN+="@TLP_ULIB@/tlp-rdw-udev %p usb_dock"
diff --git a/tlp-rf b/tlp-rf
deleted file mode 100755
index 0d859d7..0000000
--- a/tlp-rf
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/bin/sh
-# tlp - switch bluetooth/wifi/wwan on/off
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-# --- Locate and source libraries
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-[ -d $libdir ] || exit 0
-
-for lib in $LIBS; do
-    [ -f $libdir/$lib ] || exit 0
-    . $libdir/$lib
-done
-
-# --- MAIN
-read_defaults
-add_sbin2path
-self=${0##*/}
-
-case $self in
-    bluetooth|wifi|wwan)
-        case $1 in
-            on)
-                device_switch $self on
-                echo_device_state $self $devs
-                ;;
-
-            off)
-                device_switch $self off
-                echo_device_state $self $devs
-                ;;
-
-            toggle)
-                device_switch $self toggle
-                echo_device_state $self $devs
-                ;;
-
-            *)
-                device_state $self
-                echo_device_state $self $devs
-                ;;
-        esac
-        ;;
-
-    *)
-        echo "Error: unknown device type \"$self\"." 1>&2
-        exit 1
-        ;;
-esac
-
-exit 0
diff --git a/tlp-rf.in b/tlp-rf.in
new file mode 100755
index 0000000..91a651c
--- /dev/null
+++ b/tlp-rf.in
@@ -0,0 +1,56 @@
+#!/bin/sh
+# tlp - switch bluetooth/wifi/wwan on/off
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+# --- Locate and source libraries
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+[ -d $libdir ] || exit 0
+
+for lib in $LIBS; do
+    [ -f $libdir/$lib ] || exit 0
+    . $libdir/$lib
+done
+
+# --- MAIN
+read_defaults
+add_sbin2path
+self=${0##*/}
+
+case $self in
+    bluetooth|wifi|wwan)
+        case $1 in
+            on)
+                device_switch $self on
+                echo_device_state $self $devs
+                ;;
+
+            off)
+                device_switch $self off
+                echo_device_state $self $devs
+                ;;
+
+            toggle)
+                device_switch $self toggle
+                echo_device_state $self $devs
+                ;;
+
+            *)
+                device_state $self
+                echo_device_state $self $devs
+                ;;
+        esac
+        ;;
+
+    *)
+        echo "Error: unknown device type \"$self\"." 1>&2
+        exit 1
+        ;;
+esac
+
+exit 0
diff --git a/tlp-run-on b/tlp-run-on
deleted file mode 100755
index 910f36c..0000000
--- a/tlp-run-on
+++ /dev/null
@@ -1,57 +0,0 @@
-#!/bin/sh
-# tlp - run commands depending on power source
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions"
-
-# --- Locate and source libraries
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-if [ ! -d $libdir ]; then
-    echo "Error: missing library directory ($LIBDIRS)." 1>&2
-    exit 1
-fi
-
-for lib in $LIBS; do
-    if [ ! -f $libdir/$lib ]; then
-        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
-        exit 1
-    fi
-    . $libdir/$lib
-done
-
-# --- MAIN
-self=${0##*/}
-
-cmd=$1
-if [ -z "$cmd" ]; then
-    echo "Usage: $self command [arg(s)]" 1>&2
-    exit 1
-fi
-if ! cmd_exists $cmd; then
-    echo "Error: \"$cmd\" not found." 1>&2
-    exit 2
-fi
-shift
-
-case $self in
-    run-on-ac)
-        if get_power_state; then
-            $cmd $@
-        fi
-        ;;
-
-    run-on-bat)
-        if ! get_power_state; then
-            $cmd $@
-        fi
-        ;;
-
-    *)
-        echo "Error: unknown mode $self." 1>&2
-        exit 1
-        ;;
-esac
diff --git a/tlp-run-on.in b/tlp-run-on.in
new file mode 100755
index 0000000..182fffa
--- /dev/null
+++ b/tlp-run-on.in
@@ -0,0 +1,57 @@
+#!/bin/sh
+# tlp - run commands depending on power source
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions"
+
+# --- Locate and source libraries
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+if [ ! -d $libdir ]; then
+    echo "Error: missing library directory ($LIBDIRS)." 1>&2
+    exit 1
+fi
+
+for lib in $LIBS; do
+    if [ ! -f $libdir/$lib ]; then
+        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
+        exit 1
+    fi
+    . $libdir/$lib
+done
+
+# --- MAIN
+self=${0##*/}
+
+cmd=$1
+if [ -z "$cmd" ]; then
+    echo "Usage: $self command [arg(s)]" 1>&2
+    exit 1
+fi
+if ! cmd_exists $cmd; then
+    echo "Error: \"$cmd\" not found." 1>&2
+    exit 2
+fi
+shift
+
+case $self in
+    run-on-ac)
+        if get_power_state; then
+            $cmd $@
+        fi
+        ;;
+
+    run-on-bat)
+        if ! get_power_state; then
+            $cmd $@
+        fi
+        ;;
+
+    *)
+        echo "Error: unknown mode $self." 1>&2
+        exit 1
+        ;;
+esac
diff --git a/tlp-sleep.service b/tlp-sleep.service
deleted file mode 100644
index b0e27c7..0000000
--- a/tlp-sleep.service
+++ /dev/null
@@ -1,18 +0,0 @@
-# tlp - systemd suspend/resume service
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-[Unit]
-Description=TLP suspend/resume
-Before=sleep.target
-StopWhenUnneeded=yes
-
-[Service]
-Type=oneshot
-RemainAfterExit=yes
-ExecStart=/usr/sbin/tlp suspend
-ExecStop=/usr/sbin/tlp resume
-
-[Install]
-WantedBy=sleep.target
diff --git a/tlp-sleep.service.in b/tlp-sleep.service.in
new file mode 100644
index 0000000..fff9de9
--- /dev/null
+++ b/tlp-sleep.service.in
@@ -0,0 +1,18 @@
+# tlp - systemd suspend/resume service
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+[Unit]
+Description=TLP suspend/resume
+Before=sleep.target
+StopWhenUnneeded=yes
+
+[Service]
+Type=oneshot
+RemainAfterExit=yes
+ExecStart=@TLP_SBIN@/tlp suspend
+ExecStop=@TLP_SBIN@/tlp resume
+
+[Install]
+WantedBy=sleep.target
diff --git a/tlp-stat b/tlp-stat
deleted file mode 100755
index 0905a70..0000000
--- a/tlp-stat
+++ /dev/null
@@ -1,1194 +0,0 @@
-#!/bin/sh
-# tlp - display power save and usb autosuspend status
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# --- Constants
-
-readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm"
-readonly LIBS="tlp-functions tlp-rf-func"
-
-readonly TLPUSB=tlp-usblist
-readonly TLPPCI=tlp-pcilist
-
-readonly SMARTCTL=smartctl
-readonly LSBREL=lsb_release
-
-readonly ASPM=/sys/module/pcie_aspm/parameters/policy
-readonly NMIWD=/proc/sys/kernel/nmi_watchdog
-
-readonly IBMTHERMAL=/proc/acpi/ibm/thermal
-readonly CORETEMP_DIRS="
-/sys/devices/platform/coretemp.0
-/sys/devices/platform/coretemp.0/hwmon/hwmon*"
-readonly IBMFAN=/proc/acpi/ibm/fan
-readonly HWMONFAN_DIRS="
-/sys/class/hwmon/hwmon*/device
-/sys/class/hwmon/hwmon*"
-
-readonly JOURNALCTL=journalctl
-readonly DEBUGLOG=/var/log/debug
-
-readonly SYSTEMD_SERVICES="tlp.service tlp-sleep.service"
-
-# --- Variables
-needs_root_priv=
-show_all=1
-show_bat=0
-show_conf=0
-show_disk=0
-show_pcie=0
-show_proc=0
-show_rfkill=0
-show_system=0
-show_temp=0
-show_trace=0
-show_usb=0
-show_verbose=0
-show_warn=0
-
-no_runtimepm=0
-
-# --- Functions
-
-printparm () { # formatted output of sysfile - general
-    # $1: format, $2: sysfile, $3: namsg, $4: cutoff
-    local format="$1"
-    local sysf="$2"
-    local namsg="$3"
-    local cutoff="$4"
-    local val=""
-
-    if [ -f $sysf ]; then
-        # sysfile exists
-        val=$(cat $sysf 2> /dev/null)
-        if [ $? = 0 ]; then
-            # sysfile read successful
-            if [ -n "$cutoff" ]; then
-                val=${val%$cutoff}
-            fi
-        fi
-    fi
-
-    if [ -z "$val" ]; then
-        # replace empty value with n/a text
-        if [ -n "$namsg" ]; then
-            format=$( echo $format | sed -r "s/##(.*)##/($namsg)/" | sed -r "s/\[.*\]//" )
-        else
-            format=$( echo $format | sed -r "s/##(.*)##/(not available)/" | sed -r "s/\[.*\]//" )
-        fi
-        printf "$format\n" "$sysf"
-    else
-        # non empty value: strip delimiters from format str
-        format=$( echo $format | sed -r "s/##(.*)##/\1/" )
-        printf "$format\n" "$sysf" "$val"
-    fi
-
-    return 0
-}
-
-printparm_i915 () { # formatted output of sysfile - i915 kernel module variant
-    # $1: sysfile, $2: alternative
-    local sysf val
-
-    # Check if sysfile or alternative exist
-    if [ -f $1 ]; then
-        sysf=$1
-    elif [ -f $2 ]; then
-        sysf=$2
-    else
-        sysf=""
-    fi
-
-    if [ -n "$sysf" ]; then
-        # sysfile exists, get content
-        val=$(cat $sysf 2> /dev/null)
-        if [ $? = 0 ]; then
-            # sysfile was readable, output content
-            printf "%-44s = %2d " $sysf $val
-            # Explain content
-            if [ "$val" = "-1" ]; then
-                echo "(use per-chip default)"
-            else
-                echo -n "("
-                if [ $(( $val & 1 )) -ne 0 ]; then
-                    echo -n "enabled"
-                else
-                    echo -n "disabled"
-                fi
-                [ $(( $val & 2 )) -ne 0 ] && echo -n " + deep"
-                [ $(( $val & 4 )) -ne 0 ] && echo -n " + deepest"
-                echo ")"
-            fi
-        else
-            # sysfile was not readable
-            printf "%-44s = (not available)\n" $sysf
-        fi
-    else
-        # Neither sysfile nor alternative exists
-        printf "%-44s = (not available)\n" $1
-    fi
-
-    return 0
-}
-
-print_tp_batstate () { # print battery charging state with an explanation when
-    # a threshold inhibits charging
-    # $1: sysfile; $2: 1=ThinkPad battery/0=other
-    local sysf val
-
-    # Check if bat state sysfile exists
-    if [ -f $1 ]; then
-        sysf=$1
-    else
-        sysf=""
-    fi
-
-    if [ -n "$sysf" ]; then
-        # bat state sysfile exists, get content
-        val=$(cat $sysf 2> /dev/null)
-        if [ $? = 0 ]; then
-            # sysfile was readable, output content
-            printf "%-59s = %s" $sysf $val
-            # Explain content if necessary
-            case $val in
-                Unknown) # "Unknown" means a threshold forbids charging
-                    printf " (threshold effective)\n"
-                    ;;
-
-                *) # Nothing to do
-                    printf "\n"
-                    ;;
-            esac
-        else
-            # sysfile was not readable
-            printf "%-59s = (not available)\n" $sysf
-        fi
-    else
-        # sysfile nonexistent
-        printf "%-59s = (not available)\n" $1
-    fi
-
-    return 0
-}
-
-print_tpacpi_thresholds () { # formatted output of ThinkPad charging thresholds
-    # - tpcapi-bat variant
-    # $1: BAT0/BAT1; $2: bat # = 1/2
-    local start_thresh stop_thresh force
-
-    read_tpacpi_threshold ST $2
-    start_thresh=$?
-    if [ $start_thresh -ne 255 ]; then
-        [ $start_thresh -eq 0 ] && start_thresh=96
-        printf "%-59s = %6d [%%]\n" "tpacpi-bat.${1}.startThreshold" $start_thresh
-    else
-        printf "%-59s = (not available)\n" "tpacpi-bat.${1}.startThreshold"
-    fi
-
-    read_tpacpi_threshold SP $2
-    stop_thresh=$?
-    if [ $stop_thresh -ne 255 ]; then
-        [ $stop_thresh -eq  0 ] && stop_thresh=100
-        printf "%-59s = %6d [%%]\n" "tpacpi-bat.${1}.stopThreshold" $stop_thresh
-    else
-        printf "%-59s = (not available)\n" "tpacpi-bat.${1}.stopThreshold"
-    fi
-
-    get_force_discharge $2; force=$?
-    if [ $force -ne 2 ]; then
-        printf "%-59s = %6d\n" "tpacpi-bat.${1}.forceDischarge" "$force"
-    else
-        printf "%-59s = %s\n" "tpacpi-bat.${1}.forceDischarge" "(not available)"
-    fi
-
-    return 0
-}
-
-check_ata_errors () { # check kernel log for ata errors
-    # (possibly) caused by SATA_LINKPWR_ON_AC/BAT != max_performance
-    # stdout: error count
-
-    if wordinlist $SATA_LINKPWR_ON_BAT "min_power medium_power" || \
-       wordinlist $SATA_LINKPWR_ON_AC "min_power medium_power"; then
-        # config values != max_performance exist --> check kernel log
-
-        # count matching error lines
-        echo $( dmesg | egrep -c "ata[0-9]+: SError: {.*CommWake.*}" 2> /dev/null )
-    else
-        # no values in question configured 
-        echo "0"
-    fi
-
-    return 0
-}
-
-# @stdout glob_files ( glob_pattern, dir[, dir...] )
-#
-#  Nested for-loop that applies a glob expression to several directories
-#  (or file path prefixes) and prints matching file paths to stdout.
-#
-glob_files () {
-    [ -n "${1-}" ] || return 64
-    local glob_pattern file_iter
-
-    glob_pattern="${1}"
-
-    while shift && [ $# -gt 0 ]; do
-        for file_iter in ${1}${glob_pattern}; do
-            [ ! -f "${file_iter}" ] || echo "${file_iter}"
-        done
-    done
-}
-
-read_args () { # read command line arguments
-    for a in $*; do
-        case $a in
-            "-b"|"--battery")
-                show_all=0
-                show_bat=1
-                needs_root_priv=1
-                ;;
-
-            "-c"|"--config")
-                show_all=0
-                show_conf=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-d"|"--disk")
-                show_all=0
-                show_disk=1
-                needs_root_priv=1
-                ;;
-
-            "-e"|"--pcie")
-                show_all=0
-                show_pcie=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-p"|"--processor")
-                show_all=0
-                show_proc=1
-                needs_root_priv=1
-                ;;
-
-            "-r"|"--rfkill")
-                show_all=0
-                show_rfkill=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-s"|"--system")
-                show_all=0
-                show_system=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-t"|"--temp")
-                show_all=0
-                show_temp=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-u"|"--usb")
-                show_all=0
-                show_usb=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-v"|"--verbose")
-                show_verbose=1
-                ;;
-
-            "-w"|"--warn")
-                show_all=0
-                show_warn=1
-                : ${needs_root_priv:=0}
-                ;;
-
-            "-T"|"--trace")
-                show_all=0
-                show_trace=1
-                needs_root_priv=1
-                ;;
-
-            *)
-                echo "Usage: tlp-stat [ -b | --battery   | -c | --config |"
-                echo "                  -d | --disk      | -e | --pcie   |"
-                echo "                  -p | --processor | -r | --rfkill |"
-                echo "                  -s | --system    | -t | --temp   |"
-                echo "                  -u | --usb       | -w | --warn   |"
-                echo "                  -T | --trace     | -v | --verbose ]"
-                exit 3
-                ;;
-        esac
-    done
-}
-
-# --- Locate and source libraries
-
-for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
-if [ ! -d $libdir ]; then
-    echo "Error: missing library directory ($LIBDIRS)." 1>&2
-    exit 1
-fi
-
-for lib in $LIBS; do
-    if [ ! -f $libdir/$lib ]; then
-        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
-        exit 1
-    fi
-    . $libdir/$lib
-done
-
-# --- MAIN
-add_sbin2path
-
-read_args $*
-: ${needs_root_priv:=1}
-
-# inhibit trace output
-nodebug=1
-
-# check for and read conffile
-read_defaults
-conf_present=$?
-
-# check prereqisites
-if [ "$needs_root_priv" = "1" ]; then
-    check_root
-    load_modules
-    check_tpacpi
-    check_tpsmapi
-fi
-
-echo "--- TLP $TLPVER --------------------------------------------"
-echo
-
-# --- show configuration
-if [ "$show_conf" = "1" ] || [ "$show_all" = "1" ]; then
-    if [ $conf_present -eq 0 ]; then
-        echo "+++ Configured Settings: $CONFFILE"
-        egrep -v '^#|^\s*$' $CONFFILE
-        echo
-    else
-        echo "Warning: config file $CONFFILE not present." 1>&2
-        echo
-    fi
-fi # show_conf
-
-if [ "$show_system" = "1" ] || [ "$show_all" = "1" ] ; then
-    # --- show system info
-    echo "+++ System Info"
-
-    echo "System         = $( read_dmi sys_vendor product_version product_name )"
-    echo "BIOS           = $( read_dmi bios_version )"
-
-    # --- show release & kernel info
-    cmd_exists $LSBREL && echo "Release        = $($LSBREL -d -s)"
-    echo "Kernel         = $(uname -r -m -v)"
-    printparm "%-14s = %s" /proc/cmdline
-
-    # --- show init system info
-    if check_systemd; then
-        echo "Init system    = systemd"
-    elif check_upstart; then
-        echo "Init system    = upstart"
-    elif check_openrc; then
-        echo "Init system    = openrc"
-    else
-        echo "Init system    = sysvinit"
-    fi
-    echo
-
-    # --- show TLP status
-    echo "+++ System Status"
-    if [ "$TLP_ENABLE" = "1" ]; then
-        echo "TLP power save = enabled"
-    else
-        echo "TLP power save = not enabled"
-    fi
-
-    # -- check systemd service units status
-    if check_systemd; then
-        for su in $SYSTEMD_SERVICES; do
-            if ! $SYSTEMCTL is-enabled $su > /dev/null 2>&1 ; then
-                echo "***Warning: $su is not enabled -- invoke \"systemctl enable $su\" to correct this!"
-            fi
-        done
-    fi
-
-    # -- show warning if l-m-t detected
-    check_laptop_mode_tools
-
-    # --- show power source
-    get_sys_power_supply
-    case $? in
-        0) echo "power source   = AC" ;;
-        1) echo "power source   = battery" ;;
-        *) echo "power source   = unknown (using ${TLP_DEFAULT_MODE:-AC} settings)" ;;
-    esac
-    echo
-fi # show_system
-
-if [ "$show_proc" = "1" ] || [ "$show_all" = "1" ]; then
-    # --- show cpu info
-    echo "+++ Processor"
-    sed -rn 's/model name[ \t]+: (.+)/CPU Model      = \1/p' /proc/cpuinfo | head -1
-    echo
-
-    # -- show scaling gov and freq info
-    for cpuf in /sys/devices/system/cpu/cpu*/cpufreq; do
-        if [ -f $cpuf/scaling_driver ]; then
-            printparm "%-54s = ##%s##" $cpuf/scaling_driver
-            printparm "%-54s = ##%s##" $cpuf/scaling_governor
-
-            if [ -f $cpuf/scaling_min_freq ]; then
-                printf "%-54s = %8d [kHz]\n" $cpuf/scaling_min_freq $(cat $cpuf/scaling_min_freq)
-            fi
-
-            if [ -f $cpuf/scaling_max_freq ]; then
-                printf "%-54s = %8d [kHz]\n" $cpuf/scaling_max_freq $(cat $cpuf/scaling_max_freq)
-            fi
-
-            if [ -f $cpuf/scaling_available_frequencies ]; then
-                printf "%s = " $cpuf/scaling_available_frequencies
-                for freq in $(cat $cpuf/scaling_available_frequencies); do
-                    printf "%s " $freq
-                done
-                printf "[kHz]\n"
-            fi
-            printf "\n"
-        fi
-    done
-
-    check_intel_pstate
-
-    if [ $intel_pstate -eq 1 ]; then
-        # show Intel P-state info
-        printparm "%-54s = ##%d##" $CPU_MIN_PERF_PCT
-        printparm "%-54s = ##%d##" $CPU_MAX_PERF_PCT
-        printparm "%-54s = ##%d##" $CPU_TURBO_PSTATE
-
-    elif [ -f $CPU_BOOST_ALL_CTRL ]; then
-        # show turbo boost info
-        get_sysval $CPU_BOOST_ALL_CTRL; boost=$?
-
-        # simple test for attribute "w" doesn't work, so actually write
-        if ( echo "$boost" > $CPU_BOOST_ALL_CTRL ) 2> /dev/null; then
-            printparm "%-54s = ##%d##" $CPU_BOOST_ALL_CTRL
-        else
-            printparm "%-54s = ##%d## (cpu not supported)" $CPU_BOOST_ALL_CTRL
-        fi
-    else
-         printparm "%-54s = (not available)" $CPU_BOOST_ALL_CTRL
-    fi
-
-    # --- show sched power save info
-    for pool in mc smp smt; do
-        sdev="/sys/devices/system/cpu/sched_${pool}_power_savings"
-        [ -f $sdev ] && printparm "%-54s = ##%d##" $sdev
-    done
-    echo
-
-    # --- show x86 energy perf policy info
-    if cmd_exists $ENERGYPERF; then
-        # check CPU support
-        $ENERGYPERF -r > /dev/null 2>&1
-        case $? in
-            0)  # parse x86_energy_perf_policy output:
-                # - replace numbers with descriptive strings
-                # - remove ":"
-                # - indent and align
-                $ENERGYPERF -r 2>/dev/null | \
-                    sed 's/0x0000000000000000/performance/;
-                         s/0x0000000000000006/normal/;
-                         s/0x000000000000000f/powersave/;
-                         s/://' | \
-                    awk '{ printf "x86_energy_perf_policy.%-31s = %s\n", $1, $2; }'
-                ;;
-
-            1) echo "x86_energy_perf_policy: unsupported CPU." ;;
-            2) echo "x86_energy_perf_policy: program for your kernel not installed." ;;
-            *) echo "x86_energy_perf_policy: not available." ;;
-        esac
-        echo
-    else
-        echo "x86_energy_perf_policy: program not installed."
-        echo
-    fi
-
-    # --- show nmi watchdog
-    printparm "%-54s = ##%d##" $NMIWD
-    echo
-
-    # --- show voltages
-    echo "+++ Undervolting"
-    phc_avail=0
-    for cpuf in /sys/devices/system/cpu/cpu*/cpufreq; do
-        if [ -f $cpuf/phc_controls ]; then
-            phc_avail=1
-            printparm "%-58s = ##%s##" $cpuf/phc_controls
-            printparm "%-58s = ##%s##" $cpuf/phc_default_controls
-            echo
-        fi
-    done
-    if [ $phc_avail = 0 ]; then
-        echo "PHC kernel not available."
-        echo
-    fi
-fi # show_proc
-
-if [ "$show_temp" = "1" ] || [ "$show_all" = "1" ]; then
-    # --- show temperatures
-    echo "+++ Temperatures"
-    if [ -f $IBMTHERMAL ]; then
-        # use thinkpad-specific sysfile
-        echo "$IBMTHERMAL = $(cat $IBMTHERMAL | cut -f2) [C]"
-    else
-        # use sensors
-        cmax=0
-        for sens in $(glob_files '/temp?*_input' $CORETEMP_DIRS); do
-            if grep -q -- 'Physical' ${sens%input}label 2>/dev/null; then
-                # package info is available -> ignore remaining sensors
-                read -r cmax < $sens
-                break
-            else
-                # core info -> find max value
-                read -r ctemp < $sens && [ $ctemp -gt $cmax ] && cmax=$ctemp
-            fi
-        done
-        if [ $cmax -gt 0 ]; then
-            printf "CPU temp               = %5d [C]\n" $(( $cmax / 1000 ))
-        fi
-
-    fi
-
-    # --- show fan speed
-    if is_thinkpad && [ -f $IBMFAN ]; then
-        # use thinkpad-specific sysfile
-        awk '$1 ~ /speed:/ { printf "'$IBMFAN'     = %5d [/min]\n", $2 }' $IBMFAN
-    else
-        # use hwmon
-        have_any_fan=
-        for fan in $(glob_files '/fan?*_input' $HWMONFAN_DIRS); do
-            if read -r fan_speed < $fan; then
-                fan_name="${fan##*/}"; fan_name="${fan_name%_input}"
-                have_any_fan=y
-
-                printf "Fan speed (%s)       = %5d [/min]\n" \
-                    ${fan_name} ${fan_speed}
-            fi
-        done
-        if [ -z "${have_any_fan}" ]; then
-            printf "Fan speed              = (not available)\n"
-        fi
-    fi
-    echo
-fi # show_temp
-
-if [ "$show_all" = "1" ]; then
-    # --- show laptop-mode, dirty buffers params
-    echo "+++ File System"
-    printparm "%-38s = ##%5d##" /proc/sys/vm/laptop_mode
-    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_writeback_centisecs
-    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_expire_centisecs
-    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_ratio
-    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_background_ratio
-    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/age_buffer_centisecs
-    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/xfssyncd_centisecs
-    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/xfsbufd_centisecs
-    echo
-fi # show_all
-
-if [ "$show_disk" = "1" ] || [ "$show_all" = "1" ]; then
-    # --- show disk info form hdparm
-    echo "+++ Storage Devices"
-    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
-    for dev in $DISK_DEVICES; do # iterate all devices
-        get_disk_dev $dev
-
-        if [ -b /dev/$disk_dev ]; then
-            get_disk_state $disk_dev
-            check_disk_hdparm_cap $disk_dev
-            if [ $? = 0 ]; then
-                echo "/dev/$disk_dev:"
-
-                if [ -n "$disk_id" ]; then
-                    echo "          Disk ID   = $disk_id"
-                fi
-
-                echo -n "          Model     = "
-                echo_disk_model $disk_dev
-
-                echo -n "          Firmware  = "
-                echo_disk_firmware $disk_dev
-
-                get_disk_apm_level $disk_dev
-                apm=$?
-                echo -n "          APM Level = "
-                case $apm in
-                    0|255) echo "none/disabled" ;;
-                    *)     echo $apm ;;
-                esac
-
-                echo "          Status    = $disk_state"
-
-                get_disk_trim_capability $disk_dev
-                trim=$?
-                case $trim in
-                    0) echo "          TRIM      = not supported" ;;
-                    1) echo "          TRIM      = supported" ;;
-                esac
-
-                [ -f /sys/block/$disk_dev/queue/scheduler ] && \
-                    echo "          Scheduler = $(cat /sys/block/$disk_dev/queue/scheduler | sed -r 's/.*\[(.*)\].*/\1/')"
-
-                if cmd_exists $SMARTCTL ; then
-                    # --- show SMART data
-                    echo
-                    echo "        SMART info:"
-                    $SMARTCTL -A /dev/$disk_dev | grep -v '<==' | \
-                      awk -F ' ' '$2 ~ /Start_Stop_Count|Load_Cycle_Count|Reallocated_Sector_Ct|Used_Rsvd_Blk_Cnt_Chip|Used_Rsvd_Blk_Cnt_Tot/ \
-                                        { printf "          %3d %-25s = %8d \n", $1, $2, $10 } ; \
-                                  $2 ~ /Power_On_Hours/ \
-                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $10, "[h]" } ; \
-                                  $2 ~ /Temperature_Celsius/ \
-                                        { printf "          %3d %-25s = %8d %s %s %s %s\n", $1, $2, $10, $11, $12, $13, "[C]" } ; \
-                                  $2 ~ /Airflow_Temperature_Cel/ \
-                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $10, "[C]" } ; \
-                                  $2 ~ /Host_Writes/ \
-                                        { printf "          %3d %-25s = %8.3f %s\n", $1, $2, $10 / 32768.0, "[TB]" } ; \
-                                  $2 ~ /Total_LBAs_Written/ \
-                                        { printf "          %3d %-25s = %8.3f %s\n", $1, $2, $10 / 2147483648.0, "[TB]" } ; \
-                                  $2 ~ /Available_Reservd_Space|Media_Wearout_Indicator|Wear_Leveling_Count/ \
-                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $4, "[%]" }'
-                fi
-                echo
-
-                # restore standby state
-                [ "$disk_state" = "standby" ] && spindown_disk $disk_dev
-            fi
-        fi
-    done
-    echo
-
-    # --- show sata alpm mode
-    echo "+++ SATA Aggressive Link Power Management"
-    cnt=0
-    for i in /sys/class/scsi_host/host* ; do
-        if [ -f $i/link_power_management_policy ]; then
-            printparm "%-56s = ##%s##" $i/link_power_management_policy
-            cnt=$((cnt+1))
-        fi
-    done
-    if [ $cnt = 0 ]; then
-        echo "No AHCI-enabled host controller detected."
-    fi
-    echo
-fi # show_disk
-
-if [ "$show_all" = "1" ]; then
-    # --- show pcie aspm state
-    echo "+++ PCIe Active State Power Management"
-    if [ -f $ASPM ]; then
-        pol=$(cat $ASPM | sed -r 's/.*\[(.*)\].*/\1/')
-        echo "$pol" > $ASPM 2> /dev/null
-        if [ $? = 0 ]; then
-            echo "$ASPM = $pol"
-        else
-            echo "$ASPM = $pol (using bios preferences)"
-        fi
-    else
-        echo "$ASPM = (not available)"
-    fi
-    echo
-
-    # --- show i915 power mgmt
-    if [ -d $I915D ]; then
-        echo "+++ Intel Graphics"
-        printparm_i915 $I915D/powersave
-        printparm_i915 $I915D/enable_rc6 $I915D/i915_enable_rc6
-        printparm_i915 $I915D/enable_fbc $I915D/i915_enable_fbc
-        printparm_i915 $I915D/lvds_downclock
-        printparm_i915 $I915D/semaphores
-        echo
-    fi
-
-    # --- show radeon power profile or dpm state
-    if [ -d $RADD ]; then
-        for card in /sys/class/drm/card[0-9]/device ; do
-            if [ -f $card/power_dpm_state ] && [ -f $card/power_dpm_force_performance_level ]; then
-                # Use new radeon dpm state
-                echo "+++ Radeon Graphics"
-                printparm "%-25s = ##%s##" $card/power_dpm_state
-                printparm "%-25s = ##%s##" $card/power_dpm_force_performance_level
-                echo
-                break
-
-            elif [ -f $card/power_method ] && [ -f $card/power_profile ]; then
-                # Use old radeon power profile
-                echo "+++ Radeon Graphics"
-                printparm "%-25s = ##%s##" $card/power_method
-                printparm "%-25s = ##%s##" $card/power_profile
-                echo
-                break
-            fi
-        done
-    fi
-fi # show_all
-
-if [ "$show_rfkill" = "1" ] || [ "$show_all" = "1" ]; then
-    echo "+++ Wireless"
-    # --- show rfkill state
-    for i in bluetooth wifi wwan; do
-        get_devc $i
-        get_devs $i
-        echo_device_state $i $devs
-    done
-    echo
-
-    ifshown=0
-
-    # --- show bluetooth
-    get_bluetooth_ifaces
-    for iface in $bifaces; do
-        if [ -n "$iface" ]; then
-            ifshown=1
-
-            # get bluetooth driver
-            get_bluetooth_driver $iface
-            printf "%-20s: " "$iface($bluetoothdrv)"
-            if bluetooth_in_use $iface; then
-                echo "connected"
-            else
-                echo "not connected"
-            fi
-        fi
-    done
-
-    # --- show wifi data
-    get_wifi_ifaces
-    for iface in $wifaces; do
-        if [ -n "$iface" ]; then
-            ifshown=1
-
-            # get wifi power mgmt state
-            wifipm=""
-            if [ "$X_DONT_USE_IW" != "1" ] && cmd_exists $IW; then
-                # try with iw first
-                wifipm=$($IW dev $iface get power_save 2> /dev/null | \
-                    grep "Power save" | \
-                    sed -r 's/.*Power save: (on|off).*/\1/')
-            fi
-            if cmd_exists $IWC; then
-                if [ -z "$wifipm" ]; then
-                    # iw did not succeed or iw not installed -> try with iwconfig
-                    wifipm=$($IWC $iface 2> /dev/null | \
-                        grep "Power Management" | \
-                        sed -r 's/.*Power Management:(on|off).*/\1/')
-                fi
-            fi
-
-            # get wifi driver
-            get_wifi_driver $iface
-            printf "%-20s: " "$iface($wifidrv)"
-            if wireless_in_use $iface; then
-                printf "connected, "
-            else
-                printf "not connected, "
-            fi
-            printf "power management = "
-            case $wifipm in
-                on|off) printf "$wifipm" ;;
-                *)      printf "unknown" ;;
-            esac
-            printf "\n"
-        fi
-    done
-
-    # --- show wwan data
-    get_wwan_ifaces
-    for iface in $wanifaces; do
-        if [ -n "$iface" ]; then
-            ifshown=1
-
-            # get wwan driver
-            get_wwan_driver $iface
-
-            printf "%-20s: " "$iface($wwandrv)"
-            if wireless_in_use $iface; then
-                printf "connected"
-            else
-                printf "not connected"
-            fi
-            printf "\n"
-        fi
-    done
-    [ "$ifshown" = "1" ] && echo
-
-fi # show_rfkill
-
-if [ "$show_all" = "1" ]; then
-    # --- show sound power mode
-    echo "+++ Audio"
-    if [ -d /sys/module/snd_hda_intel ]; then
-        printparm "%-58s = ##%s##" /sys/module/snd_hda_intel/parameters/power_save
-        printparm "%-58s = ##%s##" /sys/module/snd_hda_intel/parameters/power_save_controller
-    fi
-    if [ -d /sys/module/snd_ac97_codec ]; then
-        printparm "%s = ##%s##" /sys/module/snd_ac97_codec/parameters/power_save
-    fi
-    echo
-
-    # -- show docks
-    cnt=0
-    for dock in $DOCKGLOB; do
-        [ ! -d $dock ] && break # no dock/bay detected
-
-        # dock/bay detected, print header
-        [ $cnt -eq 0 ] && echo "+++ Docks and Device Bays"
-        cnt=$((cnt+1))
-
-        # get dock type
-        { read -r dock_type < $dock/type; } 2>/dev/null
-
-        # get dock state
-        if check_is_docked; then
-            # docked
-            case $dock_type in
-                ata_bay)      dock_state="drive present" ;;
-                battery_bay)  dock_state="battery present" ;;
-                dock_station) dock_state="docked" ;;
-
-                *)  dock_state="docked"
-                    dock_type="unknown"
-                    ;;
-            esac
-        else
-            # not docked
-            case $dock_type in
-                ata_bay)      dock_state="no drive (or powered off)" ;;
-                battery_bay)  dock_state="no battery " ;;
-                dock_station) dock_state="undocked" ;;
-
-                *)  dock_state="undocked"
-                    dock_type="unknown"
-                    ;;
-            esac
-        fi
-
-        # print dock data
-        printf "%s: %-13s = %s\n" "$dock" "$dock_type" "$dock_state"
-    done
-    [ $cnt -gt 0 ] && echo
-fi # show_all
-
-if [ "$show_pcie" = "1" ] || [ "$show_all" = "1" ]; then
-    # -- show runtime pm
-    doall=${RUNTIME_PM_ALL:-0}
-
-    echo "+++ Runtime Power Management"
-    if [ "$doall" = "1" ]; then
-        echo "device classes   = all"
-    else
-        echo "device classes   = Ethernet, Wireless, Audio, Host Bridge, [SD] Card Reader, Firewire"
-    fi
-    echo "device blacklist = ${RUNTIME_PM_BLACKLIST:=(not configured)}"
-    echo "driver blacklist = ${RUNTIME_PM_DRIVER_BLACKLIST:=(not configured)}"
-    echo
-
-    if cmd_exists $TLPPCI; then
-        $TLPPCI
-        [ $? -eq 4 ] && no_runtimepm=1
-    else
-        echo "Error: missing subcommand $TLPPCI." 1>&2
-    fi
-    echo
-fi # show_pcie
-
-if [ "$show_usb" = "1" ] || [ "$show_all" = "1" ]; then
-    # -- show usb autosuspend
-    echo "+++ USB"
-    if [ "$USB_AUTOSUSPEND" = "1" ]; then
-        echo "autosuspend        = enabled"
-    else
-        echo "autosuspend        = disabled"
-    fi
-    echo "device whitelist   = ${USB_WHITELIST:=(not configured)}"
-    echo "device blacklist   = ${USB_BLACKLIST:=(not configured)}"
-    if [ "$USB_BLACKLIST_WWAN" = "1" ]; then
-        echo "wwan blacklist     = enabled"
-    else
-        echo "wwan blacklist     = disabled"
-    fi
-    if [ -n "$USB_DRIVER_BLACKLIST" ] && [ "$USB_DRIVER_BLACKLIST" != "usbhid" ]; then
-        echo "***Warning: USB_DRIVER_BLACKLIST is no longer supported, use USB_BLACKLIST."
-    fi
-    echo
-
-    if cmd_exists $TLPUSB; then
-        $TLPUSB
-        [ $? -eq 4 ] && no_runtimepm=1
-    else
-        echo "Error: missing subcommand $TLPUSB." 1>&2
-    fi
-    echo
-
-fi # show_usb
-
-if [ "$show_bat" = "1" ] || [ "$show_all" = "1" ]; then
-    # --- show battery info & charge thresholds
-    bcnt=0
-
-    # --- show availability of ThinkPad battery functions
-    if is_thinkpad; then
-        echo "+++ ThinkPad Extended Battery Functions"
-        echo -n "tp-smapi   = "
-        case $tpsmapi in
-            0)   echo "active" ;;
-            2)   echo "inactive (kernel module 'tp_smapi' load error)" ;;
-            127) echo "inactive (kernel module 'tp_smapi' not installed)" ;;
-            *)   echo "unknown status"
-        esac
-
-        echo -n "tpacpi-bat = "
-        case $tpacpi in
-            0)   echo "active" ;;
-            2)   echo "inactive (kernel module 'acpi_call' load error)" ;;
-            4)   echo "inactive (disabled by user configuration)" ;;
-            127) echo "inactive (kernel module 'acpi_call' not installed)" ;;
-            255) echo "inactive (unsupported hardware)" ;;
-        esac
-        echo
-    fi
-
-    if [ $tpsmapi -eq 0 ]; then
-        # it's a ThinkPad with tp-smapi
-
-        for batd in $SMAPIDIR/BAT[01]; do
-            if [ -d $batd ]; then
-                batt=${batd##/*/}
-
-                if check_tp_battery $batt; then # battery is present
-                    case $bat_idx in
-                        1) echo "+++ ThinkPad Battery Status: $batt (Main / Internal)" ;;
-                        2) echo "+++ ThinkPad Battery Status: $batt (Ultrabay / Slice / Replaceable)" ;;
-                        0) echo "+++ ThinkPad Battery Status: $batt" ;;
-                    esac
-
-                    printparm "%-59s = ##%s##" $batd/manufacturer
-                    printparm "%-59s = ##%s##" $batd/model
-                    printparm "%-59s = ##%s##" $batd/manufacture_date
-                    printparm "%-59s = ##%s##" $batd/first_use_date
-                    printparm "%-59s = ##%6d##" $batd/cycle_count
-                    printparm "%-59s = ##%6d## [mWh]" $batd/design_capacity
-                    printparm "%-59s = ##%6d## [mWh]" $batd/last_full_capacity
-                    printparm "%-59s = ##%6d## [mWh]" $batd/remaining_capacity
-                    printparm "%-59s = ##%6d## [%%]" $batd/remaining_percent
-                    printparm "%-59s = ##%6s## [min]" $batd/remaining_running_time_now
-                    printparm "%-59s = ##%6s## [min]" $batd/remaining_charging_time
-                    printparm "%-59s = ##%6d## [mW]" $batd/power_now
-                    printparm "%-59s = ##%6d## [mW]" $batd/power_avg
-                    print_tp_batstate $batd/state
-                    echo
-                    if [ $show_verbose -eq 1 ]; then
-                        printparm "%-59s = ##%6s## [mV]" $batd/group0_voltage
-                        printparm "%-59s = ##%6s## [mV]" $batd/group1_voltage
-                        printparm "%-59s = ##%6s## [mV]" $batd/group2_voltage
-                        printparm "%-59s = ##%6s## [mV]" $batd/group3_voltage
-                        echo
-                    fi
-
-                    if [ $tpacpi -eq 0 ]; then
-                        # --- show ThinkPad charge thresholds via tpacpi-bat
-                        print_tpacpi_thresholds $batt $bat_idx
-                    else
-                        # show thresholds via tp-smapi
-                        printparm "%-59s = ##%6d## [%%]" $batd/start_charge_thresh
-                        printparm "%-59s = ##%6d## [%%]" $batd/stop_charge_thresh
-                        printparm "%-59s = ##%6d##" $batd/force_discharge
-                    fi
-                    echo
-
-                    bcnt=$(($bcnt+1))
-                fi
-            fi
-        done
-    elif [ -d $ACPIBATDIR ]; then
-        # --- show ACPI data
-
-        for batd in $ACPIBATDIR/*; do
-            batt=${batd##/*/}
-            tpbat=0
-
-            if check_tp_battery $batt; then
-                # ThinkPad battery is present
-                tpbat=1
-
-                if [ $tpacpi -eq 0 ]; then
-                    # it's a ThinkPad with tpacpi-bat only
-                    case $bat_idx in
-                        1) echo "+++ ThinkPad Battery Status: $batt (Main / Internal)" ;;
-                        2) echo "+++ ThinkPad Battery Status: $batt (Ultrabay / Slice / Replaceable)" ;;
-                        0) echo "+++ ThinkPad Battery Status: $batt" ;;
-                    esac
-                else
-                   # it's a ThinkPad with neither tp-smapi nor tpacpi-bat
-                    echo "+++ Battery Status"
-                fi
-            elif [ -d $batd ] \
-                 && [ "$(cat $batd/type)" = "Battery" ] \
-                 && [ "$(cat $batd/present)" = "1" ]; then
-                    # it's some other laptop model or brand
-                    echo "+++ Battery Status"
-            else
-                batt="" # power supply is not a battery
-            fi
-
-            if [ -n "$batt" ]; then
-                printparm "%-59s = ##%s##" $batd/manufacturer
-                printparm "%-59s = ##%s##" $batd/model_name
-
-                cc=$(cat $batd/cycle_count 2> /dev/null)
-                if [ $? -eq 0 ] && [ -n "$cc" ] && [ $cc -gt 0 ]; then
-                    printf "%-59s = %6d\n" $batd/cycle_count $cc
-                else
-                    printf "%-59s = (not supported)\n" $batd/cycle_count
-                fi
-
-                if [ -f $batd/energy_full ]; then
-                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_full_design "" 000
-                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_full "" 000
-                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_now "" 000
-                    printparm "%-59s = ##%6d## [mW]" $batd/power_now "" 000
-                elif [ -f $batd/charge_full ]; then
-                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_full_design "" 000
-                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_full "" 000
-                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_now "" 000
-                    printparm "%-59s = ##%6d## [mA]" $batd/current_now "" 000
-                fi
-                if [ $tpbat -eq 1 ]; then
-                    print_tp_batstate $batd/status
-                else
-                    printparm "%-59s = ##%s##" $batd/status
-                fi
-                echo
-
-                if [ $tpacpi -eq 0 ]; then
-                    # --- show ThinkPad charge thresholds via tpacpi-bat
-                    print_tpacpi_thresholds $batt $bat_idx
-                    echo
-                fi # if $tpcacpi
-
-                bcnt=$(($bcnt+1))
-            fi # if $batt
-        done # $batd
-
-    fi # if /sys/class/power_supply
-
-    if [ $bcnt -eq 0 ]; then
-        printf "+++ Battery Status\n"
-        printf "No batteries detected.\n\n"
-    fi
-
-fi # show_bat
-
-if [ "$show_warn" = "1" ] || [ "$show_disk" = "1" ] || [ "$show_all" = "1" ]; then
-    # --- show warnings
-    # ata errors (possibly) caused by SATA_LINKPWR_ON_AC/BAT != max_performance
-    ecnt=$( check_ata_errors )
-    if [ $ecnt -ne 0 ]; then
-        echo "+++ Warnings"
-        printf "* Kernel log shows ata errors (%d) possibly caused by the configuration\n" $ecnt
-        printf "  SATA_LINKPWR_ON_AC/BAT=min_power or medium_power.\n"
-        printf "  Consider using medium_power or max_performance instead.\n"
-        printf "  See the FAQ: http://linrunner.de/en/tlp/docs/tlp-faq.html#warnings\n"
-        printf "  Details:\n"
-        dmesg | egrep -A 5 "ata[0-9]+: SError: { .*CommWake }"
-        echo
-    elif [ "$show_warn" = "1" ]; then
-        echo "No warnings detected."
-        echo ""
-    fi
-
-fi # show_warn
-
-if [ "$show_all" = "1" ]; then
-    # -- show suggestions
-    suout=""
-
-    if [ "$no_runtimepm" = "1" ]; then
-        suout="${suout}Reconfigure your Linux kernel with PM_RUNTIME=y to reduce your laptop's power consumption.\n"
-    fi
-
-    if is_thinkpad; then
-        # Add ThinkPad specific suggestions
-        model="$( read_dmi product_version )"
-        model=${model#ThinkPad }
-        model=${model#Edge }
-
-        case $model in
-            "X1 Carbon*"|X2[345]0*|T[45][345][01]*|W5[345][01]*|L[45][345]0|E[1345][05]|S[245][345][01]*)
-                [ $tpacpi -eq 127 ]  && suout="${suout}Install acpi-call kernel module for ThinkPad advanced battery functions\n"
-                ;;
-
-            X1|X220*|T420*|T520|W520)
-                [ $tpacpi -eq 127 ]  && suout="${suout}Install acpi-call kernel module for ThinkPad advanced battery functions\n"
-                [ $tpsmapi -eq 127 ] && suout="${suout}Install tp-smapi kernel modules for ThinkPad advanced battery functions\n"
-                ;;
-
-            SL?00) ;;
-
-            *) [ $tpsmapi -eq 127 ]  && suout="${suout}Install tp-smapi kernel modules for ThinkPad advanced battery functions\n"
-                ;;
-        esac
-
-    fi # if ThinkPad
-
-    # Add other suggestions
-    cmd_exists ethtool || suout="${suout}Install ethtool to disable Wake On LAN (WOL)\n"
-    cmd_exists smartctl || suout="${suout}Install smartmontools for disk drive health info\n"
-
-    if [ -n "$suout" ]; then
-        echo "+++ Suggestions"
-        printf "$suout" | sed -r 's/^/\* /'
-        echo
-    fi
-
-fi # show_all
-
-if [ "$show_trace" = "1" ]; then
-    # --- show debug log
-
-    # check for systemd journal
-    jdone=0
-    if cmd_exists $JOURNALCTL; then
-        # retrieve trace output from journal
-        $JOURNALCTL -p debug --no-pager SYSLOG_IDENTIFIER=tlp 2> /dev/null
-        # check result -- rc=1 if journald has no data available
-        [ $? -eq 0 ] && jdone=1
-    fi
-
-    if [ "$jdone" = "0"  ]; then
-        # no journald data available --> retrieve trace output from logfile
-        if [ -f $DEBUGLOG ]; then
-            grep "tlp\[" $DEBUGLOG
-        else
-            echo "Error: $DEBUGLOG does not exist." 1>&2
-            echo 1>&2
-            echo "Solution: create an rsyslog conffile /etc/rsyslog.d/90-debug.conf with the following contents" 1>&2
-            echo " *.=debug;\\" 1>&2
-            echo " mail,authpriv,cron.none;\\" 1>&2
-            echo " local0,local1,local3,local4,\\" 1>&2
-            echo " local5,local6,local7.none    -/var/log/debug" 1>&2
-            echo "and restart the rsyslog daemon." 1>&2
-            echo 1>&2
-        fi
-    fi
-fi # show_trace
-
-exit 0
diff --git a/tlp-stat.in b/tlp-stat.in
new file mode 100755
index 0000000..af3a52c
--- /dev/null
+++ b/tlp-stat.in
@@ -0,0 +1,1194 @@
+#!/bin/sh
+# tlp - display power save and usb autosuspend status
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+readonly TLPUSB=tlp-usblist
+readonly TLPPCI=tlp-pcilist
+
+readonly SMARTCTL=smartctl
+readonly LSBREL=lsb_release
+
+readonly ASPM=/sys/module/pcie_aspm/parameters/policy
+readonly NMIWD=/proc/sys/kernel/nmi_watchdog
+
+readonly IBMTHERMAL=/proc/acpi/ibm/thermal
+readonly CORETEMP_DIRS="
+/sys/devices/platform/coretemp.0
+/sys/devices/platform/coretemp.0/hwmon/hwmon*"
+readonly IBMFAN=/proc/acpi/ibm/fan
+readonly HWMONFAN_DIRS="
+/sys/class/hwmon/hwmon*/device
+/sys/class/hwmon/hwmon*"
+
+readonly JOURNALCTL=journalctl
+readonly DEBUGLOG=/var/log/debug
+
+readonly SYSTEMD_SERVICES="tlp.service tlp-sleep.service"
+
+# --- Variables
+needs_root_priv=
+show_all=1
+show_bat=0
+show_conf=0
+show_disk=0
+show_pcie=0
+show_proc=0
+show_rfkill=0
+show_system=0
+show_temp=0
+show_trace=0
+show_usb=0
+show_verbose=0
+show_warn=0
+
+no_runtimepm=0
+
+# --- Functions
+
+printparm () { # formatted output of sysfile - general
+    # $1: format, $2: sysfile, $3: namsg, $4: cutoff
+    local format="$1"
+    local sysf="$2"
+    local namsg="$3"
+    local cutoff="$4"
+    local val=""
+
+    if [ -f $sysf ]; then
+        # sysfile exists
+        val=$(cat $sysf 2> /dev/null)
+        if [ $? = 0 ]; then
+            # sysfile read successful
+            if [ -n "$cutoff" ]; then
+                val=${val%$cutoff}
+            fi
+        fi
+    fi
+
+    if [ -z "$val" ]; then
+        # replace empty value with n/a text
+        if [ -n "$namsg" ]; then
+            format=$( echo $format | sed -r "s/##(.*)##/($namsg)/" | sed -r "s/\[.*\]//" )
+        else
+            format=$( echo $format | sed -r "s/##(.*)##/(not available)/" | sed -r "s/\[.*\]//" )
+        fi
+        printf "$format\n" "$sysf"
+    else
+        # non empty value: strip delimiters from format str
+        format=$( echo $format | sed -r "s/##(.*)##/\1/" )
+        printf "$format\n" "$sysf" "$val"
+    fi
+
+    return 0
+}
+
+printparm_i915 () { # formatted output of sysfile - i915 kernel module variant
+    # $1: sysfile, $2: alternative
+    local sysf val
+
+    # Check if sysfile or alternative exist
+    if [ -f $1 ]; then
+        sysf=$1
+    elif [ -f $2 ]; then
+        sysf=$2
+    else
+        sysf=""
+    fi
+
+    if [ -n "$sysf" ]; then
+        # sysfile exists, get content
+        val=$(cat $sysf 2> /dev/null)
+        if [ $? = 0 ]; then
+            # sysfile was readable, output content
+            printf "%-44s = %2d " $sysf $val
+            # Explain content
+            if [ "$val" = "-1" ]; then
+                echo "(use per-chip default)"
+            else
+                echo -n "("
+                if [ $(( $val & 1 )) -ne 0 ]; then
+                    echo -n "enabled"
+                else
+                    echo -n "disabled"
+                fi
+                [ $(( $val & 2 )) -ne 0 ] && echo -n " + deep"
+                [ $(( $val & 4 )) -ne 0 ] && echo -n " + deepest"
+                echo ")"
+            fi
+        else
+            # sysfile was not readable
+            printf "%-44s = (not available)\n" $sysf
+        fi
+    else
+        # Neither sysfile nor alternative exists
+        printf "%-44s = (not available)\n" $1
+    fi
+
+    return 0
+}
+
+print_tp_batstate () { # print battery charging state with an explanation when
+    # a threshold inhibits charging
+    # $1: sysfile; $2: 1=ThinkPad battery/0=other
+    local sysf val
+
+    # Check if bat state sysfile exists
+    if [ -f $1 ]; then
+        sysf=$1
+    else
+        sysf=""
+    fi
+
+    if [ -n "$sysf" ]; then
+        # bat state sysfile exists, get content
+        val=$(cat $sysf 2> /dev/null)
+        if [ $? = 0 ]; then
+            # sysfile was readable, output content
+            printf "%-59s = %s" $sysf $val
+            # Explain content if necessary
+            case $val in
+                Unknown) # "Unknown" means a threshold forbids charging
+                    printf " (threshold effective)\n"
+                    ;;
+
+                *) # Nothing to do
+                    printf "\n"
+                    ;;
+            esac
+        else
+            # sysfile was not readable
+            printf "%-59s = (not available)\n" $sysf
+        fi
+    else
+        # sysfile nonexistent
+        printf "%-59s = (not available)\n" $1
+    fi
+
+    return 0
+}
+
+print_tpacpi_thresholds () { # formatted output of ThinkPad charging thresholds
+    # - tpcapi-bat variant
+    # $1: BAT0/BAT1; $2: bat # = 1/2
+    local start_thresh stop_thresh force
+
+    read_tpacpi_threshold ST $2
+    start_thresh=$?
+    if [ $start_thresh -ne 255 ]; then
+        [ $start_thresh -eq 0 ] && start_thresh=96
+        printf "%-59s = %6d [%%]\n" "tpacpi-bat.${1}.startThreshold" $start_thresh
+    else
+        printf "%-59s = (not available)\n" "tpacpi-bat.${1}.startThreshold"
+    fi
+
+    read_tpacpi_threshold SP $2
+    stop_thresh=$?
+    if [ $stop_thresh -ne 255 ]; then
+        [ $stop_thresh -eq  0 ] && stop_thresh=100
+        printf "%-59s = %6d [%%]\n" "tpacpi-bat.${1}.stopThreshold" $stop_thresh
+    else
+        printf "%-59s = (not available)\n" "tpacpi-bat.${1}.stopThreshold"
+    fi
+
+    get_force_discharge $2; force=$?
+    if [ $force -ne 2 ]; then
+        printf "%-59s = %6d\n" "tpacpi-bat.${1}.forceDischarge" "$force"
+    else
+        printf "%-59s = %s\n" "tpacpi-bat.${1}.forceDischarge" "(not available)"
+    fi
+
+    return 0
+}
+
+check_ata_errors () { # check kernel log for ata errors
+    # (possibly) caused by SATA_LINKPWR_ON_AC/BAT != max_performance
+    # stdout: error count
+
+    if wordinlist $SATA_LINKPWR_ON_BAT "min_power medium_power" || \
+       wordinlist $SATA_LINKPWR_ON_AC "min_power medium_power"; then
+        # config values != max_performance exist --> check kernel log
+
+        # count matching error lines
+        echo $( dmesg | egrep -c "ata[0-9]+: SError: {.*CommWake.*}" 2> /dev/null )
+    else
+        # no values in question configured 
+        echo "0"
+    fi
+
+    return 0
+}
+
+# @stdout glob_files ( glob_pattern, dir[, dir...] )
+#
+#  Nested for-loop that applies a glob expression to several directories
+#  (or file path prefixes) and prints matching file paths to stdout.
+#
+glob_files () {
+    [ -n "${1-}" ] || return 64
+    local glob_pattern file_iter
+
+    glob_pattern="${1}"
+
+    while shift && [ $# -gt 0 ]; do
+        for file_iter in ${1}${glob_pattern}; do
+            [ ! -f "${file_iter}" ] || echo "${file_iter}"
+        done
+    done
+}
+
+read_args () { # read command line arguments
+    for a in $*; do
+        case $a in
+            "-b"|"--battery")
+                show_all=0
+                show_bat=1
+                needs_root_priv=1
+                ;;
+
+            "-c"|"--config")
+                show_all=0
+                show_conf=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-d"|"--disk")
+                show_all=0
+                show_disk=1
+                needs_root_priv=1
+                ;;
+
+            "-e"|"--pcie")
+                show_all=0
+                show_pcie=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-p"|"--processor")
+                show_all=0
+                show_proc=1
+                needs_root_priv=1
+                ;;
+
+            "-r"|"--rfkill")
+                show_all=0
+                show_rfkill=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-s"|"--system")
+                show_all=0
+                show_system=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-t"|"--temp")
+                show_all=0
+                show_temp=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-u"|"--usb")
+                show_all=0
+                show_usb=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-v"|"--verbose")
+                show_verbose=1
+                ;;
+
+            "-w"|"--warn")
+                show_all=0
+                show_warn=1
+                : ${needs_root_priv:=0}
+                ;;
+
+            "-T"|"--trace")
+                show_all=0
+                show_trace=1
+                needs_root_priv=1
+                ;;
+
+            *)
+                echo "Usage: tlp-stat [ -b | --battery   | -c | --config |"
+                echo "                  -d | --disk      | -e | --pcie   |"
+                echo "                  -p | --processor | -r | --rfkill |"
+                echo "                  -s | --system    | -t | --temp   |"
+                echo "                  -u | --usb       | -w | --warn   |"
+                echo "                  -T | --trace     | -v | --verbose ]"
+                exit 3
+                ;;
+        esac
+    done
+}
+
+# --- Locate and source libraries
+
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+if [ ! -d $libdir ]; then
+    echo "Error: missing library directory ($LIBDIRS)." 1>&2
+    exit 1
+fi
+
+for lib in $LIBS; do
+    if [ ! -f $libdir/$lib ]; then
+        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
+        exit 1
+    fi
+    . $libdir/$lib
+done
+
+# --- MAIN
+add_sbin2path
+
+read_args $*
+: ${needs_root_priv:=1}
+
+# inhibit trace output
+nodebug=1
+
+# check for and read conffile
+read_defaults
+conf_present=$?
+
+# check prereqisites
+if [ "$needs_root_priv" = "1" ]; then
+    check_root
+    load_modules
+    check_tpacpi
+    check_tpsmapi
+fi
+
+echo "--- TLP $TLPVER --------------------------------------------"
+echo
+
+# --- show configuration
+if [ "$show_conf" = "1" ] || [ "$show_all" = "1" ]; then
+    if [ $conf_present -eq 0 ]; then
+        echo "+++ Configured Settings: $CONFFILE"
+        egrep -v '^#|^\s*$' $CONFFILE
+        echo
+    else
+        echo "Warning: config file $CONFFILE not present." 1>&2
+        echo
+    fi
+fi # show_conf
+
+if [ "$show_system" = "1" ] || [ "$show_all" = "1" ] ; then
+    # --- show system info
+    echo "+++ System Info"
+
+    echo "System         = $( read_dmi sys_vendor product_version product_name )"
+    echo "BIOS           = $( read_dmi bios_version )"
+
+    # --- show release & kernel info
+    cmd_exists $LSBREL && echo "Release        = $($LSBREL -d -s)"
+    echo "Kernel         = $(uname -r -m -v)"
+    printparm "%-14s = %s" /proc/cmdline
+
+    # --- show init system info
+    if check_systemd; then
+        echo "Init system    = systemd"
+    elif check_upstart; then
+        echo "Init system    = upstart"
+    elif check_openrc; then
+        echo "Init system    = openrc"
+    else
+        echo "Init system    = sysvinit"
+    fi
+    echo
+
+    # --- show TLP status
+    echo "+++ System Status"
+    if [ "$TLP_ENABLE" = "1" ]; then
+        echo "TLP power save = enabled"
+    else
+        echo "TLP power save = not enabled"
+    fi
+
+    # -- check systemd service units status
+    if check_systemd; then
+        for su in $SYSTEMD_SERVICES; do
+            if ! $SYSTEMCTL is-enabled $su > /dev/null 2>&1 ; then
+                echo "***Warning: $su is not enabled -- invoke \"systemctl enable $su\" to correct this!"
+            fi
+        done
+    fi
+
+    # -- show warning if l-m-t detected
+    check_laptop_mode_tools
+
+    # --- show power source
+    get_sys_power_supply
+    case $? in
+        0) echo "power source   = AC" ;;
+        1) echo "power source   = battery" ;;
+        *) echo "power source   = unknown (using ${TLP_DEFAULT_MODE:-AC} settings)" ;;
+    esac
+    echo
+fi # show_system
+
+if [ "$show_proc" = "1" ] || [ "$show_all" = "1" ]; then
+    # --- show cpu info
+    echo "+++ Processor"
+    sed -rn 's/model name[ \t]+: (.+)/CPU Model      = \1/p' /proc/cpuinfo | head -1
+    echo
+
+    # -- show scaling gov and freq info
+    for cpuf in /sys/devices/system/cpu/cpu*/cpufreq; do
+        if [ -f $cpuf/scaling_driver ]; then
+            printparm "%-54s = ##%s##" $cpuf/scaling_driver
+            printparm "%-54s = ##%s##" $cpuf/scaling_governor
+
+            if [ -f $cpuf/scaling_min_freq ]; then
+                printf "%-54s = %8d [kHz]\n" $cpuf/scaling_min_freq $(cat $cpuf/scaling_min_freq)
+            fi
+
+            if [ -f $cpuf/scaling_max_freq ]; then
+                printf "%-54s = %8d [kHz]\n" $cpuf/scaling_max_freq $(cat $cpuf/scaling_max_freq)
+            fi
+
+            if [ -f $cpuf/scaling_available_frequencies ]; then
+                printf "%s = " $cpuf/scaling_available_frequencies
+                for freq in $(cat $cpuf/scaling_available_frequencies); do
+                    printf "%s " $freq
+                done
+                printf "[kHz]\n"
+            fi
+            printf "\n"
+        fi
+    done
+
+    check_intel_pstate
+
+    if [ $intel_pstate -eq 1 ]; then
+        # show Intel P-state info
+        printparm "%-54s = ##%d##" $CPU_MIN_PERF_PCT
+        printparm "%-54s = ##%d##" $CPU_MAX_PERF_PCT
+        printparm "%-54s = ##%d##" $CPU_TURBO_PSTATE
+
+    elif [ -f $CPU_BOOST_ALL_CTRL ]; then
+        # show turbo boost info
+        get_sysval $CPU_BOOST_ALL_CTRL; boost=$?
+
+        # simple test for attribute "w" doesn't work, so actually write
+        if ( echo "$boost" > $CPU_BOOST_ALL_CTRL ) 2> /dev/null; then
+            printparm "%-54s = ##%d##" $CPU_BOOST_ALL_CTRL
+        else
+            printparm "%-54s = ##%d## (cpu not supported)" $CPU_BOOST_ALL_CTRL
+        fi
+    else
+         printparm "%-54s = (not available)" $CPU_BOOST_ALL_CTRL
+    fi
+
+    # --- show sched power save info
+    for pool in mc smp smt; do
+        sdev="/sys/devices/system/cpu/sched_${pool}_power_savings"
+        [ -f $sdev ] && printparm "%-54s = ##%d##" $sdev
+    done
+    echo
+
+    # --- show x86 energy perf policy info
+    if cmd_exists $ENERGYPERF; then
+        # check CPU support
+        $ENERGYPERF -r > /dev/null 2>&1
+        case $? in
+            0)  # parse x86_energy_perf_policy output:
+                # - replace numbers with descriptive strings
+                # - remove ":"
+                # - indent and align
+                $ENERGYPERF -r 2>/dev/null | \
+                    sed 's/0x0000000000000000/performance/;
+                         s/0x0000000000000006/normal/;
+                         s/0x000000000000000f/powersave/;
+                         s/://' | \
+                    awk '{ printf "x86_energy_perf_policy.%-31s = %s\n", $1, $2; }'
+                ;;
+
+            1) echo "x86_energy_perf_policy: unsupported CPU." ;;
+            2) echo "x86_energy_perf_policy: program for your kernel not installed." ;;
+            *) echo "x86_energy_perf_policy: not available." ;;
+        esac
+        echo
+    else
+        echo "x86_energy_perf_policy: program not installed."
+        echo
+    fi
+
+    # --- show nmi watchdog
+    printparm "%-54s = ##%d##" $NMIWD
+    echo
+
+    # --- show voltages
+    echo "+++ Undervolting"
+    phc_avail=0
+    for cpuf in /sys/devices/system/cpu/cpu*/cpufreq; do
+        if [ -f $cpuf/phc_controls ]; then
+            phc_avail=1
+            printparm "%-58s = ##%s##" $cpuf/phc_controls
+            printparm "%-58s = ##%s##" $cpuf/phc_default_controls
+            echo
+        fi
+    done
+    if [ $phc_avail = 0 ]; then
+        echo "PHC kernel not available."
+        echo
+    fi
+fi # show_proc
+
+if [ "$show_temp" = "1" ] || [ "$show_all" = "1" ]; then
+    # --- show temperatures
+    echo "+++ Temperatures"
+    if [ -f $IBMTHERMAL ]; then
+        # use thinkpad-specific sysfile
+        echo "$IBMTHERMAL = $(cat $IBMTHERMAL | cut -f2) [C]"
+    else
+        # use sensors
+        cmax=0
+        for sens in $(glob_files '/temp?*_input' $CORETEMP_DIRS); do
+            if grep -q -- 'Physical' ${sens%input}label 2>/dev/null; then
+                # package info is available -> ignore remaining sensors
+                read -r cmax < $sens
+                break
+            else
+                # core info -> find max value
+                read -r ctemp < $sens && [ $ctemp -gt $cmax ] && cmax=$ctemp
+            fi
+        done
+        if [ $cmax -gt 0 ]; then
+            printf "CPU temp               = %5d [C]\n" $(( $cmax / 1000 ))
+        fi
+
+    fi
+
+    # --- show fan speed
+    if is_thinkpad && [ -f $IBMFAN ]; then
+        # use thinkpad-specific sysfile
+        awk '$1 ~ /speed:/ { printf "'$IBMFAN'     = %5d [/min]\n", $2 }' $IBMFAN
+    else
+        # use hwmon
+        have_any_fan=
+        for fan in $(glob_files '/fan?*_input' $HWMONFAN_DIRS); do
+            if read -r fan_speed < $fan; then
+                fan_name="${fan##*/}"; fan_name="${fan_name%_input}"
+                have_any_fan=y
+
+                printf "Fan speed (%s)       = %5d [/min]\n" \
+                    ${fan_name} ${fan_speed}
+            fi
+        done
+        if [ -z "${have_any_fan}" ]; then
+            printf "Fan speed              = (not available)\n"
+        fi
+    fi
+    echo
+fi # show_temp
+
+if [ "$show_all" = "1" ]; then
+    # --- show laptop-mode, dirty buffers params
+    echo "+++ File System"
+    printparm "%-38s = ##%5d##" /proc/sys/vm/laptop_mode
+    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_writeback_centisecs
+    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_expire_centisecs
+    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_ratio
+    printparm "%-38s = ##%5d##" /proc/sys/vm/dirty_background_ratio
+    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/age_buffer_centisecs
+    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/xfssyncd_centisecs
+    printparm "%-38s = ##%5d##" /proc/sys/fs/xfs/xfsbufd_centisecs
+    echo
+fi # show_all
+
+if [ "$show_disk" = "1" ] || [ "$show_all" = "1" ]; then
+    # --- show disk info form hdparm
+    echo "+++ Storage Devices"
+    : ${DISK_DEVICES:=${DEFAULT_DISK_DEVICES}}
+    for dev in $DISK_DEVICES; do # iterate all devices
+        get_disk_dev $dev
+
+        if [ -b /dev/$disk_dev ]; then
+            get_disk_state $disk_dev
+            check_disk_hdparm_cap $disk_dev
+            if [ $? = 0 ]; then
+                echo "/dev/$disk_dev:"
+
+                if [ -n "$disk_id" ]; then
+                    echo "          Disk ID   = $disk_id"
+                fi
+
+                echo -n "          Model     = "
+                echo_disk_model $disk_dev
+
+                echo -n "          Firmware  = "
+                echo_disk_firmware $disk_dev
+
+                get_disk_apm_level $disk_dev
+                apm=$?
+                echo -n "          APM Level = "
+                case $apm in
+                    0|255) echo "none/disabled" ;;
+                    *)     echo $apm ;;
+                esac
+
+                echo "          Status    = $disk_state"
+
+                get_disk_trim_capability $disk_dev
+                trim=$?
+                case $trim in
+                    0) echo "          TRIM      = not supported" ;;
+                    1) echo "          TRIM      = supported" ;;
+                esac
+
+                [ -f /sys/block/$disk_dev/queue/scheduler ] && \
+                    echo "          Scheduler = $(cat /sys/block/$disk_dev/queue/scheduler | sed -r 's/.*\[(.*)\].*/\1/')"
+
+                if cmd_exists $SMARTCTL ; then
+                    # --- show SMART data
+                    echo
+                    echo "        SMART info:"
+                    $SMARTCTL -A /dev/$disk_dev | grep -v '<==' | \
+                      awk -F ' ' '$2 ~ /Start_Stop_Count|Load_Cycle_Count|Reallocated_Sector_Ct|Used_Rsvd_Blk_Cnt_Chip|Used_Rsvd_Blk_Cnt_Tot/ \
+                                        { printf "          %3d %-25s = %8d \n", $1, $2, $10 } ; \
+                                  $2 ~ /Power_On_Hours/ \
+                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $10, "[h]" } ; \
+                                  $2 ~ /Temperature_Celsius/ \
+                                        { printf "          %3d %-25s = %8d %s %s %s %s\n", $1, $2, $10, $11, $12, $13, "[C]" } ; \
+                                  $2 ~ /Airflow_Temperature_Cel/ \
+                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $10, "[C]" } ; \
+                                  $2 ~ /Host_Writes/ \
+                                        { printf "          %3d %-25s = %8.3f %s\n", $1, $2, $10 / 32768.0, "[TB]" } ; \
+                                  $2 ~ /Total_LBAs_Written/ \
+                                        { printf "          %3d %-25s = %8.3f %s\n", $1, $2, $10 / 2147483648.0, "[TB]" } ; \
+                                  $2 ~ /Available_Reservd_Space|Media_Wearout_Indicator|Wear_Leveling_Count/ \
+                                        { printf "          %3d %-25s = %8d %s\n", $1, $2, $4, "[%]" }'
+                fi
+                echo
+
+                # restore standby state
+                [ "$disk_state" = "standby" ] && spindown_disk $disk_dev
+            fi
+        fi
+    done
+    echo
+
+    # --- show sata alpm mode
+    echo "+++ SATA Aggressive Link Power Management"
+    cnt=0
+    for i in /sys/class/scsi_host/host* ; do
+        if [ -f $i/link_power_management_policy ]; then
+            printparm "%-56s = ##%s##" $i/link_power_management_policy
+            cnt=$((cnt+1))
+        fi
+    done
+    if [ $cnt = 0 ]; then
+        echo "No AHCI-enabled host controller detected."
+    fi
+    echo
+fi # show_disk
+
+if [ "$show_all" = "1" ]; then
+    # --- show pcie aspm state
+    echo "+++ PCIe Active State Power Management"
+    if [ -f $ASPM ]; then
+        pol=$(cat $ASPM | sed -r 's/.*\[(.*)\].*/\1/')
+        echo "$pol" > $ASPM 2> /dev/null
+        if [ $? = 0 ]; then
+            echo "$ASPM = $pol"
+        else
+            echo "$ASPM = $pol (using bios preferences)"
+        fi
+    else
+        echo "$ASPM = (not available)"
+    fi
+    echo
+
+    # --- show i915 power mgmt
+    if [ -d $I915D ]; then
+        echo "+++ Intel Graphics"
+        printparm_i915 $I915D/powersave
+        printparm_i915 $I915D/enable_rc6 $I915D/i915_enable_rc6
+        printparm_i915 $I915D/enable_fbc $I915D/i915_enable_fbc
+        printparm_i915 $I915D/lvds_downclock
+        printparm_i915 $I915D/semaphores
+        echo
+    fi
+
+    # --- show radeon power profile or dpm state
+    if [ -d $RADD ]; then
+        for card in /sys/class/drm/card[0-9]/device ; do
+            if [ -f $card/power_dpm_state ] && [ -f $card/power_dpm_force_performance_level ]; then
+                # Use new radeon dpm state
+                echo "+++ Radeon Graphics"
+                printparm "%-25s = ##%s##" $card/power_dpm_state
+                printparm "%-25s = ##%s##" $card/power_dpm_force_performance_level
+                echo
+                break
+
+            elif [ -f $card/power_method ] && [ -f $card/power_profile ]; then
+                # Use old radeon power profile
+                echo "+++ Radeon Graphics"
+                printparm "%-25s = ##%s##" $card/power_method
+                printparm "%-25s = ##%s##" $card/power_profile
+                echo
+                break
+            fi
+        done
+    fi
+fi # show_all
+
+if [ "$show_rfkill" = "1" ] || [ "$show_all" = "1" ]; then
+    echo "+++ Wireless"
+    # --- show rfkill state
+    for i in bluetooth wifi wwan; do
+        get_devc $i
+        get_devs $i
+        echo_device_state $i $devs
+    done
+    echo
+
+    ifshown=0
+
+    # --- show bluetooth
+    get_bluetooth_ifaces
+    for iface in $bifaces; do
+        if [ -n "$iface" ]; then
+            ifshown=1
+
+            # get bluetooth driver
+            get_bluetooth_driver $iface
+            printf "%-20s: " "$iface($bluetoothdrv)"
+            if bluetooth_in_use $iface; then
+                echo "connected"
+            else
+                echo "not connected"
+            fi
+        fi
+    done
+
+    # --- show wifi data
+    get_wifi_ifaces
+    for iface in $wifaces; do
+        if [ -n "$iface" ]; then
+            ifshown=1
+
+            # get wifi power mgmt state
+            wifipm=""
+            if [ "$X_DONT_USE_IW" != "1" ] && cmd_exists $IW; then
+                # try with iw first
+                wifipm=$($IW dev $iface get power_save 2> /dev/null | \
+                    grep "Power save" | \
+                    sed -r 's/.*Power save: (on|off).*/\1/')
+            fi
+            if cmd_exists $IWC; then
+                if [ -z "$wifipm" ]; then
+                    # iw did not succeed or iw not installed -> try with iwconfig
+                    wifipm=$($IWC $iface 2> /dev/null | \
+                        grep "Power Management" | \
+                        sed -r 's/.*Power Management:(on|off).*/\1/')
+                fi
+            fi
+
+            # get wifi driver
+            get_wifi_driver $iface
+            printf "%-20s: " "$iface($wifidrv)"
+            if wireless_in_use $iface; then
+                printf "connected, "
+            else
+                printf "not connected, "
+            fi
+            printf "power management = "
+            case $wifipm in
+                on|off) printf "$wifipm" ;;
+                *)      printf "unknown" ;;
+            esac
+            printf "\n"
+        fi
+    done
+
+    # --- show wwan data
+    get_wwan_ifaces
+    for iface in $wanifaces; do
+        if [ -n "$iface" ]; then
+            ifshown=1
+
+            # get wwan driver
+            get_wwan_driver $iface
+
+            printf "%-20s: " "$iface($wwandrv)"
+            if wireless_in_use $iface; then
+                printf "connected"
+            else
+                printf "not connected"
+            fi
+            printf "\n"
+        fi
+    done
+    [ "$ifshown" = "1" ] && echo
+
+fi # show_rfkill
+
+if [ "$show_all" = "1" ]; then
+    # --- show sound power mode
+    echo "+++ Audio"
+    if [ -d /sys/module/snd_hda_intel ]; then
+        printparm "%-58s = ##%s##" /sys/module/snd_hda_intel/parameters/power_save
+        printparm "%-58s = ##%s##" /sys/module/snd_hda_intel/parameters/power_save_controller
+    fi
+    if [ -d /sys/module/snd_ac97_codec ]; then
+        printparm "%s = ##%s##" /sys/module/snd_ac97_codec/parameters/power_save
+    fi
+    echo
+
+    # -- show docks
+    cnt=0
+    for dock in $DOCKGLOB; do
+        [ ! -d $dock ] && break # no dock/bay detected
+
+        # dock/bay detected, print header
+        [ $cnt -eq 0 ] && echo "+++ Docks and Device Bays"
+        cnt=$((cnt+1))
+
+        # get dock type
+        { read -r dock_type < $dock/type; } 2>/dev/null
+
+        # get dock state
+        if check_is_docked; then
+            # docked
+            case $dock_type in
+                ata_bay)      dock_state="drive present" ;;
+                battery_bay)  dock_state="battery present" ;;
+                dock_station) dock_state="docked" ;;
+
+                *)  dock_state="docked"
+                    dock_type="unknown"
+                    ;;
+            esac
+        else
+            # not docked
+            case $dock_type in
+                ata_bay)      dock_state="no drive (or powered off)" ;;
+                battery_bay)  dock_state="no battery " ;;
+                dock_station) dock_state="undocked" ;;
+
+                *)  dock_state="undocked"
+                    dock_type="unknown"
+                    ;;
+            esac
+        fi
+
+        # print dock data
+        printf "%s: %-13s = %s\n" "$dock" "$dock_type" "$dock_state"
+    done
+    [ $cnt -gt 0 ] && echo
+fi # show_all
+
+if [ "$show_pcie" = "1" ] || [ "$show_all" = "1" ]; then
+    # -- show runtime pm
+    doall=${RUNTIME_PM_ALL:-0}
+
+    echo "+++ Runtime Power Management"
+    if [ "$doall" = "1" ]; then
+        echo "device classes   = all"
+    else
+        echo "device classes   = Ethernet, Wireless, Audio, Host Bridge, [SD] Card Reader, Firewire"
+    fi
+    echo "device blacklist = ${RUNTIME_PM_BLACKLIST:=(not configured)}"
+    echo "driver blacklist = ${RUNTIME_PM_DRIVER_BLACKLIST:=(not configured)}"
+    echo
+
+    if cmd_exists $TLPPCI; then
+        $TLPPCI
+        [ $? -eq 4 ] && no_runtimepm=1
+    else
+        echo "Error: missing subcommand $TLPPCI." 1>&2
+    fi
+    echo
+fi # show_pcie
+
+if [ "$show_usb" = "1" ] || [ "$show_all" = "1" ]; then
+    # -- show usb autosuspend
+    echo "+++ USB"
+    if [ "$USB_AUTOSUSPEND" = "1" ]; then
+        echo "autosuspend        = enabled"
+    else
+        echo "autosuspend        = disabled"
+    fi
+    echo "device whitelist   = ${USB_WHITELIST:=(not configured)}"
+    echo "device blacklist   = ${USB_BLACKLIST:=(not configured)}"
+    if [ "$USB_BLACKLIST_WWAN" = "1" ]; then
+        echo "wwan blacklist     = enabled"
+    else
+        echo "wwan blacklist     = disabled"
+    fi
+    if [ -n "$USB_DRIVER_BLACKLIST" ] && [ "$USB_DRIVER_BLACKLIST" != "usbhid" ]; then
+        echo "***Warning: USB_DRIVER_BLACKLIST is no longer supported, use USB_BLACKLIST."
+    fi
+    echo
+
+    if cmd_exists $TLPUSB; then
+        $TLPUSB
+        [ $? -eq 4 ] && no_runtimepm=1
+    else
+        echo "Error: missing subcommand $TLPUSB." 1>&2
+    fi
+    echo
+
+fi # show_usb
+
+if [ "$show_bat" = "1" ] || [ "$show_all" = "1" ]; then
+    # --- show battery info & charge thresholds
+    bcnt=0
+
+    # --- show availability of ThinkPad battery functions
+    if is_thinkpad; then
+        echo "+++ ThinkPad Extended Battery Functions"
+        echo -n "tp-smapi   = "
+        case $tpsmapi in
+            0)   echo "active" ;;
+            2)   echo "inactive (kernel module 'tp_smapi' load error)" ;;
+            127) echo "inactive (kernel module 'tp_smapi' not installed)" ;;
+            *)   echo "unknown status"
+        esac
+
+        echo -n "tpacpi-bat = "
+        case $tpacpi in
+            0)   echo "active" ;;
+            2)   echo "inactive (kernel module 'acpi_call' load error)" ;;
+            4)   echo "inactive (disabled by user configuration)" ;;
+            127) echo "inactive (kernel module 'acpi_call' not installed)" ;;
+            255) echo "inactive (unsupported hardware)" ;;
+        esac
+        echo
+    fi
+
+    if [ $tpsmapi -eq 0 ]; then
+        # it's a ThinkPad with tp-smapi
+
+        for batd in $SMAPIDIR/BAT[01]; do
+            if [ -d $batd ]; then
+                batt=${batd##/*/}
+
+                if check_tp_battery $batt; then # battery is present
+                    case $bat_idx in
+                        1) echo "+++ ThinkPad Battery Status: $batt (Main / Internal)" ;;
+                        2) echo "+++ ThinkPad Battery Status: $batt (Ultrabay / Slice / Replaceable)" ;;
+                        0) echo "+++ ThinkPad Battery Status: $batt" ;;
+                    esac
+
+                    printparm "%-59s = ##%s##" $batd/manufacturer
+                    printparm "%-59s = ##%s##" $batd/model
+                    printparm "%-59s = ##%s##" $batd/manufacture_date
+                    printparm "%-59s = ##%s##" $batd/first_use_date
+                    printparm "%-59s = ##%6d##" $batd/cycle_count
+                    printparm "%-59s = ##%6d## [mWh]" $batd/design_capacity
+                    printparm "%-59s = ##%6d## [mWh]" $batd/last_full_capacity
+                    printparm "%-59s = ##%6d## [mWh]" $batd/remaining_capacity
+                    printparm "%-59s = ##%6d## [%%]" $batd/remaining_percent
+                    printparm "%-59s = ##%6s## [min]" $batd/remaining_running_time_now
+                    printparm "%-59s = ##%6s## [min]" $batd/remaining_charging_time
+                    printparm "%-59s = ##%6d## [mW]" $batd/power_now
+                    printparm "%-59s = ##%6d## [mW]" $batd/power_avg
+                    print_tp_batstate $batd/state
+                    echo
+                    if [ $show_verbose -eq 1 ]; then
+                        printparm "%-59s = ##%6s## [mV]" $batd/group0_voltage
+                        printparm "%-59s = ##%6s## [mV]" $batd/group1_voltage
+                        printparm "%-59s = ##%6s## [mV]" $batd/group2_voltage
+                        printparm "%-59s = ##%6s## [mV]" $batd/group3_voltage
+                        echo
+                    fi
+
+                    if [ $tpacpi -eq 0 ]; then
+                        # --- show ThinkPad charge thresholds via tpacpi-bat
+                        print_tpacpi_thresholds $batt $bat_idx
+                    else
+                        # show thresholds via tp-smapi
+                        printparm "%-59s = ##%6d## [%%]" $batd/start_charge_thresh
+                        printparm "%-59s = ##%6d## [%%]" $batd/stop_charge_thresh
+                        printparm "%-59s = ##%6d##" $batd/force_discharge
+                    fi
+                    echo
+
+                    bcnt=$(($bcnt+1))
+                fi
+            fi
+        done
+    elif [ -d $ACPIBATDIR ]; then
+        # --- show ACPI data
+
+        for batd in $ACPIBATDIR/*; do
+            batt=${batd##/*/}
+            tpbat=0
+
+            if check_tp_battery $batt; then
+                # ThinkPad battery is present
+                tpbat=1
+
+                if [ $tpacpi -eq 0 ]; then
+                    # it's a ThinkPad with tpacpi-bat only
+                    case $bat_idx in
+                        1) echo "+++ ThinkPad Battery Status: $batt (Main / Internal)" ;;
+                        2) echo "+++ ThinkPad Battery Status: $batt (Ultrabay / Slice / Replaceable)" ;;
+                        0) echo "+++ ThinkPad Battery Status: $batt" ;;
+                    esac
+                else
+                   # it's a ThinkPad with neither tp-smapi nor tpacpi-bat
+                    echo "+++ Battery Status"
+                fi
+            elif [ -d $batd ] \
+                 && [ "$(cat $batd/type)" = "Battery" ] \
+                 && [ "$(cat $batd/present)" = "1" ]; then
+                    # it's some other laptop model or brand
+                    echo "+++ Battery Status"
+            else
+                batt="" # power supply is not a battery
+            fi
+
+            if [ -n "$batt" ]; then
+                printparm "%-59s = ##%s##" $batd/manufacturer
+                printparm "%-59s = ##%s##" $batd/model_name
+
+                cc=$(cat $batd/cycle_count 2> /dev/null)
+                if [ $? -eq 0 ] && [ -n "$cc" ] && [ $cc -gt 0 ]; then
+                    printf "%-59s = %6d\n" $batd/cycle_count $cc
+                else
+                    printf "%-59s = (not supported)\n" $batd/cycle_count
+                fi
+
+                if [ -f $batd/energy_full ]; then
+                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_full_design "" 000
+                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_full "" 000
+                    printparm "%-59s = ##%6d## [mWh]" $batd/energy_now "" 000
+                    printparm "%-59s = ##%6d## [mW]" $batd/power_now "" 000
+                elif [ -f $batd/charge_full ]; then
+                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_full_design "" 000
+                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_full "" 000
+                    printparm "%-59s = ##%6d## [mAh]" $batd/charge_now "" 000
+                    printparm "%-59s = ##%6d## [mA]" $batd/current_now "" 000
+                fi
+                if [ $tpbat -eq 1 ]; then
+                    print_tp_batstate $batd/status
+                else
+                    printparm "%-59s = ##%s##" $batd/status
+                fi
+                echo
+
+                if [ $tpacpi -eq 0 ]; then
+                    # --- show ThinkPad charge thresholds via tpacpi-bat
+                    print_tpacpi_thresholds $batt $bat_idx
+                    echo
+                fi # if $tpcacpi
+
+                bcnt=$(($bcnt+1))
+            fi # if $batt
+        done # $batd
+
+    fi # if /sys/class/power_supply
+
+    if [ $bcnt -eq 0 ]; then
+        printf "+++ Battery Status\n"
+        printf "No batteries detected.\n\n"
+    fi
+
+fi # show_bat
+
+if [ "$show_warn" = "1" ] || [ "$show_disk" = "1" ] || [ "$show_all" = "1" ]; then
+    # --- show warnings
+    # ata errors (possibly) caused by SATA_LINKPWR_ON_AC/BAT != max_performance
+    ecnt=$( check_ata_errors )
+    if [ $ecnt -ne 0 ]; then
+        echo "+++ Warnings"
+        printf "* Kernel log shows ata errors (%d) possibly caused by the configuration\n" $ecnt
+        printf "  SATA_LINKPWR_ON_AC/BAT=min_power or medium_power.\n"
+        printf "  Consider using medium_power or max_performance instead.\n"
+        printf "  See the FAQ: http://linrunner.de/en/tlp/docs/tlp-faq.html#warnings\n"
+        printf "  Details:\n"
+        dmesg | egrep -A 5 "ata[0-9]+: SError: { .*CommWake }"
+        echo
+    elif [ "$show_warn" = "1" ]; then
+        echo "No warnings detected."
+        echo ""
+    fi
+
+fi # show_warn
+
+if [ "$show_all" = "1" ]; then
+    # -- show suggestions
+    suout=""
+
+    if [ "$no_runtimepm" = "1" ]; then
+        suout="${suout}Reconfigure your Linux kernel with PM_RUNTIME=y to reduce your laptop's power consumption.\n"
+    fi
+
+    if is_thinkpad; then
+        # Add ThinkPad specific suggestions
+        model="$( read_dmi product_version )"
+        model=${model#ThinkPad }
+        model=${model#Edge }
+
+        case $model in
+            "X1 Carbon*"|X2[345]0*|T[45][345][01]*|W5[345][01]*|L[45][345]0|E[1345][05]|S[245][345][01]*)
+                [ $tpacpi -eq 127 ]  && suout="${suout}Install acpi-call kernel module for ThinkPad advanced battery functions\n"
+                ;;
+
+            X1|X220*|T420*|T520|W520)
+                [ $tpacpi -eq 127 ]  && suout="${suout}Install acpi-call kernel module for ThinkPad advanced battery functions\n"
+                [ $tpsmapi -eq 127 ] && suout="${suout}Install tp-smapi kernel modules for ThinkPad advanced battery functions\n"
+                ;;
+
+            SL?00) ;;
+
+            *) [ $tpsmapi -eq 127 ]  && suout="${suout}Install tp-smapi kernel modules for ThinkPad advanced battery functions\n"
+                ;;
+        esac
+
+    fi # if ThinkPad
+
+    # Add other suggestions
+    cmd_exists ethtool || suout="${suout}Install ethtool to disable Wake On LAN (WOL)\n"
+    cmd_exists smartctl || suout="${suout}Install smartmontools for disk drive health info\n"
+
+    if [ -n "$suout" ]; then
+        echo "+++ Suggestions"
+        printf "$suout" | sed -r 's/^/\* /'
+        echo
+    fi
+
+fi # show_all
+
+if [ "$show_trace" = "1" ]; then
+    # --- show debug log
+
+    # check for systemd journal
+    jdone=0
+    if cmd_exists $JOURNALCTL; then
+        # retrieve trace output from journal
+        $JOURNALCTL -p debug --no-pager SYSLOG_IDENTIFIER=tlp 2> /dev/null
+        # check result -- rc=1 if journald has no data available
+        [ $? -eq 0 ] && jdone=1
+    fi
+
+    if [ "$jdone" = "0"  ]; then
+        # no journald data available --> retrieve trace output from logfile
+        if [ -f $DEBUGLOG ]; then
+            grep "tlp\[" $DEBUGLOG
+        else
+            echo "Error: $DEBUGLOG does not exist." 1>&2
+            echo 1>&2
+            echo "Solution: create an rsyslog conffile /etc/rsyslog.d/90-debug.conf with the following contents" 1>&2
+            echo " *.=debug;\\" 1>&2
+            echo " mail,authpriv,cron.none;\\" 1>&2
+            echo " local0,local1,local3,local4,\\" 1>&2
+            echo " local5,local6,local7.none    -/var/log/debug" 1>&2
+            echo "and restart the rsyslog daemon." 1>&2
+            echo 1>&2
+        fi
+    fi
+fi # show_trace
+
+exit 0
diff --git a/tlp-usb-udev b/tlp-usb-udev
deleted file mode 100755
index 917fc5c..0000000
--- a/tlp-usb-udev
+++ /dev/null
@@ -1,152 +0,0 @@
-#!/bin/sh
-# tlp - handle added usb devices
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# Remark: the calling udev rule is triggered for "base" devices only,
-#         not for the corresponding subdevices. 
-
-# --- Constants
-readonly LOGGER=logger
-
-readonly USBD=/sys/bus/usb/devices
-readonly USB_TIMEOUT=2
-readonly USB_TIMEOUT_MS=2000
-readonly USB_WWAN_VENDORS="0bdb 05c6 1199"
-
-readonly RUNDIR=/var/run/tlp
-readonly USB_DONE=usb_done
-
-readonly CONFFILE=/etc/default/tlp
-
-# --- Subroutines
-wordinlist () { # test if word in list
-                # $1: word, $2: whitespace-separated list of words
-    local word
-
-    if [ -n "${1-}" ]; then
-        for word in ${2-}; do
-            [ "${word}" != "${1}" ] || return 0 # exact match
-        done
-    fi
-
-    return 1 # no match
-}
-
-echo_debug () { # $1: tag; $2: msg; echo debug msg if tag matches
-    if wordinlist "$1" "$TLP_DEBUG"; then
-        $LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
-    fi
-}
-
-# --- MAIN
-
-# read config
-[ -f $CONFFILE ] || exit 0
-. $CONFFILE
-
-# exit if TLP or autosuspend disabled
-[ "$TLP_ENABLE" = "1" ] && [ "$USB_AUTOSUSPEND" = "1" ] || exit 0
-
-# USB autosuspend has two principal operation modes:
-#
-# Mode 1 (optional):
-# - System startup is handled by tlp-functions:set_usb_suspend()
-# - Startup completion is signaled by "flag file" $USB_DONE
-# - Newly added devices are handled by this udev script
-# - Mode 1 is enabled by the private config variable X_TLP_USB_MODE=1
-#
-# Mode 2 (default):
-# - Everything - including system startup, but not shutdown - is handled by this udev script
-
-# do exit if mode 1 and no startup completion flag
-[ "$X_TLP_USB_MODE" = "1" ] && [ ! -f $RUNDIR/$USB_DONE ] && exit 0
-
-# get args
-usbdev=/sys$1
-
-# handle device
-if [ -f $usbdev/power/autosuspend ] || [ -f $usbdev/power/autosuspend_delay_ms ]; then
-    # device is autosuspendable
-
-    # apply autosuspend
-    ctrlf="control"
-    autof="autosuspend_delay_ms"
-    usbid="$(cat $usbdev/idVendor):$(cat $usbdev/idProduct)"
-    busdev="Bus $(cat $usbdev/busnum) Dev $(cat $usbdev/devnum)"
-    control="auto"
-    exc=""
-    chg=0
-
-    if wordinlist "$usbid" "$USB_WHITELIST"; then
-        # device is in whitelist -- whitelist always wins
-        control="auto"
-        exc="_dev_white"
-    elif wordinlist "$usbid" "$USB_BLACKLIST"; then
-        # device is in blacklist
-        control="on"
-        exc="_dev_black"
-    else
-        # wait for subdevices to populate
-        sleep 0.5
-
-        # check for hid subdevices
-        for subdev in $usbdev/*:*; do
-            if [ -d $subdev ] && [ "$(cat $subdev/bInterfaceClass)" = "03" ]; then
-                control="on"
-                exc="_hid_black"
-                break
-            fi
-        done
-
-        if [ -z "$exc" ]; then
-            # check for wwan vendor ids
-            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
-
-            if [ $USB_BLACKLIST_WWAN = "1" ]; then
-                vendor="$(cat $usbdev/idVendor)"
-                if wordinlist "$vendor" "$USB_WWAN_VENDORS"; then
-                    control="on"
-                    exc="_wwan_black"
-                fi
-            fi
-        fi
-    fi
-
-    if [ -f $usbdev/power/control ]; then
-        if [ "$(cat $usbdev/power/control)" != "$control" ]; then
-            # Write actual changes only
-            echo "$control" > $usbdev/power/control
-            chg=1
-        fi
-    else
-        # level is deprecated
-        if [ "$(cat $usbdev/power/level)" != "$control" ]; then
-            # Write actual changes only
-            echo "$control" > $usbdev/power/level
-            chg=1
-        fi
-        ctrlf="level"
-    fi
-
-    if [ "$X_TLP_USB_SET_AUTOSUSPEND_DELAY" = "1" ]; then
-        # set autosuspend_delay
-        if [ -f $usbdev/power/autosuspend_delay_ms ]; then
-            echo $USB_TIMEOUT_MS > $usbdev/power/autosuspend_delay_ms
-        else
-            # autosuspend is deprecated
-            echo $USB_TIMEOUT > $usbdev/power/autosuspend
-            autof="autosuspend"
-        fi
-        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev [$ctrlf $autof]"
-    elif [ $chg -eq 1 ]; then
-        # default: change control but not autosuspend_delay, i.e. keep kernel default setting
-        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev [$ctrlf]"
-    else
-        # we didn't change anything actually
-        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev"
-    fi
-fi
-
-exit 0
diff --git a/tlp-usb-udev.in b/tlp-usb-udev.in
new file mode 100755
index 0000000..62fab99
--- /dev/null
+++ b/tlp-usb-udev.in
@@ -0,0 +1,152 @@
+#!/bin/sh
+# tlp - handle added usb devices
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# Remark: the calling udev rule is triggered for "base" devices only,
+#         not for the corresponding subdevices. 
+
+# --- Constants
+readonly LOGGER=logger
+
+readonly USBD=/sys/bus/usb/devices
+readonly USB_TIMEOUT=2
+readonly USB_TIMEOUT_MS=2000
+readonly USB_WWAN_VENDORS="0bdb 05c6 1199"
+
+readonly RUNDIR=/var/run/tlp
+readonly USB_DONE=usb_done
+
+readonly CONFFILE=@TLP_CONF@
+
+# --- Subroutines
+wordinlist () { # test if word in list
+                # $1: word, $2: whitespace-separated list of words
+    local word
+
+    if [ -n "${1-}" ]; then
+        for word in ${2-}; do
+            [ "${word}" != "${1}" ] || return 0 # exact match
+        done
+    fi
+
+    return 1 # no match
+}
+
+echo_debug () { # $1: tag; $2: msg; echo debug msg if tag matches
+    if wordinlist "$1" "$TLP_DEBUG"; then
+        $LOGGER -p debug -t "tlp[$$,$PPID]" "$2"
+    fi
+}
+
+# --- MAIN
+
+# read config
+[ -f $CONFFILE ] || exit 0
+. $CONFFILE
+
+# exit if TLP or autosuspend disabled
+[ "$TLP_ENABLE" = "1" ] && [ "$USB_AUTOSUSPEND" = "1" ] || exit 0
+
+# USB autosuspend has two principal operation modes:
+#
+# Mode 1 (optional):
+# - System startup is handled by tlp-functions:set_usb_suspend()
+# - Startup completion is signaled by "flag file" $USB_DONE
+# - Newly added devices are handled by this udev script
+# - Mode 1 is enabled by the private config variable X_TLP_USB_MODE=1
+#
+# Mode 2 (default):
+# - Everything - including system startup, but not shutdown - is handled by this udev script
+
+# do exit if mode 1 and no startup completion flag
+[ "$X_TLP_USB_MODE" = "1" ] && [ ! -f $RUNDIR/$USB_DONE ] && exit 0
+
+# get args
+usbdev=/sys$1
+
+# handle device
+if [ -f $usbdev/power/autosuspend ] || [ -f $usbdev/power/autosuspend_delay_ms ]; then
+    # device is autosuspendable
+
+    # apply autosuspend
+    ctrlf="control"
+    autof="autosuspend_delay_ms"
+    usbid="$(cat $usbdev/idVendor):$(cat $usbdev/idProduct)"
+    busdev="Bus $(cat $usbdev/busnum) Dev $(cat $usbdev/devnum)"
+    control="auto"
+    exc=""
+    chg=0
+
+    if wordinlist "$usbid" "$USB_WHITELIST"; then
+        # device is in whitelist -- whitelist always wins
+        control="auto"
+        exc="_dev_white"
+    elif wordinlist "$usbid" "$USB_BLACKLIST"; then
+        # device is in blacklist
+        control="on"
+        exc="_dev_black"
+    else
+        # wait for subdevices to populate
+        sleep 0.5
+
+        # check for hid subdevices
+        for subdev in $usbdev/*:*; do
+            if [ -d $subdev ] && [ "$(cat $subdev/bInterfaceClass)" = "03" ]; then
+                control="on"
+                exc="_hid_black"
+                break
+            fi
+        done
+
+        if [ -z "$exc" ]; then
+            # check for wwan vendor ids
+            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
+
+            if [ $USB_BLACKLIST_WWAN = "1" ]; then
+                vendor="$(cat $usbdev/idVendor)"
+                if wordinlist "$vendor" "$USB_WWAN_VENDORS"; then
+                    control="on"
+                    exc="_wwan_black"
+                fi
+            fi
+        fi
+    fi
+
+    if [ -f $usbdev/power/control ]; then
+        if [ "$(cat $usbdev/power/control)" != "$control" ]; then
+            # Write actual changes only
+            echo "$control" > $usbdev/power/control
+            chg=1
+        fi
+    else
+        # level is deprecated
+        if [ "$(cat $usbdev/power/level)" != "$control" ]; then
+            # Write actual changes only
+            echo "$control" > $usbdev/power/level
+            chg=1
+        fi
+        ctrlf="level"
+    fi
+
+    if [ "$X_TLP_USB_SET_AUTOSUSPEND_DELAY" = "1" ]; then
+        # set autosuspend_delay
+        if [ -f $usbdev/power/autosuspend_delay_ms ]; then
+            echo $USB_TIMEOUT_MS > $usbdev/power/autosuspend_delay_ms
+        else
+            # autosuspend is deprecated
+            echo $USB_TIMEOUT > $usbdev/power/autosuspend
+            autof="autosuspend"
+        fi
+        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev [$ctrlf $autof]"
+    elif [ $chg -eq 1 ]; then
+        # default: change control but not autosuspend_delay, i.e. keep kernel default setting
+        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev [$ctrlf]"
+    else
+        # we didn't change anything actually
+        echo_debug "usb" "udev_usb.$control$exc: $busdev ID $usbid $usbdev"
+    fi
+fi
+
+exit 0
diff --git a/tlp.in b/tlp.in
new file mode 100755
index 0000000..96ff971
--- /dev/null
+++ b/tlp.in
@@ -0,0 +1,288 @@
+#!/bin/sh
+# tlp - adjust power settings
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# --- Constants
+readonly LIBDIRS="/usr/lib/tlp-pm /usr/lib64/tlp-pm @TLP_TLIB@"
+readonly LIBS="tlp-functions tlp-rf-func"
+
+# --- Locate and source libraries
+for libdir in $LIBDIRS; do [ -d $libdir ] && break; done
+if [ ! -d $libdir ]; then
+    echo "Error: missing library directory ($LIBDIRS)." 1>&2
+    exit 1
+fi
+
+for lib in $LIBS; do
+    if [ ! -f $libdir/$lib ]; then
+        echo "Error: missing function library \'$libdir/$lib\'." 1>&2
+        exit 1
+    fi
+    . $libdir/$lib
+done
+
+# --- Subroutines
+apply_common_settings () { # apply settings common to all modes
+                           # $1: 0=ac mode, 1=battery mode
+    load_modules
+
+    set_laptopmode $1
+    set_dirty_parms $1
+    set_scaling_governor $1
+    set_scaling_min_max_freq $1
+    set_cpu_perf_pct $1
+    set_cpu_boost_all $1
+    set_sched_powersave $1
+    set_nmi_watchdog
+    set_phc_controls $1
+    set_energy_perf_policy $1
+    set_disk_apm_level $1
+    set_disk_spindown_timeout $1
+    set_disk_io_sched
+    set_sata_link_power $1
+    set_pcie_aspm $1
+    set_radeon_profile $1
+    set_wifi_power_mode $1
+    disable_wake_on_lan
+    set_sound_power_mode $1
+    set_runtime_pm $1
+
+    return 0
+}
+
+# --- MAIN
+read_defaults
+check_tlp_enabled || exit 1
+add_sbin2path
+
+check_laptop_mode_tools
+
+# get cmd line args
+mode=$(echo $1 | tr "[:upper:]" "[:lower:]")
+mode2=$(echo $2 | tr "[:upper:]" "[:lower:]")
+
+# inhibit trace output for tlp stat
+[ "$mode" = "stat" ] && nodebug=1
+
+# get current power state
+get_power_state
+pwrmode=$?
+
+modedebug=$mode
+[ -n "$mode2" ] && modedebug="$modedebug $mode2"
+echo_debug "run" "+++ mode=$modedebug ($TLPVER) ++++++++++++++++++++++++++++++++++++++++"
+
+if [ -n "$addpath" ]; then
+    echo_debug "path" "PATH=$oldpath[$addpath]"
+else
+    echo_debug "path" "PATH=$oldpath"
+fi
+
+if [ $pwrmode -eq 1 ]; then
+    echo_debug "run" "power_source=bat"
+else
+    echo_debug "run" "power_source=ac"
+fi
+
+exitcode=0
+
+case "$mode" in
+    init) # system initialization/shutdown: sysv, upstart, systemd, ...
+        check_root
+
+        case $mode2 in
+            start|restart|force-reload)
+                echo -n "Loading kernel modules..."
+                load_modules
+                echo "done. "
+
+                # apply settings
+                set_radio_device_states start
+
+                echo -n "Applying power save settings..."
+                apply_common_settings $pwrmode
+                [ "$pwrmode" = "1" ] && poweroff_drivebay 0
+                [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
+                echo "done."
+
+                echo -n "Setting battery charge thresholds..."
+                set_charge_thresholds
+                echo "done."
+                ;;
+
+            stop)
+                set_radio_device_states stop
+
+                if [ "$USB_AUTOSUSPEND_DISABLE_ON_SHUTDOWN" = "1" ]; then
+                    echo -n "Disabling usb autosuspend..."
+                    set_usb_suspend 0 on
+                    echo "done."
+                fi
+
+                # remove usb startup flag
+                [ -f $USB_DONE ] && rm $USB_DONE
+
+                # apply ac settings for faster shutdown
+                echo -n "Applying power save settings..."
+                apply_common_settings 0
+                echo "done."
+                ;;
+
+            *)
+                echo "Usage: tlp init {start|stop|restart|force-reload}" >&2
+                exit 3
+                ;;
+        esac
+        ;;
+
+    auto) # set mode depending on state (called by udev rule)
+        check_root
+        apply_common_settings $pwrmode
+        [ "$pwrmode" = "1" ] && poweroff_drivebay 0
+        set_radio_device_states $pwrmode
+        ;;
+
+    start) # set mode depending on state (interactive mode)
+        check_root
+        apply_common_settings $pwrmode
+        [ "$pwrmode" = "1" ] && poweroff_drivebay 0
+        set_usb_suspend 0 auto
+        set_charge_thresholds
+        set_radio_device_states $pwrmode
+
+        echo_started_mode $pwrmode
+        ;;
+
+    true|bat*) # set battery power mode
+        check_root
+        apply_common_settings 1
+        poweroff_drivebay 0
+        [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
+        set_radio_device_states 1
+
+        echo_started_mode 1
+        ;;
+
+    false|ac) # set ac power mode
+        check_root
+        apply_common_settings 0
+        [ "$X_TLP_USB_MODE" = "1" ] && set_usb_suspend 0 auto
+        set_radio_device_states 0
+
+        echo_started_mode 0
+        ;;
+
+    suspend) # handle suspend/hibernate
+        check_root
+        save_device_states "bluetooth wwan"
+
+        get_power_state
+        pwrmode=$?
+        apply_common_settings 0
+        suspend_drivebay $pwrmode
+        ;;
+
+    resume) # handle resume
+        check_root
+        restore_device_states
+
+        get_power_state
+        pwrmode=$?
+        apply_common_settings $pwrmode
+        resume_drivebay
+        ;;
+
+    usb) # Enable usb autosuspend
+        check_root
+        set_usb_suspend 1 auto
+        ;;
+
+    bayoff) # power off drive bay
+        check_root
+        poweroff_drivebay 1
+        ;;
+
+    setcharge) # set charge thresholds (temporarily)
+        check_root
+        load_modules
+        setcharge_battery $2 $3 $4
+        exitcode=$?
+        ;;
+
+    fullcharge) # charge battery up to 100% (temporarily)
+        if check_ac_power fullcharge; then
+            check_root
+            load_modules
+            setcharge_battery 96 100 $2
+            exitcode=$?
+        else
+            exitcode=2
+        fi
+        ;;
+
+    chargeonce) # charge battery to upper threshold once
+        if check_ac_power chargeonce; then
+            check_root
+            load_modules
+            chargeonce_battery $2
+            exitcode=$?
+        else
+            exitcode=2
+        fi
+        ;;
+
+    discharge) # discharge battery completely (to recalibrate)
+        if check_ac_power discharge; then
+            check_root
+            load_modules
+            discharge_battery $2
+            exitcode=$?
+        else
+            exitcode=2
+        fi
+        ;;
+
+    recalibrate) # recalibrate battery, i.e. discharge and charge to 100%
+        if check_ac_power recalibrate; then
+            check_root
+            load_modules
+            setcharge_battery 96 100 $2
+            sleep 1
+            discharge_battery $2
+            exitcode=$?
+            if [ $exitcode -eq 0 ]; then
+                echo "      The battery starts charging now. For a complete recalibration"
+                echo "      keep AC connected until the battery is fully charged."
+            fi
+        else
+            exitcode=2
+        fi
+        ;;
+
+    stat) # show status
+        shift
+        tlp-stat $*
+        exitcode=$?
+        ;;
+
+    diskid) # show disk-by-id
+        { for dev in $(ls /dev/disk/by-id/ | egrep '^ata' | egrep -v '\-part[1-9]+'); do
+            if [ -n "$dev" ]; then
+                get_disk_dev $dev
+                echo "$disk_dev: $disk_id"
+            fi
+        done } | sort
+        ;;
+
+    *)
+        echo "Error: unknown command \"$mode\"."  1>&2
+        echo "Usage: tlp start|true|bat|false|ac|usb|bayoff|discharge|setcharge|fullcharge|recalibrate|stat|diskid" 1>&2
+        exitcode=3
+        ;;
+esac
+
+exit $exitcode
+
+
diff --git a/tlp.rules b/tlp.rules
deleted file mode 100644
index f4a6897..0000000
--- a/tlp.rules
+++ /dev/null
@@ -1,10 +0,0 @@
-# tlp - udev rules
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-# handle change of power source ac/bat
-ACTION=="change", SUBSYSTEM=="power_supply", ATTR{type}=="Mains", RUN+="/usr/sbin/tlp auto"
-
-# handle added usb devices (exclude subdevices via DRIVER=="USB")
-ACTION=="add", SUBSYSTEM=="usb", DRIVER=="usb", ENV{DEVTYPE}=="usb_device", RUN+="/lib/udev/tlp-usb-udev %p"
diff --git a/tlp.rules.in b/tlp.rules.in
new file mode 100644
index 0000000..8bd8b10
--- /dev/null
+++ b/tlp.rules.in
@@ -0,0 +1,10 @@
+# tlp - udev rules
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+# handle change of power source ac/bat
+ACTION=="change", SUBSYSTEM=="power_supply", ATTR{type}=="Mains", RUN+="@TLP_SBIN@/tlp auto"
+
+# handle added usb devices (exclude subdevices via DRIVER=="USB")
+ACTION=="add", SUBSYSTEM=="usb", DRIVER=="usb", ENV{DEVTYPE}=="usb_device", RUN+="@TLP_ULIB@/tlp-usb-udev %p"
diff --git a/tlp.service b/tlp.service
deleted file mode 100644
index 2ff5e60..0000000
--- a/tlp.service
+++ /dev/null
@@ -1,19 +0,0 @@
-# tlp - systemd startup/shutdown service
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-[Unit]
-Description=TLP system startup/shutdown
-Wants=bluetooth.service NetworkManager.service
-After=multi-user.target bluetooth.service NetworkManager.service
-Before=shutdown.target
-
-[Service]
-Type=simple
-RemainAfterExit=yes
-ExecStart=/usr/sbin/tlp init start
-ExecStop=/usr/sbin/tlp init stop
-
-[Install]
-WantedBy=multi-user.target
diff --git a/tlp.service.in b/tlp.service.in
new file mode 100644
index 0000000..66a8826
--- /dev/null
+++ b/tlp.service.in
@@ -0,0 +1,19 @@
+# tlp - systemd startup/shutdown service
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+[Unit]
+Description=TLP system startup/shutdown
+Wants=bluetooth.service NetworkManager.service
+After=multi-user.target bluetooth.service NetworkManager.service
+Before=shutdown.target
+
+[Service]
+Type=simple
+RemainAfterExit=yes
+ExecStart=@TLP_SBIN@/tlp init start
+ExecStop=@TLP_SBIN@/tlp init stop
+
+[Install]
+WantedBy=multi-user.target
diff --git a/tlp.upstart b/tlp.upstart
deleted file mode 100644
index af5a94b..0000000
--- a/tlp.upstart
+++ /dev/null
@@ -1,25 +0,0 @@
-# tlp - system startup/shutdown
-#
-# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
-# This software is licensed under the GPL v2 or later.
-
-description "tlp"
-
-start on ( virtual-filesystems and runlevel [2345] )
-stop on runlevel [!2345]
-
-env TLP=/usr/sbin/tlp
-
-pre-start script
-    [ -x $TLP ] || exit 4
-    $TLP init start
-
-end script
-
-post-stop script
-    [ -x $TLP ] || exit 4
-    $TLP init stop
-
-end script
-
-
diff --git a/tlp.upstart.in b/tlp.upstart.in
new file mode 100644
index 0000000..121c0e0
--- /dev/null
+++ b/tlp.upstart.in
@@ -0,0 +1,25 @@
+# tlp - system startup/shutdown
+#
+# Copyright (c) 2015 Thomas Koch <linrunner at gmx.net>
+# This software is licensed under the GPL v2 or later.
+
+description "tlp"
+
+start on ( virtual-filesystems and runlevel [2345] )
+stop on runlevel [!2345]
+
+env TLP=@TLP_SBIN@/tlp
+
+pre-start script
+    [ -x $TLP ] || exit 4
+    $TLP init start
+
+end script
+
+post-stop script
+    [ -x $TLP ] || exit 4
+    $TLP init stop
+
+end script
+
+
-- 
2.5.0

